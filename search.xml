<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于浮躁]]></title>
    <url>%2F2022%2F04%2F28%2F%E5%85%B3%E4%BA%8E%E6%B5%AE%E8%BA%81%2F</url>
    <content type="text"><![CDATA[关于浮躁 ​ 事情不是用来完成的，它是用来体验的。做事不专心，就难以品尝其中的乐趣。当你讨厌什么的时，你总是会遇到它，而且还无法逃避，这会给你带来困惑，因为你不知道究竟发生了什么，所以，你很容易处在焦虑、烦躁与混乱中。 ​ 事情不是用来完成的，它是用来体验的。通过体验，你才能认识更高的自己，才能意识到自己的广阔和自由。如果把事情当成负担，你就无法走得更远，而且很容易变得消沉，没有动力。做事得乐趣在于深入事情的内部，只有到达了那个层面，奥秘才会展示出来，而且，它还会带出你更多的品质，也同时会减少你的焦虑与不安。你可以试一下。在做事时，尽量做好每个细节，让细节来稳定你的心态。只要心态平稳了，你的信心就会增强，而且你还会认真对待来到你面前的每件事。事情没有大小，只有全心或不全心。 ​ 你只要建立全心做事的品质，你就能把这种品质延伸到其他的事情中去。这样一来，你就会发现你的确是很能干的。]]></content>
      <categories>
        <category>心理</category>
      </categories>
      <tags>
        <tag>心理</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[124-二叉树中的最大路径和]]></title>
    <url>%2F2021%2F03%2F26%2F124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 示例 1： 123输入：root = [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6 示例 2： 123输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42 提示： 树中节点数目范围是 [1, 3 * 104] -1000 &lt;= Node.val &lt;= 1000 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int MaxVal=Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; dfs(root); return MaxVal; &#125; public int dfs(TreeNode root) &#123; if(root==null) return 0; //找左子树的最大路径(降序：从上往下) int leftval=Math.max(dfs(root.left),0); //找右子树的最大路径(降序：从上往下) int rightval=Math.max(dfs(root.right),0); //计算当前节点的最大路径 int newpathval=root.val+leftval+rightval; //更新最大路径和 MaxVal=Math.max(MaxVal,newpathval); //返回当前节点的最大路径和(从上往下) return root.val+Math.max(leftval,rightval); &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer40-最小的k个数]]></title>
    <url>%2F2020%2F09%2F02%2F%E5%89%91%E6%8C%87Offer40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 12输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1] 示例 2： 12输入：arr = [0,1,2,1], k = 1输出：[0] 限制： 0 &lt;= k &lt;= arr.length &lt;= 100000 &lt;= arr[i] &lt;= 10000 解题思路一用优先队列 12345678910111213141516171819202122232425262728class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if(k==0||arr.length==0) return new int[]&#123;&#125;; PriorityQueue&lt;Integer&gt; queue=new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;()&#123; //@Override public int compare(Integer a,Integer b) &#123; return b-a; &#125; &#125;); for(int i=0; i&lt;arr.length; i++) &#123; if(queue.size()&lt;k) queue.offer(arr[i]); else if(arr[i]&lt;queue.peek()) &#123; queue.poll(); queue.offer(arr[i]); &#125; &#125; int [] res=new int[queue.size()]; int cout=0; for(int temp:queue) res[cout++]=temp; return res; &#125;&#125; 解题思路二用快速排序的思想]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 68-II 二叉树的最近公共祖先]]></title>
    <url>%2F2020%2F08%2F05%2F%E5%89%91%E6%8C%87Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 原题链接 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 解题思路参考这篇文章 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||p==root||q==root) return root; TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left==null&amp;&amp;right==null) return null; if(left==null) return right; if(right==null) return left; return root; &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 68-I 二叉搜索树的最近公共祖先]]></title>
    <url>%2F2020%2F08%2F04%2F%E5%89%91%E6%8C%87Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(p.val&lt;root.val&amp;&amp;q.val&lt;root.val) return lowestCommonAncestor(root.left,p,q); if(p.val&gt;root.val&amp;&amp;q.val&gt;root.val) return lowestCommonAncestor(root.right,p,q); return root; &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 64-求1加到n]]></title>
    <url>%2F2020%2F08%2F04%2F%E5%89%91%E6%8C%87Offer-64-%E6%B1%821%E5%8A%A0%E5%88%B0n%2F</url>
    <content type="text"><![CDATA[题目描述求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 12输入: n = 3输出: 6 示例 2： 12输入: n = 9输出: 45 限制： 1 &lt;= n &lt;= 10000 解题思路这道题很特殊，解题思路也很特别，用逻辑运算符，参考文章 12345678class Solution &#123; int res=0; public int sumNums(int n) &#123; boolean a=n&gt;0&amp;&amp;sumNums(n-1)&gt;0; res+=n; return res; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 63-股票的最大利润]]></title>
    <url>%2F2020%2F08%2F04%2F%E5%89%91%E6%8C%87Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%2F</url>
    <content type="text"><![CDATA[题目描述假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制： 10 &lt;= 数组长度 &lt;= 10^5 解题思路用暴力也可以过，每遍历一次价格，就和后面的所有价格进行比较，统计最大的利润差 123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int max=0; for(int i=0; i&lt;prices.length; i++) &#123; for(int j=i+1; j&lt;prices.length; j++) &#123; int temp=prices[j]-prices[i]; if(temp&gt;max) max=temp; &#125; &#125; return max; &#125;&#125; 用动态规划时间复杂度更低，dp[i]表示第i天能获得的最大利润，状态转移公式为dp[i]=max(dp[i-1],prices[i]-(前i天的最低价格))， 1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; int len=prices.length; if(len==0) return 0; int [] dp=new int [len]; dp[0]=0; int cost=prices[0]; for(int i=1; i&lt;len; i++) &#123; if(prices[i]&lt;cost) cost=prices[i]; dp[i]=Math.max(dp[i-1],prices[i]-cost); &#125; return dp[len-1]; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 62-圆圈中最后剩下的数字]]></title>
    <url>%2F2020%2F08%2F04%2F%E5%89%91%E6%8C%87Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1： 12输入: n = 5, m = 3输出: 3 示例 2： 12输入: n = 10, m = 17输出: 2 限制： 1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 解题思路我想用数组标记，每次经过m步后，就把对应的位置标记为已访问。循环n次后，最后标记的就是最后一个位置，我们想要的结果，但是超时了。。。 12345678910111213141516171819202122232425262728class Solution &#123; public int lastRemaining(int n, int m) &#123; int [] visit=new int [n]; int i=0; int step=-1; while(i&lt;n) &#123; for(int j=1; j&lt;=m; j++) &#123; step++; if(step==n) step=step%n; while(visit[step]==1) &#123; step++; if(step==n) step=step%n; &#125; &#125; visit[step]=1; if(step==n) step=step%n; //System.out.println(step); i++; &#125; return step; &#125;&#125; 这是著名的约瑟夫环问题，看了别人的解法,我总结如下： 我们每次删除的是第m个数字 第一次是0,1,2,3,4,在后面加上0,1,2,3,4,这一次删除的是2 第二次是从3开始的，3,4,0,1,3,4,0,1，这一次 删除的是0 第三次是从1开始的，1,3,4,1,3,4，这一次 删除的是4 第三次是从1开始的，1,3,1,3，这一次 删除的是1 最后剩下的就是3了 然后我们从最后剩下的 3 倒着看，我们可以反向推出这个数字在之前每个轮次的位置。 最后剩下的 3 的下标是 0。 第四轮反推，补上 m 个位置，然后模上当时的数组大小 2，位置是(0 + 3) % 2 = 1。 第三轮反推，补上 m 个位置，然后模上当时的数组大小 3，位置是(1 + 3) % 3 = 1。 第二轮反推，补上 m 个位置，然后模上当时的数组大小 4，位置是(1 + 3) % 4 = 0。 第一轮反推，补上 m 个位置，然后模上当时的数组大小 5，位置是(0 + 3) % 5 = 3。 所以最终剩下的数字的下标就是3。因为数组是从0开始的，所以最终的答案就是3。 总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。 12345678910class Solution &#123; public int lastRemaining(int n, int m) &#123; int index=0; for(int i=2; i&lt;=n; i++) &#123; index=(index+m)%i; &#125; return index; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 61-扑克牌中的顺子]]></title>
    <url>%2F2020%2F08%2F04%2F%E5%89%91%E6%8C%87Offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目描述从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 示例 1: 12输入: [1,2,3,4,5]输出: True 示例 2: 12输入: [0,0,1,2,5]输出: True 限制： 数组长度为 5 数组的数取值为 [0, 13] . 解题思路一用HashSet，遍历数组，把非零的数放到set中，用两个变量分别记录非零值的最大值和最小值，如果数组中有非零的重复值（set中有重复元素），就返回fasle，如果数组中非零值的最大值和最小值的差小于5，就返回true。 123456789101112131415161718192021222324class Solution &#123; public boolean isStraight(int[] nums) &#123; int len=nums.length; Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); //Arrays.sort(nums); //int cout=0;//统计零的个数 int max=0,min=14; for(int i=0; i&lt;len; i++) &#123; if(nums[i]==0) continue; if(set.size()&gt;0&amp;&amp;set.contains(nums[i])) return false; set.add(nums[i]); if(nums[i]&gt;max) max=nums[i]; if(nums[i]&lt;min) min=nums[i]; &#125; if(max-min&lt;5) return true; return false; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 60-n个骰子的点数]]></title>
    <url>%2F2020%2F08%2F04%2F%E5%89%91%E6%8C%87Offer-60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例 1: 12输入: 1输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例 2: 12输入: 2输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 限制： 11 &lt;= n &lt;= 11 解题思路2个骰子的各个点数的概率可以通过1个骰子和另一个骰子的概率得出，例如一个骰子上面的点数为1，2，3，4，5，6，他们分别的概率为1/6，1/6，1/6，1/6，1/6，1/6，两个骰子上面的点数可能为2，3，4，5，6，7，8，9，10，11，12，可以通过一个骰子上面的点数加上另一个骰子上面的点数得出，例如3，只可能为1，2，2,1他们分别的概率为1/36，1/36，两个骰子上面点数为3的概率为2/36.其他情况同理可得。n个骰子可以通过n-1个骰子和1个骰子得出 大佬的思路 123456789101112131415161718class Solution &#123; public double[] twoSum(int n) &#123; double [] res=&#123;1/6d,1/6d,1/6d,1/6d,1/6d,1/6d&#125;; for(int i=2; i&lt;=n; i++) &#123; double [] mid=new double[5*i+1]; for(int j=0; j&lt;res.length; j++) &#123; for(int a=0; a&lt;6; a++) &#123; mid[j+a]+=res[j]/6; &#125; &#125; res=mid; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 56-II 数组中数字出现的次数II]]></title>
    <url>%2F2020%2F08%2F02%2F%E5%89%91%E6%8C%87Offer-56-II-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0II%2F</url>
    <content type="text"><![CDATA[题目描述在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 示例 1： 12输入：nums = [3,4,3,3]输出：4 示例 2： 12输入：nums = [9,1,7,9,7,9,7]输出：1 限制： 1 &lt;= nums.length &lt;= 10000 1 &lt;= nums[i] &lt; 2^31 解题思路先把每一个数化成二进制位，如果一个数出现三次，统计它的二进制表示的每一位（0或1）出现的次数也是三次。如果把所有出现三次的数字的二进制表示的每一位分别加起来，那么每一位的和都能被3整除。我们需要一个长度位32的辅助数组存储二进制表示的每一位的和。 参考文章 12345678910111213141516171819202122class Solution &#123; public int singleNumber(int[] nums) &#123; int [] bit=new int[32]; int res=0; for(int num: nums) &#123; int k=1; for(int i=31; i&gt;=0; i--) &#123; if((k&amp;num)!=0) bit[i]++; k=k&lt;&lt;1; &#125; &#125; for(int i=0; i&lt;32; i++) &#123; res=res&lt;&lt;1; res+=bit[i]%3; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>剑指offer笔记</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 56-I 数组中数字出现的次数]]></title>
    <url>%2F2020%2F08%2F02%2F%E5%89%91%E6%8C%87Offer-56-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 12输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1] 示例 2： 12输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 限制： 2 &lt;= nums.length &lt;= 10000 解题思路所有数字进行异或操作后，就是两个不同数异或的结果，比如1和6异或的结果就是7，对应的二进制111，我们找一位为1的数，1，2，4，都可以，我找1，遍历数组，如果和1&amp;的结果为0的为一组，4，4，6为一组，1为一组，然后每一组里面的数进行异或操作，就是我们想要的结果。 详细的思路解答 12345678910111213141516171819class Solution &#123; public int[] singleNumbers(int[] nums) &#123; int res=0; for(int n:nums) res^=n; int k=1; while((k&amp;res)==0) k=k&lt;&lt;1; int a=0,b=0; for(int n:nums) &#123; if((n&amp;k)==0) a^=n; else b^=n; &#125; return new int[]&#123;a,b&#125;; &#125;&#125;]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>剑指offer笔记</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 54-二叉搜索树的第K大节点]]></title>
    <url>%2F2020%2F08%2F02%2F%E5%89%91%E6%8C%87Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一棵二叉搜索树，请找出其中第k大的节点。 示例 1: 1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 4 限制： 1 ≤ k ≤ 二叉搜索树元素个数 解题思路先进行二叉搜索树的中序逆序遍历，把对应数字放到一个List中，然后取第k个数就是对应所求 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; res; public int kthLargest(TreeNode root, int k) &#123; res=new ArrayList&lt;&gt;(); inorder(root); int cout=1,ans=-1; for(int temp:res) &#123; if(cout==k) &#123; ans=temp; break; &#125; cout++; &#125; return ans; &#125; public void inorder(TreeNode root) &#123; if(root==null) return; inorder(root.right); res.add(root.val); inorder(root.left); &#125;&#125;]]></content>
      <categories>
        <category>二叉搜索树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指offer笔记</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer53-II 0~n-1中缺失的数字]]></title>
    <url>%2F2020%2F08%2F02%2F%E5%89%91%E6%8C%87Offer53-II-0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 1: 12输入: [0,1,3]输出: 2 示例 2: 12输入: [0,1,2,3,4,5,6,7,9]输出: 8 限制： 11 &lt;= 数组长度 &lt;= 10000 解题思路参考大佬的思路 1234567891011121314class Solution &#123; public int missingNumber(int[] nums) &#123; int i=0,j=nums.length-1; while(i&lt;=j) &#123; int mid=(i+j)/2; if(nums[mid]==mid) i=mid+1; else j=mid-1; &#125; return i; &#125;&#125;]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer53-I 在排序数组中查找数字I]]></title>
    <url>%2F2020%2F08%2F02%2F%E5%89%91%E6%8C%87Offer53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I%2F</url>
    <content type="text"><![CDATA[题目描述统计一个数字在排序数组中出现的次数。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: 2 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: 0 限制： 10 &lt;= 数组长度 &lt;= 50000 解题思路常规方法很简单，要用二分查找，详细解答 123456789101112131415161718class Solution &#123; public int search(int[] nums, int target) &#123; return help(nums,target)-help(nums,target-1); &#125; public int help(int [] nums,int target) &#123; int i=0,j=nums.length-1; while(i&lt;=j) &#123; int mid=(i+j)/2; if(nums[mid]&lt;=target) i=mid+1; else j=mid-1; &#125; return i; &#125;&#125;]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer52-两个链表的第一个公共节点]]></title>
    <url>%2F2020%2F08%2F01%2F%E5%89%91%E6%8C%87Offer52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 注意： 如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路这道题用常规思路很容易，但是使用浪漫相遇，使用两个指针，p1指向第一个链表的头节点，p2指向第二个链表的头节点，同时往后遍历，如果p1遍历到第一个链表的末尾，则指向第二个链表的头节点，如果p2遍历到第二个链表的末尾，则指向第一个链表的头节点。最后总会相遇，如果没有公共的节点，会同时指向null,跳出循环。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null||headB==null) return null; ListNode p1=headA; ListNode p2=headB; while(p1!=p2) &#123; p1=p1==null? headA:p1.next; p2=p2==null? headB:p2.next; &#125; return p1; &#125;&#125;]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer47-礼物的最大价值]]></title>
    <url>%2F2020%2F08%2F01%2F%E5%89%91%E6%8C%87Offer47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例 1: 12345678输入: [ [1,3,1], [1,5,1], [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示： 0 &lt; grid.length &lt;= 200 0 &lt; grid[0].length &lt;= 200 解题思路这道题用递归可以做，但是超时了，代码如下： 12345678910111213141516171819202122class Solution &#123; public int m=0; public int maxValue(int[][] grid) &#123; int i=0,j=0; move(i,j,0,grid); return m; &#125; public void move(int i,int j,int value,int[][] grid) &#123; if(i&lt;0||i&gt;=grid.length||j&lt;0||j&gt;=grid[0].length) return; value+=grid[i][j]; if(i==grid.length-1&amp;&amp;j==grid[0].length-1&amp;&amp;value&gt;m) &#123; m=value; return; &#125; int temp=value; move(i+1,j,value,grid); move(i,j+1,temp,grid); &#125;&#125; 思路二用动态规划，dp[i][j]表示遍历到坐标i，j能够获得的最大价值，如果dp[i-1][j]大于dp[i][j-1],则dp[i][j]=dp[i-1][j]+grid[i][j],其他情况同理可得 大佬的详细思路 123456789101112131415161718class Solution &#123; public int maxValue(int[][] grid) &#123; int [][]dp=new int[grid.length][grid[0].length]; dp[0][0]=grid[0][0]; for(int i=1; i&lt;grid.length; i++) dp[i][0]=dp[i-1][0]+grid[i][0]; for(int i=1; i&lt;grid[0].length; i++) dp[0][i]=dp[0][i-1]+grid[0][i]; for(int i=1; i&lt;grid.length; i++) &#123; for(int j=1; j&lt;grid[0].length;j++) &#123; dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1])+grid[i][j]; &#125; &#125; return dp[grid.length-1][grid[0].length-1]; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer46-把数字翻译成字符串]]></title>
    <url>%2F2020%2F08%2F01%2F%E5%89%91%E6%8C%87Offer46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1: 123输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 提示： 0 &lt;= num &lt; 2^31 解题思路字符串x1x2x3x4x5,如果计算第xi的翻译方案数，则要看x(i-2)x(i-1)是否可以组成可以翻译成字母的字符串，如果可以，则和x(i-1)加x(i-2)组成的方案是相同的，不可以的话，和x(i-1)组成的方案是相同的。 详细的解释请看这里 12345678910111213141516171819class Solution &#123; public int translateNum(int num) &#123; String str=String.valueOf(num); int len=str.length(); int [] dp=new int[len+1]; dp[0]=1; dp[1]=1; for(int i=2; i&lt;=len; i++) &#123; String tmp=str.substring(i-2,i); int s=Integer.valueOf(tmp); if(s&gt;=10&amp;&amp;s&lt;=25) dp[i]=dp[i-1]+dp[i-2]; else dp[i]=dp[i-1]; &#125; return dp[len]; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer44-数字序列中某一位的数字]]></title>
    <url>%2F2020%2F08%2F01%2F%E5%89%91%E6%8C%87Offer44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例 1： 12输入：n = 3输出：3 示例 2： 12输入：n = 11输出：0 限制： 0 &lt;= n &lt; 2^31 解题思路digit是这种类型的数字有多少位，例如10~99，有2位，start是指这种数字开始时的数字，例如10~99，start=10，cout是指这个范围的数字总共有多少位，例如10~99,一共有90*2=180位。 第一步，先确定在哪个范围的第几个数字，例如n=15，一位数一共有9个，那么15是从10开始的第6个数。（n=n-9=6) 第二步，再确定n是哪个数字，例如n=5对应的数字为5，计算公式为：start+(n-1)/digit,例如n=15,通过第一步后n=6,通过计算公式得出的结果为:10+2=12，确定的数字为12 第三步，再确定是数字12的哪一位，计算公式为:(n-1)%digit 这里面详细的图表解释 123456789101112131415161718class Solution &#123; public int findNthDigit(int n) &#123; int digit=1; long start=1,cout=9; while(n&gt;cout) &#123; n-=cout;//n=n-cout会有类型转换的错误 digit++; start=start*10; cout=9*start*digit; &#125; //确定是那个数字 long num=start+(n-1)/digit; //System.out.println(num); return Long.toString(num).charAt((n-1)%digit)-'0'; //return (int)num; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer35-复杂链表的复制]]></title>
    <url>%2F2020%2F07%2F27%2F%E5%89%91%E6%8C%87Offer35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目描述请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例 1： 12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*// Definition for a Node.class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125;&#125;*/class Solution &#123; public Node copyRandomList(Node head) &#123; Node p=head;//操作指针 if(p==null) return null; while(p!=null)//复制每个节点放在每个节点的后面 &#123; Node newp=new Node(p.val); newp.next=p.next; p.next=newp; p=newp.next; &#125; //复制随机指针 p=head; while(p!=null) &#123; if(p.random!=null) &#123; p.next.random=p.random.next; &#125; p=p.next.next; &#125; //拆分链表 p=head; Node newp=p.next;//新链表的操作指针 Node newhead=newp;//新的头节点 while(newp.next!=null) &#123; p.next=newp.next; p=newp.next; newp.next=p.next; newp=p.next; &#125; p.next=null; return newhead; &#125;&#125;]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 27-二叉树的镜像]]></title>
    <url>%2F2020%2F07%2F25%2F%E5%89%91%E6%8C%87Offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[题目描述请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 12345 4 / \ 2 7 / \ / \1 3 6 9 镜像输出： 12345 4 / \ 7 2 / \ / \9 6 3 1 示例 1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 限制： 10 &lt;= 节点个数 &lt;= 1000 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if(root==null) return root; TreeNode temp=root.left; root.left=root.right; root.right=temp; mirrorTree(root.left); mirrorTree(root.right); return root; &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer26-树的子结构]]></title>
    <url>%2F2020%2F07%2F24%2F%E5%89%91%E6%8C%87Offer26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A: 3 / \ 4 5 / \ 1 2给定的树 B： 123 4 /1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 12输入：A = [1,2,3], B = [3,1]输出：false 示例 2： 12输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制： 10 &lt;= 节点个数 &lt;= 10000 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSubStructure(TreeNode A, TreeNode B) &#123; if(B==null||A==null) return false; return judge(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B); &#125; public boolean judge(TreeNode A,TreeNode B) &#123; if(B==null) return true; if(A==null) return false; if(A.val!=B.val) return false; return judge(A.left,B.left)&amp;&amp;judge(A.right,B.right); &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer16-数值的整数次方]]></title>
    <url>%2F2020%2F07%2F23%2F%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[题目描述实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。 解题思路这道题本来很简单，但是涉及到-2的31次方，2的31次方-1，整数边界问题，导致时间复杂度超时 12345678910111213141516171819202122232425262728class Solution &#123; public double myPow(double x, int n) &#123; if(x==0) return 0; if(n==0||x==1) return 1; boolean flag=false; //2.00000 -2147483648 long b=n; if(n&lt;0) &#123; flag=true; b=-b; &#125; double res=1; do&#123; if((b&amp;1)==1)//double类型和int进行逻辑运算会出错 res=res*x; x=x*x; b=(b&gt;&gt;1); &#125;while(b&gt;0); if(flag) &#123; res=1/res; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 15-二进制中1的个数]]></title>
    <url>%2F2020%2F07%2F23%2F%E5%89%91%E6%8C%87Offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。 示例 2： 123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。 示例 3： 123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。 解题思路本来这道题很简单的，先把数转换成二进制数，转换过程中统计1的个数，就可以做出来的，用逻辑运算可以更简单，时间复杂更低 方法1 123456789101112public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; //String str=""; int cout=0; do&#123; cout+=(n&amp;1);//末尾是否为1,是1则加1 n=n&gt;&gt;&gt;1;//java中无符号右移 &#125;while(n!=0); return cout; &#125;&#125; 时间复杂度为logn 方法2 1234567891011121314public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; //String str=""; if(n==0) return 0; int cout=0; do&#123; cout++; n=n&amp;n-1;//二进制数字n最右边的1变成0，其余不变。 &#125;while(n!=0); return cout; &#125;&#125; 时间复杂度为O(m),m为n转化为二进制中1的个数]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>剑指offer笔记</tag>
        <tag>逻辑运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 14-剪绳子II]]></title>
    <url>%2F2020%2F07%2F23%2F%E5%89%91%E6%8C%87Offer-14-%E5%89%AA%E7%BB%B3%E5%AD%90II%2F</url>
    <content type="text"><![CDATA[给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 1000 解题思路这道题用dp涉及到大整数溢出，只能用贪心。 12345678910111213141516class Solution &#123; public int cuttingRope(int n) &#123; if(n==2) return 1; else if(n==3) return 2; long res=1; while(n&gt;4) &#123; res*=3; n-=3; res=res%1000000007; &#125; return (int)((res*n)%1000000007); &#125;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer11-旋转数组的最小数字]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%89%91%E6%8C%87Offer11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 12输入：[3,4,5,1,2]输出：1 示例 2： 12输入：[2,2,2,0,1]输出：0 解题思路一开始用的利用旋转数组的特点，如果数组中后面的数小于前面的数，这个数就是最小值，利用这个思路去做，最后也AC了，但是有事件复杂度更低的算法，那就是二分查找，大佬的文章 12345678910111213141516class Solution &#123; public int minArray(int[] numbers) &#123; int i=0,j=numbers.length-1; while(j&gt;i) &#123; int m=(i+j)/2; if(numbers[m]&gt;numbers[j])//最小值一定在m+1到j之间 i=m+1; else if(numbers[m]&lt;numbers[j])//最小值一定在i到m之间 j=m; else j--; &#125; return numbers[i]; &#125;&#125;]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer09-用两个栈实现队列]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%89%91%E6%8C%87Offer09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 示例 2： 1234输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 解题思路进栈的时候，把数放在第一个栈里面，出栈的时候，把第一个栈的数一次出栈，然后放到第二个栈中 12345678910111213141516171819202122232425262728293031class CQueue &#123; Stack&lt;Integer&gt; stack1=new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2=new Stack&lt;&gt;(); public CQueue() &#123; &#125; public void appendTail(int value) &#123; stack1.push(value); &#125; public int deleteHead() &#123; if(stack2.size()==0) &#123; while(stack1.size()!=0) &#123; stack2.push(stack1.pop()); &#125; &#125; if(stack2.size()==0) return -1; return stack2.pop(); &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */]]></content>
      <categories>
        <category>设计题</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>剑指offer笔记</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer07-重建二叉树]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%89%91%E6%8C%87Offer07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 限制： 10 &lt;= 节点个数 &lt;= 5000 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder.length==0||inorder.length==0) return null; TreeNode root=new TreeNode(preorder[0]); for(int i=0; i&lt;inorder.length; i++) &#123; if(preorder[0]==inorder[i]) &#123; root.left=buildTree(Arrays.copyOfRange(preorder,1,i+1),Arrays.copyOfRange(inorder,0,i)); root.right=buildTree(Arrays.copyOfRange(preorder,i+1,preorder.length),Arrays.copyOfRange(inorder,i+1,inorder.length)); &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer04-二维数组的查找]]></title>
    <url>%2F2020%2F07%2F10%2F%E5%89%91%E6%8C%87Offer04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 120 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000 123456789101112131415161718class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; //这道题你主要是思维固化，你可以从左下角开始查找，当前的值比目标值小，往上查找，当前的值比目标值大，往右查找 if(matrix==null||matrix.length==0) return false; int i=matrix.length-1,j=0; while(j&lt;matrix[0].length&amp;&amp;i&gt;=0) &#123; if(matrix[i][j]&gt;target) i--; else if(matrix[i][j]&lt;target) j++; else return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于驼峰命名的问题]]></title>
    <url>%2F2020%2F06%2F04%2F%E5%85%B3%E4%BA%8E%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[12&lt;!-- 开启驼峰命名转换：Table&#123;create_time&#125;-&gt;&#123;createTime&#125;--&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; 开启驼峰命名，如果你的实体类中属性名和数据库的属性名一样也会出错，害的我一顿好找，找了好久，能够根据查询到对应的对象，就是查不到对象对应的属性，最后把驼峰命名关闭就好了 总结以后就不要开启驼峰命名了，实体类的属性就写得和数据库中的属性一样就可以了，别瞎折腾，搞什么驼峰命名了，没什么用，和数据库中的的属性一样不就好了]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1467-两个盒子中球的颜色数相同的概率]]></title>
    <url>%2F2020%2F06%2F02%2FLeetCode1467-%E4%B8%A4%E4%B8%AA%E7%9B%92%E5%AD%90%E4%B8%AD%E7%90%83%E7%9A%84%E9%A2%9C%E8%89%B2%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[题目描述桌面上有 2n 个颜色不完全相同的球，球上的颜色共有 k 种。给你一个大小为 k 的整数数组 balls ，其中 balls[i] 是颜色为 i 的球的数量。 所有的球都已经 随机打乱顺序 ，前 n 个球放入第一个盒子，后 n 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。 注意：这两个盒子是不同的。例如，两个球颜色分别为 a 和 b，盒子分别为 [] 和 ()，那么 [a] (b) 和 [b] (a) 这两种分配方式是不同的（请认真阅读示例 1 的解释部分）。 请计算「两个盒子中球的颜色数相同」的情况的概率。 示例 1： 123456输入：balls = [1,1]输出：1.00000解释：球平均分配的方式只有两种：- 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子- 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。 示例 2： 12345678输入：balls = [2,1,1]输出：0.66667解释：球的列表为 [1, 1, 2, 3]随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ：[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。概率 = 8/12 = 0.66667 示例 3： 1234输入：balls = [1,2,1,2]输出：0.60000解释：球的列表为 [1, 2, 2, 3, 4, 4]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。概率 = 108 / 180 = 0.6 。 示例 4： 1234输入：balls = [3,2,1]输出：0.30000解释：球的列表为 [1, 1, 1, 2, 2, 3]。要想显示所有 60 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 18 种情况是比较容易的。概率 = 18 / 60 = 0.3 。 示例 5： 12输入：balls = [6,6,6,6,6,6]输出：0.90327 提示： 1 &lt;= balls.length &lt;= 8 1 &lt;= balls[i] &lt;= 6 sum(balls) 是偶数 答案与真实值误差在 10^-5 以内，则被视为正确答案 解题思路这道题对现在的我确实有点难度，自己要多练dp了 大佬视频讲解链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Solution &#123; public double[][][][] dp=new double [10][30][10][10]; //盒子A，盒子B //盒子A中球的颜色数=盒子B中球的颜色数 //dp[c][i][p][q] 已经分配了前c中颜色的球，盒子A中有i个球，盒子B中有sum-i个球(sum=balls[0]+...+balls[c-1]),盒子A中有p中颜色，盒子B中有q种颜色 //取颜色c+1，balls[c] //L个放进盒子A，balls[c]-L个放进盒子B private double C(int n,int m) &#123; if(m&gt;n) return 0; if(m==n) return 1; double s=1; for(int i=n; i&gt;m; i--) s=s*i; for(int i=1; i&lt;=n-m; i++) s=s/i; return s; &#125; public double getProbability(int[] balls) &#123; int m=balls.length,n=0; for(int k:balls) n=n+k; n=n/2; for(int i=0; i&lt;=m; i++) &#123; for(int j=0; j&lt;=n; j++) &#123; for(int p=0; p&lt;=m; p++) &#123; for(int q=0; q&lt;=m; q++) &#123; dp[i][j][p][q]=0; &#125; &#125; &#125; &#125; dp[0][0][0][0]=1.0; int sum=0; for(int c=1; c&lt;=m; c++) &#123; int cnt=balls[c-1]; for(int i=0; i&lt;=n; i++) &#123; for(int p=0; p&lt;=m; p++) &#123; for(int q=0; q&lt;=m; q++) &#123; double tot=0; for(int L=0; L&lt;=cnt; L++) &#123; if(i+L&lt;=n&amp;&amp;sum-i+cnt-L&lt;=n) tot+=C(n-i,L)*C(n-(sum-i),cnt-L); &#125; for(int L=0; L&lt;=cnt; L++) &#123; if(i+L&lt;=n&amp;&amp;sum-i+cnt-L&lt;=n) &#123; int np=p+(L&gt;0?1:0);//三目运算符记得加括号 int nq=q+((cnt-L)&gt;0?1:0); double a=C(n-i,L); double b=C(n-(sum-i),cnt-L); double v=C(n-i,L)*C(n-(sum-i),cnt-L)/tot; dp[c][i+L][np][nq]+=dp[c-1][i][p][q]*v; //System.out.println(a+" "+b+" "+tot+" "+v); &#125; &#125; &#125; &#125; &#125; sum+=cnt; &#125; double ans=0; for(int p=0; p&lt;=m; p++) &#123; ans+=dp[m][n][p][p]; // System.out.println(ans); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5426-重新规划路线]]></title>
    <url>%2F2020%2F06%2F01%2FLeetCode5426-%E9%87%8D%E6%96%B0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[题目描述n 座城市，从 0 到 n-1 编号，其间共有 n-1 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。 路线用 connections 表示，其中 connections[i] = [a, b] 表示从城市 a 到 b 的一条有向路线。 今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。 请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。 题目数据 保证 每个城市在重新规划路线方向后都能到达城市 0 。 示例 1： 123输入：n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]输出：3解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。 示例 2： 123输入：n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]输出：2解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。 示例 3： 12输入：n = 3, connections = [[1,0],[2,0]]输出：0 提示： 2 &lt;= n &lt;= 5 * 10^4 connections.length == n-1 connections[i].length == 2 0 &lt;= connections[i][0], connections[i][1] &lt;= n-1 connections[i][0] != connections[i][1] 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int minReorder(int n, int[][] connections) &#123; List&lt;HashSet&lt;Integer&gt;&gt; in=new ArrayList&lt;&gt;(); for(int i=0; i&lt;n; i++) in.add(new HashSet());//每个节点创建一个set存储它的入度节点 List&lt;HashSet&lt;Integer&gt;&gt; out=new ArrayList&lt;&gt;(); for(int i=0; i&lt;n; i++) out.add(new HashSet()); //我老是搞不清入度和出度，比如0-&gt;1,0的出度为1，1的入度0 for(int [] a:connections) &#123; out.get(a[0]).add(a[1]); in.get(a[1]).add(a[0]); &#125; Queue&lt;Integer&gt; queue=new LinkedList&lt;&gt;(); queue.offer(0); int ans=0; while(!queue.isEmpty()) &#123; int cur=queue.poll(); while(in.get(cur)!=null&amp;&amp;in.get(cur).size()&gt;0) &#123; for(int k:in.get(cur)) &#123; queue.offer(k); //把对应出度移除 out.get(k).remove(cur); &#125; in.get(cur).clear(); &#125; while(out.get(cur)!=null&amp;&amp;out.get(cur).size()&gt;0) &#123; for(int k:out.get(cur)) &#123; ans++; queue.offer(k); in.get(k).remove(cur); &#125; out.get(cur).clear(); &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>图</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5425-切割后面积最大的蛋糕]]></title>
    <url>%2F2020%2F05%2F31%2FLeetCode5425-%E5%88%87%E5%89%B2%E5%90%8E%E9%9D%A2%E7%A7%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E8%9B%8B%E7%B3%95%2F</url>
    <content type="text"><![CDATA[题目描述矩形蛋糕的高度为 h 且宽度为 w，给你两个整数数组 horizontalCuts 和 verticalCuts，其中 horizontalCuts[i] 是从矩形蛋糕顶部到第 i 个水平切口的距离，类似地， verticalCuts[j] 是从矩形蛋糕的左侧到第 j 个竖直切口的距离。 请你按数组 horizontalCuts 和 verticalCuts 中提供的水平和竖直位置切割后，请你找出 面积最大 的那份蛋糕，并返回其 面积 。由于答案可能是一个很大的数字，因此需要将结果对 10^9 + 7 取余后返回。 示例 1： 123输入：h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]输出：4 解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。 代码123456789101112131415161718class Solution &#123; public int maxArea(int h, int w, int[] hs, int[] vs) &#123; Arrays.sort(hs); Arrays.sort(vs); int len1=hs.length; int len2=vs.length; long x=0,y=0; x=hs[0]-0; y=vs[0]-0; for(int i=1; i&lt;len1; i++) x=Math.max(x,hs[i]-hs[i-1]); x=Math.max(x,h-hs[len1-1]); for(int j=1; j&lt;len2; j++) y=Math.max(y,vs[j]-vs[j-1]); y=Math.max(y,w-vs[len2-1]); return (int)((x*y)%1000000007);//用int相乘最后会溢出 &#125;&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode32-最长有效括号]]></title>
    <url>%2F2020%2F05%2F30%2FLeetCode32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目描述给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 解题思路首先使用想用栈，自己都不知道下手，看了别人的思路才写出来的，但是超时了 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int longestValidParentheses(String s) &#123; if(s.length()&lt;2) return 0; int maxlen=0; for(int i=0; i&lt;s.length(); i++) &#123; for(int j=i+2; j&lt;=s.length(); j+=2) &#123; if(judge(s.substring(i,j))) &#123; maxlen=Math.max(maxlen,j-i); &#125; &#125; &#125; return maxlen; &#125; private boolean judge(String s) &#123; Stack&lt;Character&gt; stack=new Stack&lt;&gt;(); for(int i=0; i&lt;s.length(); i++) &#123; if(s.charAt(i)=='(') stack.push('('); else if(!stack.isEmpty()&amp;&amp;s.charAt(i)==')') stack.pop(); else return false; &#125; return stack.isEmpty(); &#125;&#125; 利用栈的另一种方法，时间复杂度为O(n),空间复杂度为O(n) 详细图解 123456789101112131415161718192021222324class Solution &#123; public int longestValidParentheses(String s) &#123; if(s.length()&lt;2) return 0; Stack &lt;Integer&gt; stack=new Stack&lt;&gt;(); stack.push(-1); int maxlen=0; for(int i=0; i&lt;s.length(); i++) &#123; if(s.charAt(i)=='(')//左括号把对应下标进栈 stack.push(i); else &#123; stack.pop();//遇到右括号，出栈 if(stack.isEmpty())//出栈后如果栈为空，把出栈下标进栈 &#123; stack.push(i); &#125; maxlen=Math.max(maxlen,i-stack.peek()); &#125; &#125; return maxlen; &#125;&#125;]]></content>
      <categories>
        <category>括号</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>括号</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode30-串联所有单词的子串]]></title>
    <url>%2F2020%2F05%2F30%2FLeetCode30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1： 1234567输入： s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。输出的顺序不重要, [9,0] 也是有效答案。 示例 2： 1234输入： s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[] 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List &lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(s.length()==0||words.length==0) return res; int onelen=words[0].length();//每一个单词的长度 int wordslen=onelen*words.length;//总的单词长度 if(wordslen&gt;s.length())//如果单词的长度大于字符串的长度 return res; Map&lt;String,Integer&gt;wordsMap=new HashMap&lt;&gt;(); for(String word:words) &#123; if(s.indexOf(word)&lt;0)//如果字符串中没有这个单词 return res; wordsMap.put(word,wordsMap.getOrDefault(word,0)+1); &#125; for(int i=0; i&lt;onelen; i++)//滑动窗口查找 &#123; int left=i,right=i,cout=0; Map&lt;String,Integer&gt;subMap=new HashMap&lt;&gt;();//字符串中符合要求的单词 while(right+onelen&lt;=s.length()) &#123; String wo=s.substring(right,right+onelen); right=right+onelen; if(!wordsMap.containsKey(wo))//wordsMap中没有这个单词 &#123; left=right;//左滑动窗口跳到右滑动窗口 subMap.clear();//清掉里面的单词统计 cout=0;//符合要求的单词个数为0 &#125; else &#123; //统计字符串符合要求的单词个数 subMap.put(wo,subMap.getOrDefault(wo,0)+1); cout++;//当前匹配的单词个数//s:"foobarfoobarfoothe",words:"foo","bar","foo","the"//subMap中bar的个数超过wordsMap中bar的个数，自己在纸上模拟一下就懂了 while(subMap.getOrDefault(wo,0)&gt;wordsMap.getOrDefault(wo,0)) &#123; String temp=s.substring(left,left+onelen);//左指针的单词 left=left+onelen;//左指针向右移 subMap.put(temp,subMap.getOrDefault(temp,0)-1);//subMap中对应的单词个数减一 cout--;//匹配单词的个数减一 &#125; if(cout==words.length)//匹配个数等于单词的个数 &#123; res.add(left);//添加左指针 // System.out.println(cout+" "+wo); &#125; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>字符产</tag>
        <tag>子串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode25-K个一组翻转链表]]></title>
    <url>%2F2020%2F05%2F29%2FLeetCode25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例： 给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明： 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 解题思路这题的思路是很简单的，但是指针的操作比较复杂，主要涉及到多个指针的操作，画图有助于这道题的理解。 这里详细的图解 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode first=new ListNode(0); first.next=head; ListNode pre=first; ListNode end=first; while(end!=null) &#123; for(int i=0; i&lt;k&amp;&amp;end!=null; i++) end=end.next; if(end==null)//如果小于k个就循环结束 break; ListNode start=pre.next;//每k个节点的开始节点 ListNode Next=end.next;//k个节点的最后节点的下一个节点 end.next=null; pre.next=reverse(start); start.next=Next; end=start; pre=start; &#125; return first.next; &#125; private ListNode reverse(ListNode node)//把这k个节点进行翻转 &#123; ListNode curr=node; ListNode pre=null; while(curr!=null) &#123; ListNode Next=curr.next; curr.next=pre; pre=curr; curr=Next; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>翻转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode23-合并K个排序链表]]></title>
    <url>%2F2020%2F05%2F27%2FLeetCode23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述合并 *k *个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 解题思路利用优先队列，依次把k个链表的头节点入队，按节点的值建立小顶堆，每次从优先队列中获取最小值节点。 时间复杂度，每次从优先队列中获取最小值的时间复杂度为Log(K),总的时间复杂度为nlog(K) 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode newhead=new ListNode(0); ListNode p=newhead; if(lists==null||lists.length==0) return null; PriorityQueue&lt;ListNode&gt; pq=new PriorityQueue&lt;&gt;((v1,v2)-&gt;(v1.val-v2.val)); for(ListNode temp:lists) &#123; if(temp!=null)//特判lists是否为空 pq.offer(temp); &#125; while(!pq.isEmpty()) &#123; ListNode head=pq.poll(); p.next=head; p=head; if(head.next!=null) &#123; pq.offer(head.next); &#125; &#125; return newhead.next; &#125;&#125;]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode4-寻找两个正序数组的中位数]]></title>
    <url>%2F2020%2F05%2F26%2FLeetCode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2: 1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 解题思路详见视频 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if(nums2.length&lt;nums1.length)//nums1永远是长度较小的数组 &#123; int [] temp=nums1; nums1=nums2; nums2=temp; &#125; int len1=nums1.length; int len2=nums2.length; int n=(len1+len2+1)/2;//分割线左边元素的个数 int left=0; int right=len1; while(left&lt;right) &#123; int i=left+(right-left+1)/2; int j=n-i; if(nums1[i-1]&gt;nums2[j])//如果分割线左上角的数大于右下角 &#123;//向[left,i-1]搜索 right=i-1; &#125; else &#123;//向[i,right]搜索 left=i; &#125; &#125; int i=left; int j=n-i; int nums1LeftMax= i==0?Integer.MIN_VALUE:nums1[i-1]; int nums1RightMin= i==len1?Integer.MAX_VALUE:nums1[i]; int nums2LeftMax= j==0?Integer.MIN_VALUE:nums2[j-1]; int nums2RightMin= j==len2?Integer.MAX_VALUE:nums2[j]; double res=0; if((len1+len2)%2==1)//如果总的数组中元素的数量为奇数个 &#123; res=(double)Math.max(nums1LeftMax,nums2LeftMax); &#125; else//偶数个 &#123; res=(Math.max(nums1LeftMax,nums2LeftMax)+Math.min(nums1RightMin,nums2RightMin))/2.0; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5419-两个子序列的最大点积]]></title>
    <url>%2F2020%2F05%2F25%2FLeetCode5419-%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目描述参考的链接 1234567891011121314151617181920212223242526class Solution &#123; public int maxDotProduct(int[] nums1, int[] nums2) &#123; int[][] dp=new int[510][510]; int len1=nums1.length; int len2=nums2.length; for(int i=0; i&lt;=len1; i++) &#123; for(int j=0; j&lt;=len2; j++) &#123; dp[i][j]=-1001; &#125; &#125; for(int i=1; i&lt;=len1; i++) &#123; for(int j=1; j&lt;=len2; j++) &#123; dp[i][j]=nums1[i-1]*nums2[j-1]; dp[i][j]=Math.max(dp[i][j],dp[i][j]+dp[i-1][j-1]); dp[i][j]=Math.max(dp[i][j],dp[i-1][j]); dp[i][j]=Math.max(dp[i][j],dp[i][j-1]); dp[i][j]=Math.max(dp[i][j],dp[i-1][j-1]); &#125; &#125; return dp[len1][len2]; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5418-二叉树中的伪回文路径]]></title>
    <url>%2F2020%2F05%2F24%2FLeetCode5418-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%9B%9E%E6%96%87%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。 请你返回从根到叶子节点的所有路径中 *伪回文 *路径的数目。 示例 1： 1234输入：root = [2,3,1,3,1,null,1]输出：2 解释：上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。 在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。 示例 2： 1234输入：root = [2,1,1,1,3,null,null,null,null,null,1]输出：1 解释：上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。 这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。 示例 3： 12输入：root = [9]输出：1 提示： 给定二叉树的节点数目在 1 到 10^5 之间。 节点值在 1 到 9 之间。 解题思路别人思路 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int res=0; public int pseudoPalindromicPaths (TreeNode root) &#123; if(root==null) return res; DFS(root,0); return res; &#125; private void DFS(TreeNode root,int temp) &#123; temp=temp^(1&lt;&lt;root.val);//节点的值为n，就左移n位 if(root.left==null&amp;&amp;root.right==null) &#123; if(temp==0||(temp&amp;(temp-1))==0) res++; &#125; if(root.left!=null) DFS(root.left,temp); if(root.right!=null) DFS(root.right,temp); &#125;&#125;]]></content>
      <categories>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>回文序列</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode274-H指数]]></title>
    <url>%2F2020%2F05%2F23%2FLeetCode274-H%E6%8C%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数 不超过 h 次。） 例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。 示例： 1234输入：citations = [3,0,6,1,5]输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。 提示：如果 h 有多种可能的值，h 指数是其中最大的那个。 问题我想让数组从大到小排序，但是写了好久没写出来，我把写的代码贴在这里，我以后想起来了，再来看看 123456Arrays.sort(citations,new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a,Integer b) &#123; return b-a; &#125; &#125;); 通过的代码： 123456789101112131415class Solution &#123; public int hIndex(int[] citations) &#123; int len=citations.length; Arrays.sort(citations); int h=1; for(int i=len-1; i&gt;=0; i--) &#123; if(citations[i]&lt;h) break; else h++; &#125; return h-1; &#125;&#125;]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode220-存在重复元素III]]></title>
    <url>%2F2020%2F05%2F23%2FLeetCode220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III%2F</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。 示例 1: 12输入: nums = [1,2,3,1], k = 3, t = 0输出: true 示例 2: 12输入: nums = [1,0,1,1], k = 1, t = 2输出: true 示例 3: 12输入: nums = [1,5,9,1,5,9], k = 2, t = 3输出: false 解题思路首先想到是用暴力，比较数组中不同元素，是否满足两个元素值的差和两个元素的下标差是否满足条件，最后就超时了 超时代码如下： 12345678910111213141516class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; int len=nums.length; for(int i=0; i&lt;len; i++) &#123; for(int j=i; j&lt;len; j++) &#123; if(i==j) continue; if(Math.abs((long)nums[i]-nums[j])&lt;=t&amp;&amp;Math.abs(i-j)&lt;=k)//这里容易溢出，所以强转 return true; &#125; &#125; return false; &#125;&#125; 题解 12345678910111213141516171819202122232425262728class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; TreeSet&lt;Long&gt; set=new TreeSet&lt;&gt;(); int len=nums.length; for(int i=0; i&lt;len; i++) &#123; Long h=set.ceiling((long)(nums[i])); if(h!=null&amp;&amp;h&lt;=(long)t+nums[i]) return true; Long l=set.floor((long)(nums[i])); /*if(l!=null) &#123; 这样写会算出错误的结果(long)(nums[i]-t); long res=(long)(nums[i]-t); System.out.println("nums[i]-t："+res); System.out.println("l："+l); &#125;*/ if(l!=null&amp;&amp;(long)nums[i]-t&lt;=l)//用Integer会溢出 return true; set.add((long)(nums[i])); if(set.size()&gt;k) &#123; set.remove((long)nums[i-k]); &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>时间复杂度</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode179-最大数]]></title>
    <url>%2F2020%2F05%2F23%2FLeetCode179-%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 12输入: [10,2]输出: 210 示例 2: 12输入: [3,30,34,5,9]输出: 9534330 *说明: *输出结果可能非常大，所以你需要返回一个字符串而不是整数。 解题思路这里的难点就是怎么排序，按字典序排序，字典序大的放在前面详细解释 123456789101112131415161718192021222324class Solution &#123; public String largestNumber(int[] nums) &#123; int len=nums.length; String [] str=new String[len]; for(int i=0; i&lt;len; i++) &#123; str[i]=nums[i]+""; &#125; Arrays.sort(str,new Comparator&lt;String&gt;()&#123; public int compare(String s1,String s2) &#123; String temp1=s1+s2; String temp2=s2+s1; return temp2.compareTo(temp1); &#125; &#125;); String res=""; if(str[0].equals("0")) return "0"; for(int i=0; i&lt;len; i++) res+=str[i]; return res; &#125;&#125;]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode57-插入区间]]></title>
    <url>%2F2020%2F05%2F21%2FLeetCode57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目描述给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1: 12输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]] 示例 2: 123输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 解题思路第一步：如果当前区间的末尾值小于新插入区间的开始值，则把对应区间直接加入到结果中。 第二步:如果当前区间的开始值小于新插入区间的末尾值,则更新对应的新插入区间（这时候两个区间是有交集的） 第三步：把剩下的区间加入到结果中 参考了这篇文章 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int[][] insert(int[][] intervals, int[] newInterval) &#123; int len=intervals.length; if(len==0||intervals==null) &#123; int [][] specail=new int[1][2]; specail[0]=newInterval; return specail; &#125; if(newInterval==null) return intervals; int [][]res=new int[len+1][2]; int i=0; int index=0; //如果当前区间的末尾值小于新插入区间的开始值 while(i&lt;len&amp;&amp;intervals[i][1]&lt;newInterval[0]) &#123; res[index++]=intervals[i]; i++; &#125; //如果当前区间的开始值小于新插入区间的末尾值 while(i&lt;len&amp;&amp;intervals[i][0]&lt;=newInterval[1]) &#123; newInterval[0]=Math.min(intervals[i][0],newInterval[0]); newInterval[1]=Math.max(intervals[i][1],newInterval[1]); i++; &#125; res[index++]=newInterval; while(i&lt;len)//最后剩下的 &#123; res[index++]=intervals[i]; i++; &#125; return Arrays.copyOf(res,index); &#125;&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode56-合并区间]]></title>
    <url>%2F2020%2F05%2F21%2FLeetCode56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目描述给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题思路这里主要是把两个区间分成三种情况，画图详见,然后根据情况进行合并就可以了。 1234567891011121314151617class Solution &#123; public int[][] merge(int[][] intervals) &#123; Arrays.sort(intervals,(a1,a2)-&gt;(a1[0]-a2[0])); int len=intervals.length; int [][] res=new int[len][2]; int index=-1; for(int [] a:intervals) &#123; //如果当前区间的起始位置大于前一个区间的终点位置 if(index==-1||a[0]&gt;res[index][1]) res[++index]=a; else res[index][1]=Math.max(a[1],res[index][1]); &#125; return Arrays.copyOf(res,index+1); &#125;&#125;]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1452-收藏清单]]></title>
    <url>%2F2020%2F05%2F20%2FLeetCode1452-%E6%94%B6%E8%97%8F%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[题目描述给你一个数组 favoriteCompanies ，其中 favoriteCompanies[i] 是第 i 名用户收藏的公司清单（下标从 0 开始）。 请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标。下标需要按升序排列。 示例 1： 123456输入：favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;,&quot;microsoft&quot;],[&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;],[&quot;amazon&quot;]]输出：[0,1,4] 解释：favoriteCompanies[2]=[&quot;google&quot;,&quot;facebook&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集。favoriteCompanies[3]=[&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 和 favoriteCompanies[1]=[&quot;google&quot;,&quot;microsoft&quot;] 的子集。其余的收藏清单均不是其他任何人收藏的公司清单的子集，因此，答案为 [0,1,4] 。 示例 2： 123输入：favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;leetcode&quot;,&quot;amazon&quot;],[&quot;facebook&quot;,&quot;google&quot;]]输出：[0,1] 解释：favoriteCompanies[2]=[&quot;facebook&quot;,&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集，因此，答案为 [0,1] 。 示例 3： 12输入：favoriteCompanies = [[&quot;leetcode&quot;],[&quot;google&quot;],[&quot;facebook&quot;],[&quot;amazon&quot;]]输出：[0,1,2,3] 提示： 1 &lt;= favoriteCompanies.length &lt;= 100 1 &lt;= favoriteCompanies[i].length &lt;= 500 1 &lt;= favoriteCompanies[i][j].length &lt;= 20 favoriteCompanies[i] 中的所有字符串 各不相同 。 用户收藏的公司清单也 各不相同 ，也就是说，即便我们按字母顺序排序每个清单， favoriteCompanies[i] != favoriteCompanies[j] 仍然成立。 所有字符串仅包含小写英文字母。 解题思路一个字符串是零一个字符串的子串，我比赛的时候为啥就没有想到用HashSet啊，一直想着如何判断一个字符串是否是另一个字符串的字符，但是一直到比赛结束也没有写出来 12345678910111213141516171819202122232425class Solution &#123; public List&lt;Integer&gt; peopleIndexes(List&lt;List&lt;String&gt;&gt; favoriteCompanies) &#123; List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); for(int i=0; i&lt;favoriteCompanies.size(); i++) &#123; List&lt;String&gt; l1=favoriteCompanies.get(i); boolean flag=true; for(int j=0; j&lt;favoriteCompanies.size(); j++) &#123; if(i==j) continue; List&lt;String&gt; l2=favoriteCompanies.get(j); Set&lt;String&gt; set1=new HashSet&lt;&gt;(l2); if(set1.containsAll(l1)) &#123; flag=false; break; &#125; &#125; if(flag==true) res.add(i); &#125; return res; &#125;&#125; 注意使用的是HashSet中的containsAll方法]]></content>
      <categories>
        <category>Set</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1451-重新排列句子中的单词]]></title>
    <url>%2F2020%2F05%2F20%2FLeetCode1451-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目描述「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子 text : 句子的首字母大写 text 中的每个单词都用单个空格分隔。 请你重新排列 text 中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。 请同样按上述格式返回新的句子。 示例 1： 1234输入：text = &quot;Leetcode is cool&quot;输出：&quot;Is cool leetcode&quot;解释：句子中共有 3 个单词，长度为 8 的 &quot;Leetcode&quot; ，长度为 2 的 &quot;is&quot; 以及长度为 4 的 &quot;cool&quot; 。输出需要按单词的长度升序排列，新句子中的第一个单词首字母需要大写。 示例 2： 12345678输入：text = &quot;Keep calm and code on&quot;输出：&quot;On and keep calm code&quot;解释：输出的排序情况如下：&quot;On&quot; 2 个字母。&quot;and&quot; 3 个字母。&quot;keep&quot; 4 个字母，因为存在长度相同的其他单词，所以它们之间需要保留在原句子中的相对顺序。&quot;calm&quot; 4 个字母。&quot;code&quot; 4 个字母。 示例 3： 12输入：text = &quot;To be or not to be&quot;输出：&quot;To be or to be not&quot; 提示： text 以大写字母开头，然后包含若干小写字母以及单词间的单个空格。 1 &lt;= text.length &lt;= 10^5 解题思路自己还是要加强对排序的练习，对排序还是很不熟悉 12345678910class Solution &#123; public String arrangeWords(String text) &#123; String[] s=text.toLowerCase().split(" "); Arrays.sort(s,(s1,s2)-&gt;(s1.length()-s2.length()));//按字符长度从小到大排序 char first=(char)(s[0].charAt(0)-32); String temp=first+s[0].substring(1); s[0]=temp; return String.join(" ",s); &#125;&#125;]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1443-收集树上所有苹果的最少时间]]></title>
    <url>%2F2020%2F05%2F20%2FLeetCode1443-%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%8A%E6%89%80%E6%9C%89%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目描述给你一棵有 n 个节点的无向树，节点编号为 0 到 n-1 ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 节点 0 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。 无向树的边由 edges 给出，其中 edges[i] = [fromi, toi] ，表示有一条边连接from 和to 。除此以外，还有一个布尔数组 hasApple ，其中 hasApple[i] = true 代表节点 i 有一个苹果，否则，节点 i 没有苹果。 示例 1： 123输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]输出：8 解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。 示例 2： 123输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]输出：6解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。 示例 3： 12输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]输出：0 提示： 1 &lt;= n &lt;= 10^5 edges.length == n-1 edges[i].length == 2 0 &lt;= fromi, toi &lt;= n-1 fromi &lt; toi hasApple.length == n 解题思路从有苹果的节点往根节点遍历，用result记录走过的路径，每走一条边，result就加1，并用一个visit数组记录对应是否走过该节点，遍历每一个有苹果的节点，最后result记录就是最短路径。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; int result=0; boolean [] visit; public int minTime(int n, int[][] edges, List&lt;Boolean&gt; hasApple) &#123; visit=new boolean[n];//用来标记该节点是否被访问过 int [] father=new int[n];//节点i的父节点就是father[i] Arrays.fill(father,-1); for(int [] temp:edges) &#123; if(father[temp[1]]==-1)//还没有赋值父节点 father[temp[1]]=temp[0]; else father[temp[0]]=temp[1]; &#125; for(int i=0; i&lt;hasApple.size(); i++) &#123; if(hasApple.get(i)) &#123; dfs(i,father); &#125; &#125; return result*2; &#125; private void dfs(int i,int [] father) &#123; if(i==0||visit[i])//已经到根节点，或者该节点已经被访问过 &#123; return; &#125; visit[i]=true; result++; dfs(father[i],father); &#125;&#125;]]></content>
      <categories>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error:Failed to load project configuration: cannot parse file]]></title>
    <url>%2F2020%2F05%2F15%2FError-Failed-to-load-project-configuration-cannot-parse-file%2F</url>
    <content type="text"><![CDATA[spring boot整合jdbc遇到的问题由于是第一次用Spring Initializr创建一个新的项目，导致这个问题搞了一整天，到了晚上终于弄好了 pom.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring_boot_jdbc&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring_boot_jdbc&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.build.outputEncoding&gt;UTF-8&lt;/project.build.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--一定要导jdbc的坐标，不然会报错--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml 123456spring: datasource: username: root password: 'lixin13922171767' url: jdbc:mysql://localhost:3306/eesy driver‐class‐name: com.mysql.jdbc.Driver SpringBootJdbcApplication 1234567891011121314151617181920212223242526package com.example.spring_boot_jdbc;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootJdbcApplicationTests &#123; @Autowired DataSource dataSource; @Test public void contextLoads() throws Exception &#123; System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;&#125; 目录结构如图所示 但是运行的结果就是 12Error:Failed to load project configuration: cannot parse file C:\project\springboot_jdbc_2020\.idea\libraries\Maven__ch_qos_logback_logback_classic_1_2_3.xml: ParseError at [row,col]:[1,1]Message: 前言中不允许有内容。 在网上找了各种方法就是不行，但是我就把.idea文件删掉了，然后重新reimport all maven project,然后配置一下jdk，重新运行，最后就好了]]></content>
      <categories>
        <category>spring boot 笔记</category>
      </categories>
      <tags>
        <tag>spring boot 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thymeleaf导包]]></title>
    <url>%2F2020%2F05%2F14%2Fthymeleaf%E5%AF%BC%E5%8C%85%2F</url>
    <content type="text"><![CDATA[thymeleaf导入相关的版本才能正确进行页面渲染，但是对于新手来说很容易搞错了 引入thymeleaf的错误写法 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt; 切换thymeleaf版本 &lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!‐‐ 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 ‐‐&gt; &lt;!‐‐ thymeleaf2 layout1‐‐&gt; &lt;thymeleaf‐layout‐dialect.version&gt;2.2.2&lt;/thymeleaf‐layout‐dialect.version&gt; &lt;/properties&gt; 正确写法 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;springboot-thymeleaf.version&gt;3.0.9.RELEASE&lt;/springboot-thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 如果有重复的thymeleaf包，运行时会报错，要把多余的包删除]]></content>
      <categories>
        <category>spring boot笔记</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1442-形成两个异或相等数组的三元组数目]]></title>
    <url>%2F2020%2F05%2F11%2FLeetCode1442-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目描述给你一个整数数组 arr 。 现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。 a 和 b 定义如下： a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k] 注意：^ 表示 按位异或 操作。 请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。 示例 1： 123输入：arr = [2,3,1,6,7]输出：4解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4) 示例 2： 12输入：arr = [1,1,1,1,1]输出：10 示例 3： 12输入：arr = [2,3]输出：0 示例 4： 12输入：arr = [1,3,5,7,9]输出：3 示例 5： 12输入：arr = [7,11,12,9,5,2,7,17,22]输出：8 提示： 1 &lt;= arr.length &lt;= 300 1 &lt;= arr[i] &lt;= 10^8 解题思路本来用暴力是很简单的，但是可能是自己前一天晚上玩手机玩到2点的原因，到了比赛的时候，自己就是脑子一团浆糊，就感觉这道题好难，心情都不好了，这道题写了1个多小时，下面看我的代码，ORZ！！！，我自己都哭了。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int countTriplets(int[] arr) &#123; int len=arr.length; int cout=0;//统计对应三元组的数量 for(int i=0; i&lt;len; i++) &#123; int a=arr[i]; for(int j=i+1; j&lt;len; j++) &#123; if(j&gt;i+1) &#123; for(int temp=i+1; temp&lt;j; temp++)//从i一直到j-1 &#123; a=a^arr[temp]; &#125; &#125; int b=arr[j]; for(int k=j; k&lt;len; k++) &#123; if(k==j) &#123; if(a==b) &#123; cout++; //System.out.println(i+" "+j+" "+k+"a="+a+"b="+b); &#125; &#125; if(k&gt;j) &#123; for(int temp1=j+1; temp1&lt;=k; temp1++)//从j到k &#123; b=b^arr[temp1]; &#125; if(a==b) &#123; cout++; //System.out.println(i+" "+j+" "+k+"a="+a+"b="+b); &#125; &#125; &#125; &#125; &#125; return cout; &#125;&#125; 我后来想，可能是自己对异或这个慨念不是很熟悉吧，0异或非零数a等于a，从而导致了一系列的问题。 暴力解法 123456789101112131415161718192021class Solution &#123; public int countTriplets(int[] arr) &#123; int cout=0; for(int i=0; i&lt;arr.length; i++) &#123; int a=0; for(int j=i; j&lt;arr.length; j++) &#123; a=a^arr[j]; int b=0; for(int k=j+1; k&lt;arr.length; k++) &#123; b=b^arr[k]; if(a==b) cout++; &#125; &#125; &#125; return cout; &#125;&#125; 时间复杂度优化这种解法需要记住异或的两个性质：如果a == b，那么a ^ b == 0。反之也成立。异或具有结合率。(a1 ^ a2) ^ a3 =a1 ^ (a2 ^ a3) 题目中a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1],b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]。那么a ^ b = arr[i] ^ arr[i + 1] ^ ... ^ arr[k] a==b,则a^b==0,arr[i] ^ arr[i + 1] ^ ... ^ arr[k]==0,统计arr数组中有多少个i到k满足条件，例如数组1，2，3，下标0到2满足条件，一共有3个元素，则可以分成满足条件的2组，1,2 3和1 2,3,则每一个满足条件的下标i到k，可以生成k-i组的数目。把这些满足条件的统计出来即可。 12345678910111213141516class Solution &#123; public int countTriplets(int[] arr) &#123; int cout=0; for(int i=0; i&lt;arr.length; i++) &#123; int a=arr[i]; for(int k=i+1; k&lt;arr.length; k++) &#123; a=a^arr[k]; if(a==0) cout+=(k-i); &#125; &#125; return cout; &#125;&#125; 时间复杂度从n的三次方降到ln的二次方]]></content>
      <categories>
        <category>暴力</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode529-扫雷游戏]]></title>
    <url>%2F2020%2F05%2F05%2FLeetCode529-%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class position&#123; int x; int y; public position(int a,int b) &#123; x=a; y=b; &#125;&#125;class Solution &#123; public char[][] updateBoard(char[][] board, int[] click) &#123; int rows=board.length; int cols=board[0].length; Queue &lt;position&gt; queue=new LinkedList&lt;&gt;(); position start=new position(click[0],click[1]); queue.offer(start); while(!queue.isEmpty()) &#123; position temp=queue.poll(); if(board[temp.x][temp.y]=='M') &#123; board[temp.x][temp.y]='X'; return board; &#125; //统计该点四周的地雷个数 int cout=0; for(int i=-1; i&lt;=1; i++) &#123; for(int j=-1; j&lt;=1; j++) &#123; if(i==0&amp;&amp;j==0) continue; int tempx=temp.x+i; int tempy=temp.y+j; if(tempx&lt;0||tempx&gt;=rows||tempy&lt;0||tempy&gt;=cols) continue; if(board[tempx][tempy]=='M'||board[tempx][tempy]=='X') cout++; &#125; &#125; if(cout&gt;0)//周边有雷 &#123; board[temp.x][temp.y]=(char)(cout+'0'); &#125; else//周边没有雷 &#123; board[temp.x][temp.y]='B'; for(int i=-1; i&lt;=1; i++) &#123; for(int j=-1; j&lt;=1; j++) &#123; if(i==0&amp;&amp;j==0) continue; int tempx=temp.x+i; int tempy=temp.y+j; if(tempx&lt;0||tempx&gt;=rows||tempy&lt;0||tempy&gt;=cols) continue; if(board[tempx][tempy]=='E') &#123; queue.offer(new position(tempx,tempy)); board[tempx][tempy]='B'; &#125; &#125; &#125; &#125; &#125; return board; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量>=5部]]></title>
    <url>%2F2020%2F05%2F04%2F%E6%9F%A5%E6%89%BE%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF%E4%B8%AD%E5%8C%85%E6%8B%ACrobot%E7%9A%84%E7%94%B5%E5%BD%B1%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%86%E7%B1%BB%E5%90%8D%E7%A7%B0%E4%BB%A5%E5%8F%8A%E7%94%B5%E5%BD%B1%E6%95%B0%E7%9B%AE%EF%BC%8C%E8%80%8C%E4%B8%94%E8%BF%98%E9%9C%80%E8%A6%81%E8%AF%A5%E5%88%86%E7%B1%BB%E5%AF%B9%E5%BA%94%E7%94%B5%E5%BD%B1%E6%95%B0%E9%87%8F-5%E9%83%A8%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 这里的统计count（），一定要明确统计的是哪个表中的字段，不然会出错 12345678select c.name,count(fc.film_id)from (select category_id,count(film_id) as nums from film_category group by category_id having nums&gt;=5) as cc,film as f,category as c,film_category as fcwhere f.description like '%robot%'and f.film_id=fc.film_idand fc.category_id=c.category_idand c.category_id=cc.category_id;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给出每个员工每年薪水涨幅超过5000的员工编号emp_no]]></title>
    <url>%2F2020%2F05%2F04%2F%E7%BB%99%E5%87%BA%E6%AF%8F%E4%B8%AA%E5%91%98%E5%B7%A5%E6%AF%8F%E5%B9%B4%E8%96%AA%E6%B0%B4%E6%B6%A8%E5%B9%85%E8%B6%85%E8%BF%875000%E7%9A%84%E5%91%98%E5%B7%A5%E7%BC%96%E5%8F%B7emp-no%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 给出每个员工每年薪水涨幅超过5000的员工编号emp_no、薪水变更开始日期from_date以及薪水涨幅值salary_growth，并按照salary_growth逆序排列。 提示：在sqlite中获取datetime时间对应的年份函数为strftime(‘%Y’, to_date) 123456CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 题解 123456select s2.emp_no,s2.from_date,(s2.salary-s1.salary) as salary_growthfrom salaries as s1 inner join salaries as s2 on s1.emp_no=s2.emp_noand salary_growth&gt;=5000 and(strftime('%Y', s2.to_date)-strftime('%Y', s1.to_date)=1or strftime('%Y', s2.from_date)-strftime('%Y', s1.from_date)=1)order by salary_growth desc;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇总各个部门当前员工的title类型的分配数目]]></title>
    <url>%2F2020%2F05%2F03%2F%E6%B1%87%E6%80%BB%E5%90%84%E4%B8%AA%E9%83%A8%E9%97%A8%E5%BD%93%E5%89%8D%E5%91%98%E5%B7%A5%E7%9A%84title%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E9%85%8D%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当前员工所有的title以及该类型title对应的数目count 123456789101112131415CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE IF NOT EXISTS `titles` (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL); 123456select de.dept_no as dept_no,d.dept_name as dept_name,t.title as title,count(t.title) as countfrom titles as t inner join dept_emp as de on t.emp_no=de.emp_no and de.to_date='9999-01-01' and t.to_date='9999-01-01'inner join departments as d on de.dept_no=d.dept_nogroup by d.dept_no,t.title;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取员工当前的薪水比器manager当前薪水还高的相关信息]]></title>
    <url>%2F2020%2F05%2F03%2F%E8%8E%B7%E5%8F%96%E5%91%98%E5%B7%A5%E5%BD%93%E5%89%8D%E7%9A%84%E8%96%AA%E6%B0%B4%E6%AF%94%E5%99%A8manager%E5%BD%93%E5%89%8D%E8%96%AA%E6%B0%B4%E8%BF%98%E9%AB%98%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date=’9999-01-01’,结果第一列给出员工的emp_no，第二列给出其manager的manager_no，第三列给出该员工当前的薪水emp_salary,第四列给该员工对应的manager当前的薪水manager_salary 123456789101112131415161718CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 解析 123456select es.emp_no as emp_no,ms.emp_no as manager_no,es.salary as emp_salary,ms.salary as manager_salaryfrom (select s.salary, de.emp_no,de.dept_no from salaries as sinner join dept_emp as de on s.emp_no=de.emp_no and s.to_date='9999-01-01')as es,(select s.salary,dm.emp_no,dm.dept_no from salaries as s inner joindept_manager as dm on s.emp_no=dm.emp_no and s.to_date='9999-01-01')as ms where es.dept_no=ms.dept_no and es.salary&gt; ms.salary;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取所有非manager员工当前的薪水情况]]></title>
    <url>%2F2020%2F05%2F02%2F%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%9D%9Emanager%E5%91%98%E5%B7%A5%E5%BD%93%E5%89%8D%E7%9A%84%E8%96%AA%E6%B0%B4%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ，当前表示to_date=’9999-01-01’ 1234567891011121314151617181920212223242526CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 还不懂就去看题解 12345select de.dept_no,e.emp_no,s.salaryfrom (employees as e inner join dept_emp as de on e.emp_no=de.emp_no) inner join salaries as s on e.emp_no=s.emp_nowhere de.to_date='9999-01-01' and s.to_date='9999-01-01' and e.emp_no not in(select emp_no from dept_manager);]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对所有员工的薪水按照salary进行按照1-N的排名]]></title>
    <url>%2F2020%2F05%2F02%2F%E5%AF%B9%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5%E7%9A%84%E8%96%AA%E6%B0%B4%E6%8C%89%E7%85%A7salary%E8%BF%9B%E8%A1%8C%E6%8C%89%E7%85%A71-N%E7%9A%84%E6%8E%92%E5%90%8D%2F</url>
    <content type="text"><![CDATA[题目描述1234567对所有员工的当前(to_date=&apos;9999-01-01&apos;)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 原题链接 解题思路我怎么感觉sql的查询语句好难啊，都不会做，每道题都要看别人的题解 第一个的题解写得很清晰 12345select a.emp_no,a.salary,count(distinct b.salary)as rankfrom salaries as a,salaries as bwhere a.to_date='9999-01-01' and b.to_date='9999-01-01' and a.salary&lt;=b.salarygroup by a.emp_noorder by a.salary desc,a.emp_no asc;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计各个部门的工资记录数]]></title>
    <url>%2F2020%2F05%2F02%2F%E7%BB%9F%E8%AE%A1%E5%90%84%E4%B8%AA%E9%83%A8%E9%97%A8%E7%9A%84%E5%B7%A5%E8%B5%84%E8%AE%B0%E5%BD%95%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述统计各个部门的工资记录数，给出部门编码dept_no、部门名称dept_name以及次数sum 12345678910111213141516CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 原题链接 1234select de.dept_no,dp.dept_name,count(s.salary)as sumfrom (dept_emp AS de Inner join salaries AS s on de.emp_no=s.emp_no)Inner join departments as dp on de.dept_no=dp.dept_nogroup by de.dept_no;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode407-接雨水II]]></title>
    <url>%2F2020%2F05%2F02%2FLeetCode407-%E6%8E%A5%E9%9B%A8%E6%B0%B4II%2F</url>
    <content type="text"><![CDATA[题目描述给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。 示例： 12345678给出如下 3x6 的高度图:[ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1]]返回 4 。 如上图所示，这是下雨前的高度图[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] 的状态。 下雨后，雨水将会被存储在这些方块中。总的接雨水量是4。 提示： 1 &lt;= m, n &lt;= 110 0 &lt;= heightMap[i][j] &lt;= 20000 解题思路我开始想的是遍历二维数组，每遍历一个位置就判断四周单元格的高度，如果都比当前位置的高度高，取最小的高度，能接的雨水体积就是四周最低高度减去当前的高度，但是这样做例子中第二行第三列就不满足，于是看了别人的博客，写的很详细的博客，十分感谢 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class position&#123; int x; int y; int height; public position(int i,int j,int h) &#123; x=i; y=j; height=h; &#125;&#125;class Solution &#123; int [] dx=new int []&#123;-1,1,0,0&#125;;//上下左右 int [] dy=new int []&#123;0,0,-1,1&#125;;//上下左右 public int trapRainWater(int[][] heightMap) &#123; int rows=heightMap.length; int cols=heightMap[0].length; boolean [][] visit=new boolean[rows][cols]; PriorityQueue &lt;position&gt; queue=new PriorityQueue&lt;position&gt;( new Comparator&lt;position&gt;()&#123; public int compare(position a,position b) &#123; return a.height-b.height; &#125; &#125; ); for(int i=0; i&lt;heightMap.length; i++)//把四周的点入队 &#123; queue.offer(new position(i,0,heightMap[i][0])); visit[i][0]=true; queue.offer(new position(i,cols-1,heightMap[i][cols-1])); visit[i][cols-1]=true; &#125; for(int i=0; i&lt;cols; i++) &#123; queue.offer(new position(0,i,heightMap[0][i])); visit[0][i]=true; queue.offer(new position(rows-1,i,heightMap[rows-1][i])); visit[rows-1][i]=true; &#125; int res=0; while(!queue.isEmpty()) &#123; position temp=queue.poll(); for(int i=0; i&lt;4; i++) &#123; int tx=temp.x+dx[i]; int ty=temp.y+dy[i]; if(tx&gt;=0&amp;&amp;tx&lt;rows&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;cols&amp;&amp;!visit[tx][ty]) &#123; res+=Math.max(0,temp.height-heightMap[tx][ty]); queue.offer(new position(tx,ty,Math.max(temp.height,heightMap[tx][ty]))); visit[tx][ty]=true; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode310-最小高度树]]></title>
    <url>%2F2020%2F04%2F30%2FLeetCode310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。 格式 该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。 你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。 示例 1: 123456789输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]] 0 | 1 / \ 2 3 输出: [1] 示例 2: 1234567891011输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \ | / 3 | 4 | 5 输出: [3, 4] 说明: 根据树的定义，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。 树的高度是指根节点和叶子节点之间最长向下路径上边的数量。 解题思路我开始想的是把每个节点都当成根节点，然后记录相应的高度，最后把高度最小的树的根节点输出，但是超出内存限制了，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123; Map&lt;Integer,List&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();//树的高度对应的根结点 List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); Queue&lt;Integer&gt; queue=new LinkedList&lt;&gt;(); for(int i=0; i&lt;n; i++) &#123; int high=0;//树的高度 queue.offer(i); Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); set.add(i); while(!queue.isEmpty()) &#123; int len=queue.size(); high++; for(int j=0; j&lt;len; j++) &#123; int value=queue.poll(); for(int k=0; k&lt;edges.length; k++) &#123; if(edges[k][0]==value&amp;&amp;!set.contains(edges[k][1])) &#123; queue.offer(edges[k][1]); set.add(edges[k][1]); &#125; if(edges[k][1]==value&amp;&amp;!set.contains(edges[k][0])) &#123; queue.offer(edges[k][0]); set.add(edges[k][0]); &#125; &#125; &#125; &#125; if(!map.containsKey(high)) &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); list.add(i); map.put(high,list); &#125; else &#123; List&lt;Integer&gt; list=map.get(high); list.add(i); &#125; &#125; int max=Integer.MAX_VALUE; for(int key:map.keySet()) &#123; if(key&lt;max) max=key; &#125; return map.get(max); &#125;&#125; 看了别人的解题思路后，从叶子节点往根节点找，每次除去一个叶子节点（也就是度为1的节点），最后剩下的就是根节点。 别人的思路 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123; int [] degree=new int[n]; List&lt;List&lt;Integer&gt;&gt; sublist=new ArrayList&lt;&gt;();//邻接表 for(int i=0; i&lt;n; i++) &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); sublist.add(list); &#125; for(int i=0; i&lt;edges.length; i++)//计算每个节点的度 &#123; degree[edges[i][0]]++; degree[edges[i][1]]++; sublist.get(edges[i][0]).add(edges[i][1]); sublist.get(edges[i][1]).add(edges[i][0]); &#125; Queue&lt;Integer&gt; queue=new LinkedList&lt;&gt;(); for(int i=0; i&lt;n; i++) &#123; if(degree[i]==1)//把度为1的节点入队 queue.offer(i); &#125; List &lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(n==1) &#123; res.add(0); return res; &#125; int nums=n; while(nums&gt;2) &#123; int len=queue.size(); nums=nums-len; for(int i=0; i&lt;len; i++) &#123; int temp=queue.poll(); for(int de:sublist.get(temp)) &#123; if(degree[de]&gt;0) &#123; degree[de]--; &#125; if(degree[de]==1) queue.offer(de); &#125; &#125; &#125; //最后队列里保留的就是根节点 while(!queue.isEmpty()) &#123; int s=queue.poll(); res.add(s); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode301-删除无效的括号]]></title>
    <url>%2F2020%2F04%2F30%2FLeetCode301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目描述删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。 说明: 输入可能包含了除 ( 和 ) 以外的字符。 示例 1: 12输入: &quot;()())()&quot;输出: [&quot;()()()&quot;, &quot;(())()&quot;] 示例 2: 12输入: &quot;(a)())()&quot;输出: [&quot;(a)()()&quot;, &quot;(a())()&quot;] 示例 3: 12输入: &quot;)(&quot;输出: [&quot;&quot;] 解题思路利用BFS，每删除一个括号，就判断是否合法的括号 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public List&lt;String&gt; removeInvalidParentheses(String s) &#123; List&lt;String&gt; res=new ArrayList&lt;&gt;(); Queue&lt;String&gt; queue=new LinkedList&lt;&gt;(); queue.offer(s); boolean flag=false;//用来判断每删除一个括号，是否已经找到合法的括号 Set&lt;String&gt; set=new HashSet&lt;&gt;();//防止找到重复的合法括号 set.add(s); while(!queue.isEmpty()) &#123; String temps=queue.poll(); if(judge(temps)) &#123; res.add(temps); flag=true; &#125; if(flag==true) continue; for(int i=0; i&lt;temps.length(); i++) &#123; if(temps.charAt(i)!='('&amp;&amp;temps.charAt(i)!=')') continue; String news=temps.substring(0,i)+temps.substring(i+1,temps.length()); if(!set.contains(news)) &#123; set.add(news); queue.offer(news); &#125; &#125; &#125; return res; &#125; private boolean judge(String s)//判断是否是合法的括号 &#123; int cnt=0; for(int i=0; i&lt;s.length(); i++) &#123; if(s.charAt(i)=='(') cnt++; if(s.charAt(i)==')') cnt--; if(cnt&lt;0) return false; &#125; return cnt==0; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode279-完全平方数]]></title>
    <url>%2F2020%2F04%2F29%2FLeetCode279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于* n*。你需要让组成和的完全平方数的个数最少。 示例 1: 123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 123输入: n = 13输出: 2解释: 13 = 4 + 9. 1234567891011121314151617181920212223242526272829class Solution &#123; public int numSquares(int n) &#123; Queue&lt;Integer&gt; queue=new LinkedList&lt;&gt;(); Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); queue.offer(n); int level=0; while(!queue.isEmpty()) &#123; int len=queue.size(); level++; for(int i=0; i&lt;len; i++) &#123; int temp=queue.poll(); for(int j=1; j*j&lt;=temp; j++) &#123; int res=temp-j*j; if(res==0) return level; if(!set.contains(res)) &#123; queue.offer(res); set.add(res); &#125; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode239-滑动窗口最大值]]></title>
    <url>%2F2020%2F04%2F29%2FLeetCode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例: 123456789101112输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 1 &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 1 &lt;= k &lt;= nums.length 解题思路本来用暴力解决是可以通过的，但是时间复杂度是O(n*k),利用双端队列可以O(n)，上周周赛最后一道题要用到双端队列，看别人的题解没看懂，这里顺便学习一下，视频链接 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int len=nums.length; if(len==0) return new int[]&#123;&#125;; int [] res=new int[len-k+1]; int index=0; /*for(int i=0; i&lt;=len-k; i++) &#123; int max=Integer.MIN_VALUE; for(int j=i; j&lt;i+k; j++) &#123; max=Math.max(max,nums[j]); &#125; res[i]=max; &#125;*/ //存储是数组的索引值 Deque&lt;Integer&gt; deque=new LinkedList&lt;&gt;(); for(int i=0; i&lt;len; i++) &#123; //头: 移除头部, 保证窗口的长度范围 if(!deque.isEmpty()&amp;&amp;deque.getFirst()&lt;i-k+1) deque.removeFirst(); //尾: 移除尾部小于当前值得元素,去除不可能的元素 while(!deque.isEmpty()&amp;&amp;nums[deque.getLast()]&lt;=nums[i]) &#123; deque.removeLast(); &#125; // 尾部加入, 滑动窗口向右扩充 deque.addLast(i); //从头部返回最大值 if(i&gt;=k-1) res[index++]=nums[deque.getFirst()]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>双端队列</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1423-可获得的最大点数]]></title>
    <url>%2F2020%2F04%2F28%2FLeetCode1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例 1： 123输入：cardPoints = [1,2,3,4,5,6,1], k = 3输出：12解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 123输入：cardPoints = [2,2,2], k = 2输出：4解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。 示例 3： 123输入：cardPoints = [9,7,7,9,7,7,9], k = 7输出：55解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。 示例 4： 123输入：cardPoints = [1,1000,1], k = 1输出：1解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5： 12输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3输出：202 提示： 1 &lt;= cardPoints.length &lt;= 10^5 1 &lt;= cardPoints[i] &lt;= 10^4 1 &lt;= k &lt;= cardPoints.length 解题思路先求数组的前缀和，左边取前n个数，右边取从后面往前面的m个数，n+m等于k，从左往右边滑动。获得其中最大值。 1234567891011121314151617class Solution &#123; public int maxScore(int[] cardPoints, int k) &#123; int len=cardPoints.length; int [] pre=new int[len+1]; pre[0]=0; for(int i=0; i&lt;len; i++)//求数组的前缀和 &#123; pre[i+1]=pre[i]+cardPoints[i]; &#125; int max=-1; for(int i=0; i&lt;=k; i++)//从左往右滑动，求最大值 &#123; max=Math.max(max,pre[i]+pre[len]-pre[len-k+i]); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1424-对角线遍历II]]></title>
    <url>%2F2020%2F04%2F28%2FLeetCode1424-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86II%2F</url>
    <content type="text"><![CDATA[题目描述给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。 示例 1： 12输入：nums = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,4,2,7,5,3,8,6,9] 示例 2： 12输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] 示例 3： 12输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]输出：[1,4,2,5,3,8,6,9,7,10,11] 示例 4： 12输入：nums = [[1,2,3,4,5,6]]输出：[1,2,3,4,5,6] 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i].length &lt;= 10^5 1 &lt;= nums[i][j] &lt;= 10^9 nums 中最多有 10^5 个数字。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[] findDiagonalOrder(List&lt;List&lt;Integer&gt;&gt; nums) &#123; int len=0;//记录列表中数字的个数 Map&lt;Integer,List&lt;Integer&gt;&gt; map=new TreeMap&lt;&gt;();//对角线上横坐标和纵坐标的和是一定的 for(int i=0; i&lt;nums.size(); i++) &#123; len+=nums.get(i).size(); for(int j=0; j&lt;nums.get(i).size(); j++) &#123; if(map.containsKey(i+j)) &#123; List&lt;Integer&gt; temp=map.get(i+j); temp.add(nums.get(i).get(j)); &#125; else &#123; List&lt;Integer&gt; temp=new ArrayList&lt;&gt;(); temp.add(nums.get(i).get(j)); map.put(i+j,temp); &#125; &#125; &#125; int [] res=new int[len]; int k=0; for(int key:map.keySet()) &#123; List&lt;Integer&gt; s=map.get(key); for(int i=s.size()-1;i&gt;=0; i--)//按照题意顺序输出数组 &#123; res[k++]=s.get(i); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>List</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode207-课程表]]></title>
    <url>%2F2020%2F04%2F25%2FLeetCode207-%E8%AF%BE%E7%A8%8B%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例 1: 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示： ​ 1.输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。​ 2.你可以假定输入的先决条件中没有重复的边。​ 3.1 &lt;= numCourses &lt;= 10^5 解题思路别人的详细解答 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; int [] indegrees=new int[numCourses];//记录每门课程的入度 List&lt;List&lt;Integer&gt;&gt; adjacency=new ArrayList&lt;&gt;(); for(int i=0; i&lt;numCourses; i++)//adjacency[i]记录的是修完第i门课的可以学习的后续课程 &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); adjacency.add(list); &#125; for(int [] temp:prerequisites) &#123; indegrees[temp[0]]++;//记录i课程的入度 adjacency.get(temp[1]).add(temp[0]);//学习完temp[1]可以学习temp[0] &#125; Queue&lt;Integer&gt; queue=new LinkedList&lt;&gt;(); for(int i=0; i&lt;numCourses; i++) &#123; if(indegrees[i]==0)//入度为0的课程入队 queue.offer(i); &#125; while(!queue.isEmpty()) &#123; int pre=queue.poll(); numCourses--; for(int s:adjacency.get(pre)) &#123; indegrees[s]--; if(indegrees[s]==0) queue.offer(s); &#125; &#125; return numCourses==0; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1419-数青蛙]]></title>
    <url>%2F2020%2F04%2F22%2FLeetCode1419-%E6%95%B0%E9%9D%92%E8%9B%99%2F</url>
    <content type="text"><![CDATA[题目描述给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 croakOfFrogs 中会混合多个 “croak” 。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。 注意：要想发出蛙鸣 “croak”，青蛙必须 依序 输出 ‘c’, ’r’, ’o’, ’a’, ’k’ 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。 如果字符串 croakOfFrogs 不是由若干有效的 “croak” 字符混合而成，请返回 -1 。 示例 1： 123输入：croakOfFrogs = &quot;croakcroak&quot;输出：1 解释：一只青蛙 “呱呱” 两次 示例 2： 12345输入：croakOfFrogs = &quot;crcoakroak&quot;输出：2 解释：最少需要两只青蛙，“呱呱” 声用黑体标注第一只青蛙 &quot;crcoakroak&quot;第二只青蛙 &quot;crcoakroak&quot; 示例 3： 123输入：croakOfFrogs = &quot;croakcrook&quot;输出：-1解释：给出的字符串不是 &quot;croak&quot; 的有效组合。 示例 4： 12输入：croakOfFrogs = &quot;croakcroa&quot;输出：-1 提示： 1 &lt;= croakOfFrogs.length &lt;= 10^5 字符串中的字符只有 &#39;c&#39;, &#39;r&#39;, &#39;o&#39;, &#39;a&#39; 或者 &#39;k&#39; 解题思路大佬的思路 分别用c,r,o,a,k统计对应字符出现的次数，遍历给的字符，如果遍历到字符’r’,那么r的个数加1，c的个数减1.遍历到字符c时，那么c的个数加1，对应k的个数减1，如果这时k的个数等于0，对应的青蛙的个数加1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.*;class Solution &#123; public int minNumberOfFrogs(String croakOfFrogs) &#123; int c=0,r=0,o=0,a=0,k=0; char [] chars=croakOfFrogs.toCharArray(); int res=0;//统计青蛙的个数 for(int i=0; i&lt;chars.length; i++) &#123; if(chars[i]=='c') &#123; if(k&gt;0) k--; else res++; c++; &#125; if(chars[i]=='r') &#123; c--; r++; &#125; if(chars[i]=='o') &#123; r--; o++; &#125; if(chars[i]=='a') &#123; o--; a++; &#125; if(chars[i]=='k') &#123; a--; k++; &#125; if(c&lt;0||r&lt;0||o&lt;0||a&lt;0||k&lt;0) &#123; //System.out.println(c+" "+r+" "+o+" "+a+" "+k); return -1; &#125; &#125; if(c!=0||r!=0||o!=0||a!=0) &#123; //System.out.println(c+" "+r+" "+o+" "+a+" "+k); return -1; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1418-点菜展示表]]></title>
    <url>%2F2020%2F04%2F22%2FLeetCode1418-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi]，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi是客户点的餐品名称。 请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。 注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。 示例 1： 1234567891011输入：orders = [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]]输出：[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] 解释：点菜展示表如下所示：Table,Beef Burrito,Ceviche,Fried Chicken,Water3 ,0 ,2 ,1 ,05 ,0 ,1 ,0 ,110 ,1 ,0 ,0 ,0对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot;而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot;餐桌 10：Corina 点了 &quot;Beef Burrito&quot; 示例 2： 12345输入：orders = [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]]输出：[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] 解释：对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot;而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot; 示例 3： 12输入：orders = [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]]输出：[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]] 提示： 1 &lt;= orders.length &lt;= 5 * 10^4 orders[i].length == 3 1 &lt;= customerNamei.length, foodItemi.length &lt;= 20 customerNamei 和 foodItemi 由大小写英文字母及空格字符 ‘ ‘ 组成。 tableNumberi 是 1 到 500 范围内的整数。 解题思路这道题自己有太多的知识盲点，二维的List怎么加入元素，我只直到二维List中加入一维List，只知道HashMap，没用过TreeMap,原来TreeMap还可以对当中的元素进行排序，默认是升序，怎么对容器的元素按照题目的要求进行排序，都不熟练，在比赛的时候当然就没有做出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public List&lt;List&lt;String&gt;&gt; displayTable(List&lt;List&lt;String&gt;&gt; orders) &#123; TreeMap&lt;String,Map&lt;String,Integer&gt;&gt; tableid_food=new TreeMap&lt;&gt;(new Comparator&lt;String&gt;()&#123; public int compare(String o1,String o2)//按桌子的id从小到大排序 &#123; return Integer.valueOf(o1)-Integer.valueOf(o2); &#125; &#125;); Set&lt;String&gt; foodNameset=new HashSet&lt;&gt;();//里面是菜单名 for(List&lt;String&gt; list:orders) &#123; String tableid=list.get(1); String foodName=list.get(2); foodNameset.add(foodName); if(tableid_food.containsKey(tableid))//TreeMap中有这个桌子号 &#123; Map&lt;String,Integer&gt;food_cout=tableid_food.get(tableid);//获取对应食物和统计数 food_cout.put(foodName,food_cout.getOrDefault(foodName,0)+1); &#125; else &#123; Map&lt;String,Integer&gt;food_cout=new HashMap&lt;&gt;(); food_cout.put(foodName,1); tableid_food.put(tableid,food_cout); &#125; &#125; List&lt;String&gt; foodlist=new ArrayList&lt;&gt;(foodNameset); foodlist.sort(new Comparator&lt;String&gt;()&#123; public int compare(String l1,String l2) &#123; return l1.compareTo(l2); &#125; &#125;);//list中按首字母从小到大排序 List&lt;List&lt;String&gt;&gt;menus=new ArrayList&lt;&gt;(); for(Map.Entry&lt;String,Map&lt;String,Integer&gt;&gt;entry:tableid_food.entrySet()) &#123; String tableid=entry.getKey(); List&lt;String&gt;tempmenus=new ArrayList&lt;&gt;();//统计当前桌的菜名和对应菜的数量 tempmenus.add(tableid); for(String foodName:foodlist) &#123; tempmenus.add(entry.getValue().getOrDefault(foodName,0)+""); &#125; menus.add(tempmenus); &#125; List&lt;List&lt;String&gt;&gt;fianlMenus=new ArrayList&lt;&gt;();//最终的菜单 foodlist.add(0,"Table"); fianlMenus.add(foodlist); fianlMenus.addAll(menus); return fianlMenus; &#125;&#125;]]></content>
      <categories>
        <category>Map</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>排序</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCP 10-二叉树任务调度]]></title>
    <url>%2F2020%2F04%2F20%2FLCP-10-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。 通常任务之间是存在依赖关系的，即对于某个任务，你需要先完成他的前导任务（如果非空），才能开始执行该任务。我们保证任务的依赖关系是一棵二叉树，其中 root 为根任务，root.left 和 root.right 为他的两个前导任务（可能为空），root.val 为其自身的执行时间。 在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。 现在，系统有两个 CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。 示例 1： 12345输入：root = [47, 74, 31]输出：121解释：根节点的左右节点可以并行执行31分钟，剩下的43+47分钟只能串行执行，因此总体执行时间是121分钟。 示例 2： 123输入：root = [15, 21, null, 24, null, 27, 26]输出：87 示例 3： 123输入：root = [1,3,2,null,null,4,4]输出：7.5 限制： 1 &lt;= 节点数量 &lt;= 1000 1 &lt;= 单节点执行时间 &lt;= 1000 解题思路比赛的时候，题目都看错了，做了二十多分钟，以为自己要做出来，只是时间到了，看成先遍历根节点，然后才能遍历左右子树，题目是先遍历左右子树才能遍历根节点。别人的思路 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public double minimalExecTime(TreeNode root) &#123; double [] res=searchTree(root); return res[0]; &#125; private double [] searchTree(TreeNode root) &#123; if(root==null) return new double []&#123;0.0D,0.0D&#125;; double [] leftv=searchTree(root.left); double [] rightv=searchTree(root.right); double sum=leftv[1]+rightv[1]; double minivalue=Math.max(Math.max(leftv[0],rightv[0]),sum/2)+root.val; return new double []&#123;minivalue,sum+root.val&#125;; &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCP 09-最小跳跃次数]]></title>
    <url>%2F2020%2F04%2F20%2FLCP-09-%E6%9C%80%E5%B0%8F%E8%B7%B3%E8%B7%83%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 jump[i] 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 i+jump[i] 的弹簧（若 i+jump[i]&gt;=N ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。 为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。 示例 1： 12345输入：jump = [2, 5, 1, 1, 1, 1]输出：3解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -&gt; 2 -&gt; 1 -&gt; 6，最终小球弹出了机器。 限制： 1 &lt;= jump.length &lt;= 10^6 1 &lt;= jump[i] &lt;= 10000 解题思路比赛的时候，用的是暴力每访问一个位置，都要重新从0到该位置之间的每个位置是否比往右边下一个跳的位置更远，时间复杂度为n×n,结果就超时了。。。。。。。 看别人用BFS也可以做，先是从0位置开始，每访问一个位置，就标记该位置已经被访问，下次就不需要访问该位置了，时间复杂度为n,大佬博客 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int minJump(int[] jump) &#123; int len=jump.length; int [] flag=new int[len];//用来标记该位置是否被访问 Queue &lt;Integer&gt; position=new LinkedList&lt;&gt;(),ifgo=new LinkedList&lt;&gt;(); for(int i=0; i&lt;len; i++) ifgo.offer(i); position.offer(0); int cout=0;//统计走的步数 while(!position.isEmpty()) &#123; int n=position.size(); for(int i=0; i&lt;n; i++) &#123; int temp=position.poll(); flag[temp]=1; if(temp+jump[temp]&gt;=len) &#123; return cout+1; &#125; //向右找 if(flag[temp+jump[temp]]==0) &#123; flag[temp+jump[temp]]=1; position.offer(temp+jump[temp]); &#125; //向左找 while(!ifgo.isEmpty()&amp;&amp;ifgo.peek()&lt;temp) &#123; int num=ifgo.poll(); if(flag[num]==0) &#123; flag[num]=1; position.offer(num); &#125; &#125; &#125; cout++; &#125; return cout; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCP 08-剧情触发时间]]></title>
    <url>%2F2020%2F04%2F20%2FLCP-08-%E5%89%A7%E6%83%85%E8%A7%A6%E5%8F%91%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目描述在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。 随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 increase 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 [[1,2,1],[3,4,2]] 表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。 所有剧情的触发条件也用一个二维数组 requirements 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 c[i], r[i], h[i]，如果当前 C &gt;= c[i] 且 R &gt;= r[i] 且 H &gt;= h[i] ，则剧情会被触发。 根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。 示例 1： 123456789101112131415输入： increase = [[2,8,4],[2,5,0],[10,9,8]] requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]]输出: [2,-1,3,-1]解释：初始时，C = 0，R = 0，H = 0第 1 天，C = 2，R = 8，H = 4第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2剧情 1 和 3 无法触发。 示例 2： 123输入： increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]] requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]]输出: [-1,4,3,3,3] 示例 3： 123输入： increase = [[1,1,1]] requirements = [[0,0,0]]输出: [0] 限制： 1 &lt;= increase.length &lt;= 10000 1 &lt;= requirements.length &lt;= 100000 0 &lt;= increase[i] &lt;= 10 0 &lt;= requirements[i] &lt;= 100000 解题思路比赛的时候，我就知道用暴力，最终超时，自己在瞎搞时间优化，最后也没有优化出来，判断条件调换顺序什么的，因为我看requirement是没有顺序的，但是忘了increase是有顺序的。用二分查找就出来了，哎！ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int[] getTriggerTime(int[][] increase, int[][] requirements) &#123; int [] res=new int [requirements.length]; for(int i=1; i&lt;increase.length; i++) &#123; increase[i][0]+=increase[i-1][0]; increase[i][1]+=increase[i-1][1]; increase[i][2]+=increase[i-1][2]; &#125; for(int i=0; i&lt;requirements.length; i++) &#123; if(requirements[i][0]==0&amp;&amp;requirements[i][1]==0&amp;&amp;requirements[i][2]==0) &#123; res[i]=0; continue; &#125; int left=0; int right=increase.length-1; if(!(increase[right][0]&gt;=requirements[i][0]&amp;&amp;increase[right][1]&gt;=requirements[i][1]&amp;&amp;increase[right][2]&gt;=requirements[i][2])) &#123; res[i]=-1; continue; &#125; while(left&lt;right) &#123; int mid=(left+right)/2; if(!(increase[mid][0]&gt;=requirements[i][0]&amp;&amp;increase[mid][1]&gt;=requirements[i][1]&amp;&amp;increase[mid][2]&gt;=requirements[i][2])) &#123; left=mid+1; &#125; else &#123; right=mid; &#125; &#125; res[i]=left+1; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCP 07-传递信息]]></title>
    <url>%2F2020%2F04%2F20%2FLCP-07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[题目描述小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： ​ 1.有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0​ 2.每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。​ 3.每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。 示例 1： 输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3 输出：3 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。 示例 2： 12345输入：n = 3, relation = [[0,2],[2,1]], k = 2输出：0解释：信息不能从小 A 处经过 2 轮传递到编号 2 限制： 2 &lt;= n &lt;= 10 1 &lt;= k &lt;= 5 1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2 0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1] 解题思路比赛的时候，我用递归去解，最后栈溢出了，BFS也没有想到，真的是菜到了极点，看了别人的解题思路后，用BFS解题 用一个队列，定义一个Node的类，类中有该节点的下一个位置(next),遍历到该点的步数level，先把起始点是0的点，把下一点的位置入队，起始点的level是1.举个例子，比如[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4],起始点是0的有[0,2],[0,4]，则Node(2,1)，Node(4,1)入队,通过BFS遍历，遍历二维数组，起始点是2的，则把对应的下一个位置入队，对应的leve等于当前level加1，[2,1],[2,0]，满足条件，Node(1,2)，Node(0,2)入队,一直到到n-1并且对应走的步数为k，则对应的统计数加1. 12345678910111213141516171819202122232425262728293031323334353637class Node&#123; int next; int level; public Node(int next,int level) &#123; this.next=next; this.level=level; &#125;&#125;class Solution &#123; public int numWays(int n, int[][] relation, int k) &#123; Queue &lt;Node&gt; queue=new LinkedList&lt;&gt;(); int res=0; for(int i=0; i&lt;relation.length; i++) &#123; if(relation[i][0]==0) queue.offer(new Node(relation[i][1],1)); &#125; while(!queue.isEmpty()) &#123; Node temp=queue.poll(); if(temp.next==n-1&amp;&amp;temp.level==k) res++; else if(temp.level&lt;k) &#123; for(int i=0; i&lt;relation.length; i++) &#123; if(relation[i][0]==temp.next) &#123; queue.offer(new Node(relation[i][1],temp.level+1)); &#125; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>LeetCode春季赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis笔记]]></title>
    <url>%2F2020%2F04%2F19%2Fmybatis%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.环境搭建环境搭建的注意事项： 1.mybatis的映射配置文件位置必须和dao接口的包结构相同 2.映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 3.映射配置文件的操作配置(select),id属性的取值必须是dao接口的方法名 当我们遵从了上面三点之后，我们在开发中就无须再写dao的实现类 2.连接池连接池： 我们在实际开发中都会使用连接池，因为它可以减少我们获取连接的所消耗的时间。 连接池就是用于存储连接的一个容器。 容器其实就是一个集合对象，该集合必须是线程安全的，不能两个线程拿到统一连接，该集合还必须实现队列的特性，先进先出 mybatis中的连接池 mybatis连接池提供了3种方式的配置： 配置的位置： ​ 主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式 type属性的取值： ​ POOLED 采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现（常用） ​ UNPOOLED 采用传统的获取连接的方式，虽然也实现javax.sql.DataSource接口，但是并没有使用池的思想 ​ JNDI 采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样的 ​ 注意： 如果不是web或者maven的war工程，是不能使用的。我们课程中使用的是tomcat服务器，采用连接池dbcp连接池。 mybatis中的事务 ​ 什么是事务 ​ 事务的四大特性ACID ​ 不考虑隔离性会产生的3个问题 ​ 解决办法：四种隔离级别（4个常见面试题） ​ 它是通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚 ​]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC跨服务上传文件遇到的问题]]></title>
    <url>%2F2020%2F04%2F16%2FSpringMVC%E8%B7%A8%E6%9C%8D%E5%8A%A1%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.在学习SpringMVC跨服务上传文件遇到的问题pom.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springmvc_day02_02_fileupload&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;springmvc_day02_02_fileupload Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springmvc_day02_02_fileupload&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml文件 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 配置前端的控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc.xml配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; index.jsp文件 12345678910111213141516171819202122232425262728293031323334&lt;%-- Created by IntelliJ IDEA. User: 86139 Date: 2020/4/15 Time: 21:52 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;文件上传&lt;/h1&gt;&lt;%-- 写成action="/user/fileupload1"，找了一晚上也没有找出来 --%&gt; &lt;form action="user/fileupload1" method="post" enctype="multipart/form-data"&gt; 选择文件:&lt;input type="file" name="upload"/&gt;&lt;br/&gt; &lt;input type="submit" value="上传"/&gt; &lt;/form&gt; &lt;h1&gt;SpringMVC文件上传&lt;/h1&gt; &lt;form action="user/fileupload2" method="post" enctype="multipart/form-data"&gt; 选择文件:&lt;input type="file" name="upload"/&gt;&lt;br/&gt; &lt;input type="submit" value="上传"/&gt; &lt;/form&gt; &lt;h1&gt;跨服务器文件上传&lt;/h1&gt; &lt;form action="user/fileupload3" method="post" enctype="multipart/form-data"&gt; 选择文件:&lt;input type="file" name="upload"/&gt;&lt;br/&gt; &lt;input type="submit" value="上传"/&gt; &lt;/form&gt; &lt;a href="user/haha"&gt;haha&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; springmvc.xml文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 开启注解扫描--&gt; &lt;context:component-scan base-package="cn.itcast"&gt;&lt;/context:component-scan&gt;&lt;!-- 配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;!-- 文件所在的目录--&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt;&lt;!-- 文件的后缀名--&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 前端控制器，哪些静态资源不拦截--&gt; &lt;mvc:resources location="/css/" mapping="/css/**"/&gt; &lt;!-- 样式 --&gt; &lt;mvc:resources location="/images/" mapping="/images/**"/&gt; &lt;!-- 图片 --&gt; &lt;mvc:resources location="/js/" mapping="/js/**"/&gt; &lt;!-- javascript --&gt;&lt;!-- 配置文件解析器对象--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启springmvc框架注解的支持--&gt; &lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; UserController.java文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package cn.itcast.controller;import com.sun.jersey.api.client.Client;import com.sun.jersey.api.client.WebResource;import jdk.nashorn.internal.ir.RuntimeNode;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.List;import java.util.UUID;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.springframework.web.multipart.MultipartFile;/** * @author lixin * @create 2020-04-15 21:53 */@Controller@RequestMapping("/user")public class UserController &#123; /** * 传统的方式 * @param request * @return * @throws Exception */ @RequestMapping("/fileupload1") public String fileupload1(HttpServletRequest request) throws Exception &#123; System.out.println("文件上传"); //使用fileupload组件完成文件上传 //上传位置 String path = request.getSession().getServletContext().getRealPath("/uploads/"); //判断，该路径是否存在 File file=new File(path); if (!file.exists()) &#123; //创建该文件夹 file.mkdirs(); &#125; //解析request对象，获取上传文件项 DiskFileItemFactory factory=new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); //解析request List&lt;FileItem&gt; items = upload.parseRequest(request); //遍历 for(FileItem item:items) &#123; //进行判断，当前item对象是否是上传文件项 if(item.isFormField())&#123; //说明普通表单项 &#125; else&#123; //说明上传文件项 //获取上传文件的名称 String filename = item.getName(); //把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace("-", " "); filename = uuid+"-"+filename; //完成文件上传 item.write(new File(path,filename)); //删除临时文件 item.delete(); &#125; &#125; return "success"; &#125; /** * SpringMVC的方式 * @param request * @return * @throws Exception */ @RequestMapping("/fileupload2") public String fileupload2(HttpServletRequest request, MultipartFile upload) throws Exception &#123; System.out.println("springmvc文件上传"); //使用fileupload组件完成文件上传 //上传位置 String path = request.getSession().getServletContext().getRealPath("/uploads/"); //判断，该路径是否存在 File file=new File(path); if (!file.exists()) &#123; //创建该文件夹 file.mkdirs(); &#125; //说明上传文件项 //获取上传文件的名称 String filename = upload.getOriginalFilename(); //把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace("-", " "); filename = uuid+"-"+filename; //完成文件上传 upload.transferTo(new File(path,filename)); return "success"; &#125; /** * 跨服务器文件上传 * @param request * @param upload * @return * @throws Exception */ @RequestMapping("/fileupload3") public String fileupload3( MultipartFile upload) throws Exception &#123; System.out.println("跨服务器文件上传"); //定义上传文件服务器路径 String path= "http://localhost:9090/fileupload_server_war_exploded/uploads/"; //说明上传文件项 //获取上传文件的名称 String filename = upload.getOriginalFilename(); //把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace("-", ""); filename = uuid+"-"+filename; //创建客户端的对象 Client client = Client.create(); //和图片服务器进行连接 WebResource webResource = client.resource(path + filename); //上传文件 webResource.put(upload.getBytes()); return "success"; &#125; @RequestMapping("/haha") public String fileupload2() &#123; System.out.println("haha"); return "success"; &#125;&#125; 2.遇到的错误错误一 如果userController.java文件中写 String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot; &quot;); 会出现500的错误 123456HTTP Status 500 – Internal Server ErrorType Exception ReportMessage Request processing failed; nested exception is java.lang.IllegalArgumentException: Illegal character in path at index 69: http://localhost:9090/fileupload_server_war_exploded/uploads/f4b414a9 ca5e 4ea2 ba86 12b4cc5b16f8-1581518862564.jpegDescription The server encountered an unexpected condition that prevented it from fulfilling the request. 截图发不上，我暂时就不发了 正确的写法： String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); url中不能有空格 错误二 如果tomcat中没有配置，就会报405 Method Not Allowed错误 要在tomcat/conf/web.xml配置，加的配置代码如下： 1234&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; 今天github又大姨妈了，上传不了图片。。。]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode350-两个数组的交集II]]></title>
    <url>%2F2020%2F04%2F14%2FLeetCode350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II%2F</url>
    <content type="text"><![CDATA[题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2: 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 解题思路先对两个数组进行排序，然后用双指针遍历两个数组，把相等的数放到一个数组中。 123456789101112131415161718192021222324252627class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; int len1=nums1.length; int len2=nums2.length; Arrays.sort(nums2); Arrays.sort(nums1); int [] res=new int[len1]; int i=0,j=0,k=0; while(i&lt;len1&amp;&amp;j&lt;len2) &#123; if(nums1[i]&gt;nums2[j]) &#123; j++; &#125; else if(nums1[i]&lt;nums2[j]) &#123; i++; &#125; else &#123; res[k++]=nums2[j++]; i++; &#125; &#125; return Arrays.copyOfRange(res,0,k); &#125;&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode355-设计推特]]></title>
    <url>%2F2020%2F04%2F14%2FLeetCode355-%E8%AE%BE%E8%AE%A1%E6%8E%A8%E7%89%B9%2F</url>
    <content type="text"><![CDATA[题目描述设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能： 1.postTweet(userId, tweetId): 创建一条新的推文 2.getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。 3.follow(followerId, followeeId): 关注一个用户 4.unfollow(followerId, followeeId): 取消关注一个用户 示例: 123456789101112131415161718192021222324Twitter twitter = new Twitter();// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).twitter.postTweet(1, 5);// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.twitter.getNewsFeed(1);// 用户1关注了用户2.twitter.follow(1, 2);// 用户2发送了一个新推文 (推文id = 6).twitter.postTweet(2, 6);// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].// 推文id6应当在推文id5之前，因为它是在5之后发送的.twitter.getNewsFeed(1);// 用户1取消关注了用户2.twitter.unfollow(1, 2);// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.// 因为用户1已经不再关注用户2.twitter.getNewsFeed(1); 想法设计题自己还是差点，主要是自己对有的数据结构不是很熟悉，尤其是HashMap，要对数据结构烂熟于心，自己不是很熟，所以总是不知道如何下手，但是做出来还是很有成就感的。 看了这篇文章 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127class tweet&#123; int id;//推特id int timestamp;//发推文的时间 tweet next;//指针 public tweet(int x,int y) &#123; id=x; timestamp=y; &#125;&#125;class Twitter &#123; private int timestamp=0; private Map&lt;Integer,tweet&gt; user_tweet; private Map&lt;Integer,Set &lt;Integer&gt; &gt; user_Folllwing; private PriorityQueue &lt;tweet&gt; Maxheap; /** Initialize your data structure here. */ public Twitter() &#123; user_tweet=new HashMap&lt;&gt;(); user_Folllwing=new HashMap&lt;&gt;(); Maxheap=new PriorityQueue&lt;tweet&gt;((t1,t2)-&gt;t2.timestamp-t1.timestamp);//建立按发推特时间的大顶堆，也就是堆顶是最新发送的推特 &#125; /** Compose a new tweet. */ public void postTweet(int userId, int tweetId) &#123; timestamp++; if(user_tweet.containsKey(userId)) &#123; tweet oldhead=user_tweet.get(userId); tweet newhead=new tweet(tweetId,timestamp); newhead.next=oldhead; user_tweet.put(userId,newhead); &#125; else user_tweet.put(userId,new tweet(tweetId,timestamp)); &#125; /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ public List&lt;Integer&gt; getNewsFeed(int userId) &#123; //由于是全局使用，使用前大顶堆要清空 Maxheap.clear(); tweet head=user_tweet.get(userId); if(head!=null)//进堆时要判断是否为空 Maxheap.offer(head); Set&lt;Integer&gt; followees=user_Folllwing.get(userId); if(followees!=null) &#123; for(Integer use:followees) &#123; tweet temp=user_tweet.get(use); if(temp!=null) Maxheap.offer(temp); &#125; &#125; List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); int cout=0; while(!Maxheap.isEmpty()&amp;&amp;cout&lt;10) &#123; tweet lasttweet=Maxheap.poll(); res.add(lasttweet.id); if(lasttweet.next!=null) &#123; Maxheap.offer(lasttweet.next); &#125; cout++; &#125; return res; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ public void follow(int followerId, int followeeId) &#123; if(followerId==followeeId)//要关注的id和自己的id相等 return; Set&lt;Integer&gt; mysubscribe=user_Folllwing.get(followerId); if(mysubscribe!=null) &#123; mysubscribe.add(followeeId); user_Folllwing.put(followerId,mysubscribe); &#125; else &#123; //这里不这样写会报空指针异常，找了好久！！！ Set&lt;Integer&gt; subscribe=new HashSet&lt;&gt;(); subscribe.add(followeeId); user_Folllwing.put(followerId,subscribe); &#125; &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ public void unfollow(int followerId, int followeeId) &#123; if(followerId==followeeId) return; Set&lt;Integer&gt; mysubscribe=user_Folllwing.get(followerId); if(mysubscribe!=null) &#123; mysubscribe.remove(followeeId); &#125; else return; &#125; public static void main(String[] args) &#123; Twitter twitter = new Twitter(); twitter.postTweet(1, 1); List&lt;Integer&gt; res1 = twitter.getNewsFeed(1); System.out.println(res1); twitter.follow(2, 1); List&lt;Integer&gt; res2 = twitter.getNewsFeed(2); System.out.println(res2); twitter.unfollow(2, 1); List&lt;Integer&gt; res3 = twitter.getNewsFeed(2); System.out.println(res3); &#125;&#125;/** * Your Twitter object will be instantiated and called as such: * Twitter obj = new Twitter(); * obj.postTweet(userId,tweetId); * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId); * obj.follow(followerId,followeeId); * obj.unfollow(followerId,followeeId); */]]></content>
      <categories>
        <category>设计题</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1411-给N×3网格图涂色的方案数]]></title>
    <url>%2F2020%2F04%2F13%2FLeetCode1411-%E7%BB%99N%C3%973%E7%BD%91%E6%A0%BC%E5%9B%BE%E6%B6%82%E8%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述你有一个n x 3 的网格图 grid ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。 给你网格图的行数 n 。 请你返回给 grid 涂色的方案数。由于答案可能会非常大，请你返回答案对 10^9 + 7 取余的结果。 示例 1： 123输入：n = 1输出：12解释：总共有 12 种可行的方法： 示例 2： 12输入：n = 2输出：54 示例 3： 12输入：n = 3输出：246 示例 4： 12输入：n = 7输出：106494 示例 5： 12输入：n = 5000输出：30228214 提示： n == grid.length grid[i].length == 3 1 &lt;= n &lt;= 5000 解题思路我在周赛的时候没做出来，找不到思路，总觉得是初中的排列组合问题，这位写得很详细，我自己就不详细写了 1234567891011121314151617181920class Solution &#123; public int numOfWays(int n) &#123; long aba=6; long abc=6; if(n==1) &#123; aba=6; abc=6; &#125; for(int i=2; i&lt;=n; i++) &#123; long temp1=(aba*3+abc*2)%1000000007; long temp2=(aba*2+abc*2)%1000000007; aba=temp1; abc=temp2; //System.out.println(aba+" "+abc); &#125; return (int)((aba+abc)%1000000007); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode887-鸡蛋掉落]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD%2F</url>
    <content type="text"><![CDATA[题目描述你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。 你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。 你的目标是确切地知道 F 的值是多少。 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例 1： 1234567输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 示例 2： 12输入：K = 2, N = 6输出：3 示例 3： 12输入：K = 3, N = 14输出：4 提示： 1 &lt;= K &lt;= 100 1 &lt;= N &lt;= 10000 解题思路我是照着这篇文章写的，写得很仔细大佬的文章 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int superEggDrop(int K, int N) &#123; int dp[][]=new int[N+1][K+1]; for(int i=0; i&lt;=N; i++) Arrays.fill(dp[i],Integer.MAX_VALUE); dp[0][0]=0;//0层0个鸡蛋，测试0次 for(int i=1; i&lt;=N; i++)//1层到N层 &#123; dp[i][0]=0;//i层0个鸡蛋 dp[i][1]=i;//i层1个鸡蛋 &#125; for(int i=1; i&lt;=K; i++) &#123; dp[0][i]=0;//0层i个鸡蛋 dp[1][i]=1;//1层i个鸡蛋 &#125; //状态转移方程 for(int i=2; i&lt;=N; i++) &#123; for(int j=2; j&lt;=K; j++) &#123; int low=1; int high=i; while(low&lt;high) &#123; int mid=(high+low)/2; int breakcout=dp[mid-1][j-1]; int notbreakcout=dp[i-mid][j]; if(breakcout&gt;notbreakcout) high=mid-1; else if(breakcout&lt;notbreakcout) low=mid+1; else &#123; low=mid; break; &#125; &#125; dp[i][j]=Math.max(dp[low-1][j-1],dp[i-low][j])+1; &#125; &#125; return dp[N][K]; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode200-岛屿数量]]></title>
    <url>%2F2020%2F04%2F09%2FLeetCode200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目描述给定一个由 ‘1‘（陆地）和 ‘0‘（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 解题思路访问第一个陆地，根据广度遍历，把它相邻的陆地都标记为1，对应的计数cout为1，然后访问下一个陆地，且没有被访问过，继续根据BFS，把相邻的陆地标记为1，对应的计数cout为2，直到遍历完整个二维数组，对应的计数cout就是结果。 特别注意 每次入队的时候，要把对应位置的陆地标记为已访问，这样才不会超时，如果出队的时候再标记已访问，这样会超时。 放上大佬的详解解答链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class position&#123; int x; int y; public position(int i,int j) &#123; x=i; y=j; &#125;&#125;class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0||grid==null) return 0; int rows=grid.length; int cols=grid[0].length; int cout=0; int [] dx=&#123;-1,1,0,0&#125;; int [] dy=&#123;0,0,-1,1&#125;; boolean [][] flag=new boolean[rows][cols]; for(int i=0; i&lt;rows; i++) &#123; for(int j=0; j&lt;cols; j++) &#123; if(grid[i][j]=='1'&amp;&amp;flag[i][j]==false) &#123; cout++; //进行广度遍历 Queue&lt;position&gt; queue=new LinkedList&lt;&gt;(); queue.offer(new position(i,j)); //入队的时候标记已访问，不然会超时 flag[i][j]=true; while(!queue.isEmpty()) &#123; int len=queue.size(); for(int k=0; k&lt;len; k++) &#123; position temp=queue.poll(); //flag[temp.x][temp.y]=true;//标记已访问,这样会超时 for(int l=0; l&lt;4; l++) &#123; int tempx=temp.x+dx[l]; int tempy=temp.y+dy[l]; if(judge(tempx,tempy,grid)==true&amp;&amp;flag[tempx][tempy]==false) &#123; queue.offer(new position(tempx,tempy)); flag[tempx][tempy]=true; &#125; &#125; &#125; &#125; &#125; &#125; &#125; return cout; &#125; private boolean judge(int i,int j,char [][] grid)//判断是否在合法坐标，是否是陆地 &#123; int rows=grid.length; int cols=grid[0].length; boolean flag=false; if(i&gt;=0&amp;&amp;i&lt;rows&amp;&amp;j&gt;=0&amp;&amp;j&lt;cols&amp;&amp;grid[i][j]=='1') return true; return flag; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode133-克隆图]]></title>
    <url>%2F2020%2F04%2F09%2FLeetCode133-%E5%85%8B%E9%9A%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[题目描述给你无向 连通 **图中一个节点的引用，请你返回该图的 [深拷贝**](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 1234class Node &#123; public int val; public List&lt;Node&gt; neighbors;&#125; 测试用例格式： 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。 示例 1： 12345678输入：adjList = [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2： 123输入：adjList = [[]]输出：[[]]解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。 示例 3： 123输入：adjList = []输出：[]解释：这个图是空的，它不含任何节点。 示例 4： 12输入：adjList = [[2],[1]]输出：[[2],[1]] 提示： ​ 1.节点数不超过 100 。​ 2.每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。​ 3.无向图是一个简单图，这意味着图中没有重复的边，也没有自环。​ 4.由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。​ 5.图是连通图，你可以从给定节点访问到所有节点。 解题思路主要是理解题意，别人的思路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; neighbors; public Node() &#123; val = 0; neighbors = new ArrayList&lt;Node&gt;(); &#125; public Node(int _val) &#123; val = _val; neighbors = new ArrayList&lt;Node&gt;(); &#125; public Node(int _val, ArrayList&lt;Node&gt; _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;*/class Solution &#123; public Node cloneGraph(Node node) &#123; if(node==null) return null; Map&lt;Node,Node&gt; map=new HashMap&lt;&gt;(); Node clone=new Node(node.val,new ArrayList&lt;&gt;()); map.put(node,clone); Queue&lt;Node&gt; queue=new LinkedList&lt;&gt;(); queue.offer(node); while(!queue.isEmpty()) &#123; Node temp=queue.poll(); for(Node jj:temp.neighbors) &#123; if(!map.containsKey(jj)) &#123; map.put(jj,new Node(jj.val,new ArrayList&lt;&gt;())); queue.offer(jj); &#125; map.get(temp).neighbors.add(map.get(jj)); &#125; &#125; return clone; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode130-被围绕的区域]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二维的矩阵，包含 &#39;X&#39; 和 &#39;O&#39;（字母 O）。 找到所有被 &#39;X&#39; 围绕的区域，并将这些区域里所有的 &#39;O&#39; 用 &#39;X&#39; 填充。 示例: 1234X X X XX O O XX X O XX O X X 运行你的函数后，矩阵变为： 1234X X X XX X X XX X X XX O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 解题思路先通过BFS，将边界上的O变成#,然后再将O变成X,#变成O 大佬详细解答 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class position&#123; int i; int j; public position(int x,int y) &#123; i=x; j=y; &#125;&#125;class Solution &#123; public void solve(char[][] board) &#123; if(board.length==0||board==null) return; int rows=board.length; int cols=board[0].length; for(int i=0; i&lt;rows; i++) &#123; for(int j=0; j&lt;cols; j++) &#123; if((j==0||j==cols-1||i==0||i==rows-1)&amp;&amp;board[i][j]=='O') &#123; BFS(board,i,j); &#125; &#125; &#125; for(int i=0; i&lt;rows; i++) &#123; for(int j=0; j&lt;cols; j++) &#123; if(board[i][j]=='O') board[i][j]='X'; if(board[i][j]=='#') board[i][j]='O'; &#125; &#125; &#125; private void BFS(char[][] board,int i,int j) &#123; Queue&lt;position&gt; queue=new LinkedList&lt;&gt;(); position temp=new position(i,j); queue.offer(temp); board[i][j]='#'; while(!queue.isEmpty()) &#123; position temp1=queue.poll(); //上 if(temp1.i-1&gt;=0&amp;&amp;board[temp1.i-1][temp1.j]=='O') &#123; board[temp1.i-1][temp1.j]='#'; position t=new position(temp1.i-1,temp1.j); queue.offer(t); &#125; //下 if(temp1.i+1&lt;=board.length-1&amp;&amp;board[temp1.i+1][temp1.j]=='O') &#123; board[temp1.i+1][temp1.j]='#'; position t=new position(temp1.i+1,temp1.j); queue.offer(t); &#125; //左 if(temp1.j-1&gt;=0&amp;&amp;board[temp1.i][temp1.j-1]=='O') &#123; board[temp1.i][temp1.j-1]='#'; position t=new position(temp1.i,temp1.j-1); queue.offer(t); &#125; //右 if(temp1.j+1&lt;=board[0].length-1&amp;&amp;board[temp1.i][temp1.j+1]=='O') &#123; board[temp1.i][temp1.j+1]='#'; position t=new position(temp1.i,temp1.j+1); queue.offer(t); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode126-单词接龙II]]></title>
    <url>%2F2020%2F04%2F07%2FLeetCode126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99II%2F</url>
    <content type="text"><![CDATA[题目描述给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回一个空列表。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 12345678910输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出:[ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]] 示例 2: 12345678输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: []解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。 解题思路这道题好难啊，一开始不要做困难的题，终于做出来了，对BFS理解不是很深的时候，不要去做困难的题，不然会适得其反，这篇文章写得很详细。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Solution &#123; public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; List&lt;List&lt;String&gt;&gt; list=new ArrayList&lt;&gt;(); if(wordList.contains(endWord)==false) return list; BFS(beginWord,endWord,wordList,list); return list; &#125; private void BFS(String beginWord,String endWord,List&lt;String&gt;wordList,List&lt;List&lt;String&gt;&gt;list) &#123; Queue &lt;List&lt;String&gt;&gt; queue=new LinkedList&lt;&gt;(); List &lt;String&gt; path=new ArrayList&lt;&gt;(); path.add(beginWord); queue.offer(path); boolean flag=false; Set &lt;String&gt; visit=new HashSet&lt;&gt;(); visit.add(beginWord); Set &lt;String&gt; dict=new HashSet&lt;&gt;(wordList); while(!queue.isEmpty()) &#123; int len= queue.size(); Set&lt;String&gt; subvisit=new HashSet&lt;&gt;(); for(int i=0; i&lt;len; i++) &#123; List &lt;String&gt; tempPath=queue.poll();//出栈，即当前的路线 String temp=tempPath.get(tempPath.size()-1);//获取当前路径的末尾单词 //一次性得到下一次的节点 ArrayList &lt;String&gt; neighbors=getNeighbor(temp,dict); for(String neighbor:neighbors) &#123; if(!visit.contains(neighbor)) &#123; if(endWord.equals(neighbor)) &#123; flag=true; tempPath.add(endWord); list.add(new ArrayList&lt;String&gt;(tempPath)); tempPath.remove(tempPath.size()-1); subvisit.add(endWord); &#125; else &#123; tempPath.add(neighbor); //注意一下queue.offer(tempPath)会出错 queue.offer(new ArrayList&lt;String&gt;(tempPath)); //System.out.println(new ArrayList&lt;String&gt;(tempPath)); // System.out.println(tempPath); tempPath.remove(tempPath.size()-1); subvisit.add(neighbor); &#125; &#125; &#125; &#125; visit.addAll(subvisit); //System.out.println(queue); /*if(flag) break;*/ &#125; &#125; private ArrayList&lt;String&gt; getNeighbor(String temp,Set &lt;String&gt; dict) &#123; ArrayList &lt;String&gt; list=new ArrayList&lt;&gt;(); char [] chars=temp.toCharArray(); for(int i=0; i&lt;chars.length; i++) &#123; for(char s='a';s&lt;='z'; s++) &#123; if(s==chars[i]) continue; char oldchar=chars[i]; chars[i]=s; if(dict.contains(String.valueOf(chars))) &#123; list.add(String.valueOf(chars)); &#125; chars[i]=oldchar; &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode111-二叉树的最小深度]]></title>
    <url>%2F2020%2F04%2F07%2FLeetCode111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回它的最小深度 2. 解题思路这里是返回根节点到最近叶子结点的最短路径上的节点数量，和以前理解的最小深度是不同的。例如[1,2]的最小深度是2，而不是1，因为根节点不是叶节点。 这道题的递归结束条件是： 如果root节点是空姐点，返回0 root节点的左右子树为空，返回1 root节点的左右子树有一个为空，返回不为空子树深度加1 root节点的左右子树都不为空，返回左右子树中深度较小的深度加1（加一是根节点） 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; if(root==null)//如果根节点是空节点，那么深度为0 return 0; if(root.left==null&amp;&amp;root.right==null)//根节点的左右节点都为空，深度为1 return 1; int m1=minDepth(root.left);//计算左子树的深度 int m2=minDepth(root.right);//计算右子树的深度 if(root.left==null||root.right==null)//左右子树中有一个是空子树，返回不空子树深度加1 return m1+m2+1; //左右子树都不为空的情况 return Math.min(m1,m2)+1; &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode107-二叉树的层序遍历II]]></title>
    <url>%2F2020%2F04%2F07%2FLeetCode107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II%2F</url>
    <content type="text"><![CDATA[题目描绘给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 解题思路每次把一维数组加到二维数组的开始位置即可，sublist，list.add(0,sublist). 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; list=new ArrayList&lt;&gt;(); Queue &lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); if(root==null) return list; queue.offer(root); while(!queue.isEmpty()) &#123; List &lt;Integer&gt; sublist=new ArrayList&lt;&gt;(); int len=queue.size(); for(int i=0; i&lt;len; i++) &#123; TreeNode temp=queue.poll(); if(temp.left!=null) queue.offer(temp.left); if(temp.right!=null) queue.offer(temp.right); sublist.add(temp.val); &#125; list.add(0,sublist); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode102-二叉树的层序遍历]]></title>
    <url>%2F2020%2F04%2F07%2FLeetCode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目描述给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,null,null,15,7], 123453 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 解题思路BFS还是不是很熟悉，我知道用层序遍历，但是不知道怎么把一层的树放到一位数组中，orz，真的菜！！，判断队列中的长度就可以了。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; list=new ArrayList&lt;&gt;(); Queue &lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); if(root==null) return list; queue.offer(root); while(!queue.isEmpty()) &#123; List &lt;Integer&gt; sublist=new ArrayList&lt;&gt;(); int len=queue.size(); for(int i=0; i&lt;len; i++) &#123; TreeNode temp=queue.poll(); if(temp.left!=null) queue.offer(temp.left); if(temp.right!=null) queue.offer(temp.right); sublist.add(temp.val); &#125; list.add(sublist); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode面试题01.07-旋转矩阵]]></title>
    <url>%2F2020%2F04%2F07%2FLeetCode%E9%9D%A2%E8%AF%95%E9%A2%9801-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目描述给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？ 示例 1: 12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2: 123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 解题思路通过矩阵变化，矩阵的顺时针旋转90度matrix[i][j]-&gt;matrix[j][n-1-i],matrix[j][n-1-i]-&gt;matrix[n-1-i][n-1-j],matrix[n-1-i][n-1-j]-&gt;matrix[n-1-j][i],matrix[n-1-j][i]-&gt;matrix[i][j].只要旋转矩阵的左上部分即可，旋转的最大行坐标为n/2-1,旋转的最大列坐标为（n-1）/2. 大佬的解题思路 12345678910111213141516class Solution &#123; public void rotate(int[][] matrix) &#123; int n=matrix.length; for(int i=0; i&lt;=(n)/2-1; i++) &#123; for(int j=0; j&lt;=(n-1)/2; j++) &#123; int temp=matrix[n-1-j][i]; matrix[n-1-j][i]=matrix[n-1-i][n-1-j]; matrix[n-1-i][n-1-j]=matrix[j][n-1-i]; matrix[j][n-1-i]=matrix[i][j]; matrix[i][j]=temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>矩阵</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode72-编辑距离]]></title>
    <url>%2F2020%2F04%2F06%2FLeetCode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目描述给你两个单词 word1 和 word2*，请你计算出将 *word1 转换成 *word2 *所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 123456输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)rorse -&gt; rose (删除 &apos;r&apos;)rose -&gt; ros (删除 &apos;e&apos;) 示例 2： 12345678输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &apos;t&apos;)inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)exection -&gt; execution (插入 &apos;u&apos;) 解题思路这位大佬的解题思路写得很清晰 利用dp解决，dp[i][j]表示word1的第i个字符到word2的第j个字符所用的步骤，如果word1[i]==word2[j]，那么dp[i][j]=dp[i-1][j-1]，如果不相等，那么dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]表示替换，dp[i-1][j]表示删除，dp[i][j-1]表示插入 123456789101112131415161718192021222324class Solution &#123; public int minDistance(String word1, String word2) &#123; int [][]dp=new int[word1.length()+1][word2.length()+1]; for(int i=1; i&lt;=word1.length(); i++)//第一列 &#123; dp[i][0]=dp[i-1][0]+1; &#125; for(int j=1; j&lt;=word2.length(); j++)//第一行 dp[0][j]=dp[0][j-1]+1; for(int i=1; i&lt;=word1.length(); i++) &#123; for(int j=1; j&lt;=word2.length(); j++) &#123; if(word1.charAt(i-1)==word2.charAt(j-1)) dp[i][j]=dp[i-1][j-1]; else &#123; dp[i][j]=Math.min(Math.min(dp[i-1][j-1],dp[i][j-1]),dp[i-1][j])+1; &#125; &#125; &#125; return dp[word1.length()][word2.length()]; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1405-最长快乐字符串]]></title>
    <url>%2F2020%2F04%2F06%2FLeetCode1405-%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述如果字符串中不含有任何 &#39;aaa&#39;，&#39;bbb&#39; 或 &#39;ccc&#39; 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。 给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s： s 是一个尽可能长的快乐字符串。 s 中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。 s 中只含有 ‘a’、’b’ 、’c’ 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串 &quot;&quot;。 示例 1： 123输入：a = 1, b = 1, c = 7输出：&quot;ccaccbcc&quot;解释：&quot;ccbccacc&quot; 也是一种正确答案。 示例 2： 12输入：a = 2, b = 2, c = 1输出：&quot;aabbc&quot; 示例 3： 123输入：a = 7, b = 1, c = 0输出：&quot;aabaa&quot;解释：这是该测试用例的唯一正确答案。 提示： 0 &lt;= a, b, c &lt;= 100 a + b + c &gt; 0 解题思路感谢大佬的思路 优先队列默认是小顶堆，把它改成大顶堆，每次从大顶堆取两个元素，如果第一个元素出现的次数大于等于2，就取两次它，否则取一次，如果第二个出现的次数大于等于2，并且大于等于第一个元素，就取两次，否则取一次。直到大顶堆只剩一个元素，如果这个元素和字符串末尾的字符不同，并且它的次数大于等于2，就取两次，否则取一次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class temp &#123; int cout; char chars; public temp(int a,char s) &#123; cout=a; chars=s; &#125;&#125;class Solution &#123; public String longestDiverseString(int a, int b, int c) &#123; StringBuilder sb=new StringBuilder(); PriorityQueue&lt;temp&gt; queue=new PriorityQueue&lt;temp&gt;(new Comparator&lt;temp&gt;()&#123; public int compare(temp t1,temp t2)//优先队列默认是小顶堆，现改成大顶堆 &#123; return t2.cout-t1.cout; &#125; &#125;); if(a&gt;0) queue.offer(new temp(a,'a')); if(b&gt;0) queue.offer(new temp(b,'b')); if(c&gt;0) queue.offer(new temp(c,'c')); while(queue.size()&gt;1) &#123; temp t1=queue.poll(); if(t1.cout&gt;=2) &#123; sb.append(t1.chars+""+t1.chars); t1.cout-=2; &#125; else &#123; sb.append(t1.chars); t1.cout--; &#125; temp t2=queue.poll(); if(t2.cout&gt;=2&amp;&amp;t2.cout&gt;=t1.cout) &#123; sb.append(t2.chars+""+t2.chars); t2.cout-=2; &#125; else &#123; sb.append(t2.chars); t2.cout--; &#125; if(t1.cout&gt;0) queue.offer(t1); if(t2.cout&gt;0) queue.offer(t2); &#125; if(!queue.isEmpty()) &#123; temp t=queue.poll(); if(sb.length()==0||t.chars!=sb.charAt(sb.length()-1)) &#123; if(t.cout&gt;=2) &#123; sb.append(t.chars+""+t.chars); &#125; else sb.append(t.chars); &#125; &#125; return new String(sb); &#125;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>优先队列</tag>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5379-石子游戏III]]></title>
    <url>%2F2020%2F04%2F05%2FLeetCode5379-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FIII%2F</url>
    <content type="text"><![CDATA[题目描述Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。 Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。 每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。 假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 “Alice” ，Bob 赢了就返回 “Bob”，平局（分数相同）返回 “Tie” 。 示例 1： 123输入：values = [1,2,3,7]输出：&quot;Bob&quot;解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。 示例 2： 123456输入：values = [1,2,3,-9]输出：&quot;Alice&quot;解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。 示例 3： 123输入：values = [1,2,3,6]输出：&quot;Tie&quot;解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。 示例 4： 12输入：values = [1,2,3,-1,-2,-3,7]输出：&quot;Alice&quot; 示例 5： 12输入：values = [-1,-2,-3]输出：&quot;Tie&quot; 提示： 1 &lt;= values.length &lt;= 50000 -1000 &lt;= values[i] &lt;= 1000 解题思路感谢大佬的思路 dp[i]：标识在只剩第i堆石子到最后一堆石子时，当前玩家最多能拿多少分，当遍历完后，判断dp[0]和分数的总和-dp[0]的大小即可。 倒着计算这个数组。首先计算边界情况：dp[n-1]=stoneValue[n-1]，只剩最后一堆时只能拿走。 其他的i，你的选择有拿一堆，拿两堆，拿三堆，给对方留下了dp[i+1],dp[i+2],dp[i+3]的情况，我们能得到的分数就是剩下的所有分数减去对方能拿到的分数，为了让自己得到最高分，必须得让对方得到最少分。 dp[i]=sum{i,n}-min(dp[i+1,dp[i+2],dp[i+3]),分别对应取走一堆，两堆，三堆的情况，即dp[i]=max(sum-dp[i+1],sum-dp[i+2],sum-dp[i+3]),通过递推公式，我们就能算出dp[0]. 123456789101112131415161718192021class Solution &#123; public String stoneGameIII(int[] stoneValue) &#123; int [] dp= new int[50003]; int sum=0; for(int i=stoneValue.length-1; i&gt;=0; i--) &#123; sum+=stoneValue[i]; dp[i]=Integer.MIN_VALUE; for(int j=1; j&lt;=3; j++) &#123; dp[i]=Math.max(dp[i],sum-dp[i+j]); &#125; &#125; //System.out.println(dp[0]+" "+sum); if(dp[0]==sum-dp[0]) return "Tie"; if(dp[0]&gt;sum-dp[0]) return "Alice"; return "Bob"; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode209-长度最小的子数组]]></title>
    <url>%2F2020%2F04%2F04%2FLeetCode209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一个含有 n *个正整数的数组和一个正整数 *s ，找出该数组中满足其和** ≥ s 的长度最小的连续子数组。**如果不存在符合条件的连续子数组，返回 0。 示例: 123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 解题思路用双指针 left 和 right 表示一个窗口。 1.right 向右移增大窗口，直到窗口内的数字和大于等于了 s。进行第 2 步。 2.记录此时的长度，left 向右移动，开始减少长度，每减少一次，就更新最小长度。直到当前窗口内的数字和小于了 s，回到第 1 步。 1234567891011121314151617class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; int min_len=Integer.MAX_VALUE; int sum=0; int j=0; for(int i=0; i&lt;nums.length; i++) &#123; sum+=nums[i]; while(sum&gt;=s) &#123; min_len=Math.min(min_len,i-j+1);//记录对应的最小长度 sum-=nums[j++]; &#125; &#125; return min_len==Integer.MAX_VALUE?0:min_len; &#125;&#125;]]></content>
      <categories>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
        <tag>连续子数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode162-寻找峰值]]></title>
    <url>%2F2020%2F04%2F04%2FLeetCode162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1: 123输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2: 1234输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN)时间复杂度的。 解题思路判断nums[mid]和nums[mid+1]的关系，如果是小于，峰值在mid的右边，如果是大于，则峰值在mid的左边，通过二分查找，最后查找的就是我们需要的峰值。 123456789101112131415class Solution &#123; public int findPeakElement(int[] nums) &#123; int low=0; int high=nums.length-1; while(low&lt;high) &#123; int mid=low+(high-low)/2; if(nums[mid]&gt;=nums[mid+1])//峰在左边 high=mid; else low=mid+1; &#125; return low; &#125;&#125;]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode50-求x的n次幂]]></title>
    <url>%2F2020%2F04%2F04%2FLeetCode50-%E6%B1%82x%E7%9A%84n%E6%AC%A1%E5%B9%82%2F</url>
    <content type="text"><![CDATA[题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。 解题思路本来这道题是在二分查找里的，我看到题后就懵逼了，这和二分查找每什么关系，原来用二分递归。 12345678910111213class Solution &#123; public double myPow(double x, int n) &#123; if(n==0) return 1; if(n==1) return x; if(n==-1) return (double)(1/x); double half= myPow(x,n/2); double ans=myPow(x,n%2); return half*half*ans; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-744寻找比目标字母大的最小字母]]></title>
    <url>%2F2020%2F04%2F04%2FLeetCode-744%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[题目描述给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。 在比较时，数组里字母的是循环有序的。举个例子： 如果目标字母 target = &#39;z&#39; 并且有序数组为 letters = [&#39;a&#39;, &#39;b&#39;]，则答案返回 &#39;a&#39;。 如果目标字母 target = &#39;n&#39; 并且有序数组为 letters = [&#39;m&#39;, &#39;z&#39;, &#39;c&#39;, &#39;f&#39;, &#39;j&#39;] ，则答案返回 &#39;z&#39; 。 示例： 1234567891011121314151617181920212223242526272829输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;a&quot;输出: &quot;c&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;c&quot;输出: &quot;f&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;d&quot;输出: &quot;f&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;g&quot;输出: &quot;j&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;j&quot;输出: &quot;c&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;k&quot;输出: &quot;c&quot; 提示： ​ 1.letters长度范围在[2, 10000]区间内。​ 2.letters 仅由小写字母组成，最少包含两个不同的字母。​ 3.目标字母target 是一个小写字母。 解题思路如果第一个字符大于目标字符，或者最后一个字符小于目标字符，则返回第一个字符。 用二分查找，low=0，high=len-1,mid=low+high/2,如果letters[mid]&lt;=target,则在字符串的右边，如果letters[mid]&gt;target,则分为两种情况，如果letters[mid-1]&lt;=target,返回letters[mid]，如果letters[mid-1]&gt;target,则在字符串的左边。 1234567891011121314151617181920212223242526class Solution &#123; public char nextGreatestLetter(char[] letters, char target) &#123; //如果第一个字符大于目标字符，或者最后一个字符小于目标字符，则返回第一个字符 if(letters[0]&gt;target||letters[letters.length-1]&lt;=target) return letters[0]; int len=letters.length; int low=0; int high=len-1; while(low&lt;=high) &#123; int mid=low+(high-low)/2; if(letters[mid]&lt;=target)//mid的字符小于等于目标字符,则在右边 &#123; low=mid+1; &#125; else//mid的字符大于目标字符，分两种情况 &#123; if(letters[mid-1]&lt;=target) return letters[mid]; else//否则在左边 high=mid-1; &#125; &#125; return ' '; &#125;&#125;]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-42接雨水]]></title>
    <url>%2F2020%2F04%2F04%2FLeetCode-42%E6%8E%A5%E9%9B%A8%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[题目描述给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 解题思路直接暴力解决，从第二位置开始遍历，从该点的左边找最大值，max_left,从该点的右边找最大值，max_right,两边的最小值减去该点的高度，就是该处能盛的雨水，Math.min(max_left,max_right)-height[i],遍历到倒数第二个结点，即为所求。 123456789101112131415161718192021class Solution &#123; public int trap(int[] height) &#123; int len=height.length; int res=0; for(int i=1; i&lt;len-1; i++) &#123; int max_left=0; int max_right=0; for(int j=i;j&gt;=0; j--)//从该坐标起，找左边的最大高度 &#123; max_left=Math.max(height[j],max_left); &#125; for(int k=i; k&lt;len; k++)//从该坐标起，找右边的最大高度 &#123; max_right=Math.max(height[k],max_right); &#125; res=res+(Math.min(max_right,max_left)-height[i]); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记]]></title>
    <url>%2F2020%2F04%2F03%2FSpringMVC%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.SpringMVC的基础知识1.1MVC设计模型M:Model模型 JavaBean V:View视图 JSP C:Controller控制器 Servlet（核心控制器） 1.2 SpringMVC是什么SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode29-两数相除]]></title>
    <url>%2F2020%2F04%2F03%2FLeetCode29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%2F</url>
    <content type="text"><![CDATA[题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8以及 truncate(-2.7335) = -2 123输入: dividend = 10, divisor = 3输出: 3解释: 10/3 = truncate(3.33333..) = truncate(3) = 3 示例 2: 123输入: dividend = 7, divisor = -3输出: -2解释: 7/-3 = truncate(-2.33333..) = -2 提示： 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。 解题思路例如10除3，首先判断10&gt;3,cout=1,3&lt;10,让3翻倍，6，然后cout=2，6还是小于10，让6翻倍12，cout=4，12大于10,说明10÷3的结果在2和4之间，到底是多少呢？让11-6=5，继续进行上面的判断，把对应的cout加起来。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int divide(int dividend, int divisor) &#123; //首先判断溢出 if(dividend==Integer.MIN_VALUE&amp;&amp;divisor==-1) return Integer.MAX_VALUE; //去掉一个特殊的情况 if(dividend==0) return 0; if(divisor==1) return dividend; if(divisor==-1) return -dividend; //把所有的数转化成负数，这样做防止溢出，并用相应标记标识 int flag=0; if((dividend&gt;0&amp;&amp;divisor&lt;0)||(dividend&lt;0&amp;&amp;divisor&gt;0)) flag=-1; int a=dividend&gt;0?-dividend:dividend; int b=divisor&gt;0?-divisor:divisor; int res=helpdivide(a,b); return flag&lt;0?-res:res; &#125; private int helpdivide(int a,int b) &#123; if(a&gt;b)//如果不够除，直接返回0 return 0; int cout=1; int tb=b; while(a&lt;=tb+tb&amp;&amp;tb+tb&lt;0)//下次循环符合条件,保证tb+tb不会溢出 &#123; tb+=tb; cout+=cout; &#125; // System.out.println(tb+" "+cout); return cout+helpdivide(a-tb,b); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode475-供暖器]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode475-%E4%BE%9B%E6%9A%96%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。 所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。 说明: 1.给出的房屋和供暖器的数目是非负数且不会超过 25000。2.给出的房屋和供暖器的位置均是非负数且不会超过10^9。3.只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。4.所有供暖器都遵循你的半径标准，加热的半径也一样。 示例 1: 123输入: [1,2,3],[2]输出: 1解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。 示例 2: 123输入: [1,2,3,4],[1,4]输出: 1解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。 解题思路先对房子的位置和供暖器的位置进行排序，然后对求得每个房子和最近供暖器的距离，最大的每个房子和最近供暖器的距离就是最小的加热半径。 12345678910111213141516171819import java.util.*;class Solution &#123; public int findRadius(int[] houses, int[] heaters) &#123; Arrays.sort(houses); Arrays.sort(heaters); int radius=-1; int j=0; for(int i=0; i&lt;houses.length; i++) &#123; while(j+1&lt;heaters.length&amp;&amp;(Math.abs(houses[i]-heaters[j])&gt;=Math.abs(houses[i]-heaters[j+1])))//如果这个房子到这个加热器的距离大于等于到下一个加热器的距离 &#123; j++; &#125; //更新最大半径 radius=Math.max(radius,Math.abs(houses[i]-heaters[j])); &#125; return radius; &#125;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1111-有效括号的嵌套深度]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode1111-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 解题思路利用栈的思想，大佬这篇文章写得很详细 1234567891011121314151617181920212223class Solution &#123; public int[] maxDepthAfterSplit(String seq) &#123; //利用栈的思想 char [] chars=seq.toCharArray(); int len=chars.length; int [] res =new int [len]; int depth=0; for(int i=0; i&lt;len; i++) &#123; if(chars[i]=='(') &#123; depth++; res[i]=depth%2; &#125; else &#123; res[i]=depth%2; depth--; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>栈</category>
      </categories>
      <tags>
        <tag>括号匹配</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode349-两个数组的交集]]></title>
    <url>%2F2020%2F04%2F01%2FLeetCode349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2: 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 解题思路主要是我在做题的过程中，不会遍历HashSet中的数，导致没有做出来，遍历一个数组，每遍历一个数，用二分查找从第二个数组中查找对应的数，找到了，就把这个数加到Set中。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public int[] intersection(int[] nums1, int[] nums2) &#123; Set &lt;Integer&gt; set =new HashSet&lt;&gt;(); Arrays.sort(nums2); for(int target: nums1) &#123; if(!set.contains(target)&amp;&amp;binaryseach(target,nums2)) set.add(target); &#125; int [] a=new int[set.size()]; int i=0; for(int num: set) a[i++]=num; return a; &#125; private boolean binaryseach(int target,int [] nums2) &#123; int low=0; int high=nums2.length-1; while(low&lt;=high) &#123; int mid=low+(high-low)/2; if(nums2[mid]==target) return true; else if(target&gt;nums2[mid]) low=mid+1; else high=mid-1; &#125; return false; &#125;&#125; 注意点123Set &lt;Integer&gt; set= new HashSet&lt;&gt;();//是一个HashSet我想遍历这个setfor(int num:set)//则可以遍历这个set]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode278-第一个错误的版本]]></title>
    <url>%2F2020%2F04%2F01%2FLeetCode278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 1234567给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 解题思路这道利用二分查找，从[1,2,…,n]中找到第一个isBadVersion(i)是true的数，low=1，high=n，mid=(low+high)/2,如果isBadVersion(mid)==true, 那么正确的下标在mid的左边,令high=mid. 如果isBadVersion(mid)==false,那么正确的下标在mid的右边，令low=mid+1，循环结束后，low=high。返回low即可 12345678910111213141516171819/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int low=1; int high=n; while(low&lt;high) &#123; //int mid=(low+high)&gt;&gt;1;//这样写可能超过int的上限了 int mid=low+(high-low)/2; if(isBadVersion(mid))//在mid的左边 high=mid; else low=mid+1; &#125; return high; &#125;&#125;]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode912-排序数组]]></title>
    <url>%2F2020%2F03%2F31%2FLeetCode912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给你一个整数数组 nums，请你将该数组升序排列。 示例 1： 12输入：nums = [5,2,3,1]输出：[1,2,3,5] 示例 2： 12输入：nums = [5,1,1,2,0,0]输出：[0,0,1,1,2,5] 提示： 1 &lt;= nums.length &lt;= 50000 -50000 &lt;= nums[i] &lt;= 50000 解题思路作为一个万年冒泡排序的人，这道题一开始也是用的冒泡排序，然后就想当然的超时了，然后只能归并排序，这道题就是复习归并排序了。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int[] sortArray(int[] nums) &#123; int len=nums.length; mergesort(nums,0,len-1); return nums; &#125; private void mergesort(int [] nums,int start,int end) &#123; int mid=(start+end)/2; if(start&lt;end) &#123; mergesort(nums,start,mid); mergesort(nums,mid+1,end); merge(nums,start,mid,end); &#125; return ; &#125; private void merge(int [] nums,int start,int mid,int end) &#123; int [] temp=new int [end-start+1]; int i=start; int j=mid+1; int k=0; //把较小的数放到新数组中 while(i&lt;=mid&amp;&amp;j&lt;=end) &#123; if(nums[i]&lt;nums[j]) temp[k++]=nums[i++]; else temp[k++]=nums[j++]; &#125; //把左边的数放到新数组中 while(i&lt;=mid) temp[k++]=nums[i++]; //把右边的数放到新数组中 while(j&lt;=end) temp[k++]=nums[j++]; //把新数组覆盖原数组 for(int l=0; l&lt;k; l++) nums[start+l]=temp[l]; &#125;&#125;]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1162-地图分析]]></title>
    <url>%2F2020%2F03%2F29%2FLeetCode1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目描述你现在手里有一份大小为 N x N 的『地图』（网格）grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。 我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。 如果我们的地图上只有陆地或者海洋，请返回 -1。 示例 1： 1234输入：[[1,0,1],[0,0,0],[1,0,1]]输出：2解释： 海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。 示例 2： 1234输入：[[1,0,0],[0,0,0],[0,0,0]]输出：4解释： 海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。 提示： 1 &lt;= grid.length == grid[0].length &lt;= 100 grid[i][j] 不是 0 就是 1 解题思路把所有陆地入队，利用BFS遍历，广度遍历结束后，最后一个入队的，就是陆地最远的距离。感谢大佬的思路 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int maxDistance(int[][] grid) &#123; int rows=grid.length; int cols=grid[0].length; int [] dx=&#123;-1,1,0,0&#125;; int [] dy=&#123;0,0,-1,1&#125;; Queue &lt;int []&gt; queue=new LinkedList&lt;&gt;(); int [] point=null;//用来记录是否有陆地 for(int i=0; i&lt;rows; i++) &#123; for(int j=0; j&lt;cols; j++) &#123; if(grid[i][j]==1)//所有的陆地都入队 &#123; queue.offer(new int []&#123;i,j&#125;); &#125; &#125; &#125; boolean hasocean=false; while(!queue.isEmpty()) &#123; point=queue.poll(); for(int i=0; i&lt;4; i++) &#123; int tempx=point[0]+dx[i]; int tempy=point[1]+dy[i]; if(tempx&lt;0||tempx&gt;=rows||tempy&lt;0||tempy&gt;=cols||grid[tempx][tempy]!=0) continue; hasocean=true; grid[tempx][tempy]=grid[point[0]][point[1]]+1; queue.offer(new int []&#123;tempx,tempy&#125;); &#125; &#125; if(point==null||hasocean==false) return -1; return grid[point[0]][point[1]]-1; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5370-设计地铁系统]]></title>
    <url>%2F2020%2F03%2F29%2FLeetCode5370-%E8%AE%BE%E8%AE%A1%E5%9C%B0%E9%93%81%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[题目描述请你实现一个类 UndergroundSystem，它支持以下 3 种方法： checkIn(int id, string stationName, int t) 编号为 id 的乘客在 t 时刻进入地铁站 stationName 。 一个乘客在同一时间只能在一个地铁站进入或者离开 2.checkOut(int id, string stationName, int t) 编号为 id 的乘客在 t 时刻离开地铁站 stationName 。 3.getAverageTime(string startStation, string endStation) 返回从地铁站 startStation 到地铁站 endStation 的平均花费时间。 平均时间计算的行程包括当前为止所有从 startStation 直接到达 endStation 的行程。 调用 getAverageTime 时，询问的路线至少包含一趟行程。 你可以假设所有对 checkIn 和 checkOut 的调用都是符合逻辑的。也就是说，如果一个顾客在 t1 时刻到达某个地铁站，那么他离开的时间 t2 一定满足 t2 &gt; t1 。所有的事件都按时间顺序给出。 解题思路利用HashMap，Pair解题 123456789101112131415161718192021222324252627282930313233343536373839404142434445class UndergroundSystem &#123; // 通过id找到对应的进站的车站，进站的时间 Map&lt;Integer,Pair&lt;String,Integer&gt;&gt; map=new HashMap&lt;&gt;(); // 通过进站出站车站找到对应的平均时间 Map&lt;String,Pair&lt;Integer,Float&gt;&gt; time=new HashMap&lt;&gt;(); public UndergroundSystem() &#123; &#125; public void checkIn(int id, String stationName, int t) &#123; map.put(id,new Pair&lt;&gt;(stationName,t)); &#125; public void checkOut(int id, String stationName, int t) &#123; //通过id获得进站的名称和进站的时间 Pair &lt;String,Integer&gt; stationin=map.get(id); //进站和出站的名称 String kk=stationin.getKey()+stationName; //通过进站和出站得到他对应乘坐的时间，如果是第一个信息，则乘坐的时长为0，乘坐的次数为0 Pair&lt;Integer,Float&gt; pair=time.getOrDefault(kk,new Pair&lt;&gt;(0,0.0f)); // 计算出最新的乘坐总时长 Integer sumtime=t-stationin.getValue()+pair.getKey(); // 计算最新的乘坐次数 Float v=pair.getValue()+1.0f; // 把最新的信息添加到对应time中HashMap中， time.put(kk,new Pair&lt;&gt;(sumtime,v)); // 把进站信息的HashMap删除 map.remove(id); &#125; public double getAverageTime(String startStation, String endStation) &#123; String k=startStation+endStation; // 通过键值对，是通过get函数，通过k键获得对应的值 Pair&lt;Integer,Float&gt; pair=time.get(k); return pair.getKey()/pair.getValue(); &#125;&#125;/** * Your UndergroundSystem object will be instantiated and called as such: * UndergroundSystem obj = new UndergroundSystem(); * obj.checkIn(id,stationName,t); * obj.checkOut(id,stationName,t); * double param_3 = obj.getAverageTime(startStation,endStation); */]]></content>
      <categories>
        <category>设计题</category>
      </categories>
      <tags>
        <tag>LeetCode周赛</tag>
        <tag>HashMap</tag>
        <tag>设计题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1217-玩筹码]]></title>
    <url>%2F2020%2F03%2F27%2FLeetCode1217-%E7%8E%A9%E7%AD%B9%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目描述数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。 你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）： 将第 i 个筹码向左或者右移动 2 个单位，代价为 0。 将第 i 个筹码向左或者右移动 1 个单位，代价为 1。 最开始的时候，同一位置上也可能放着两个或者更多的筹码。 返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。 示例 1： 123输入：chips = [1,2,3]输出：1解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。 示例 2： 123输入：chips = [2,2,2,3,3]输出：2解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。 提示： 1 &lt;= chips.length &lt;= 100 1 &lt;= chips[i] &lt;= 10^9 解题思路这道题目主要是理解题意，例子一：有三个位置上有筹码，位置1，位置2，位置3，只要位置1移动到位置3，不需要代价，位置2移动到位置3，需要代价1，所以总的代价为1。 例子二：有两个位置上有筹码，位置2和位置3，位置2上面有3个筹码，位置3上面有2个筹码，要么从位置2移动到位置3，代价为3，要么从位置3移动到位置2，代价为2，所以最小的代价为2。 这道题，有两种选择，从奇数位置移动到偶数位置，算出代价，从偶数位置移动到奇数位置，算出代价，选择较小的代价。 1234567891011121314151617class Solution &#123; public int minCostToMoveChips(int[] chips) &#123; int len=chips.length; int resji=0; int resou=0; for(int i=0; i&lt;len; i++) &#123; if(chips[i]%2==0)//移动到奇数位置上需要的代价 resji++; else//移动到位置为偶数上需要的代价 resou++; &#125; if(resji&gt;resou) return resou; return resji; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1175-质数排列]]></title>
    <url>%2F2020%2F03%2F27%2FLeetCode1175-%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。 让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。 由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。 示例 1： 123输入：n = 5输出：12解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。 示例 2： 12输入：n = 100输出：682289015 提示： 1 &lt;= n &lt;= 100 解题思路我被这道题吓到了，很简单的题目，先找出1到n中质数的个数k，然后找出非质数为n-k,那么总的排列的种数为k!×(n-k)!. 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int numPrimeArrangements(int n) &#123; int cout=0; int bignumber=1000000007; for(int i=1; i&lt;=n; i++) &#123; if(judge(i)==true) cout++; &#125; double res=1; for(int i=2; i&lt;=cout; i++) &#123; res=(res*i)%bignumber; &#125; for(int i=2; i&lt;=n-cout; i++) res=(res*i)%bignumber; return (int)(res%bignumber); &#125; private boolean judge(int n) &#123; if(n&lt;2) return false; else if(n==2) return true; else&#123; for(int i=2; i&lt;=Math.sqrt(n*1.0); i++) &#123; if(n%i==0) return false; &#125; return true; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode970-强整数]]></title>
    <url>%2F2020%2F03%2F27%2FLeetCode970-%E5%BC%BA%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定两个正整数 x 和y，如果某一整数等于 x^i + y^j，其中整数 i &gt;= 0 且j &gt;= 0，那么我们认为该整数是一个强整数。 返回值小于或等于 bound 的所有强整数组成的列表。 你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。 示例 1： 12345678910输入：x = 2, y = 3, bound = 10输出：[2,3,4,5,7,9,10]解释： 2 = 2^0 + 3^03 = 2^1 + 3^04 = 2^0 + 3^15 = 2^1 + 3^17 = 2^2 + 3^19 = 2^3 + 3^010 = 2^0 + 3^2 示例 2： 12输入：x = 3, y = 5, bound = 15输出：[2,4,6,8,10,14] 提示： 1 &lt;= x &lt;= 100 1 &lt;= y &lt;= 100 0 &lt;= bound &lt;= 10^6 解题思路利用的对数和指数函数求这道题，Math.log函数的底数是e，可以用换底公式来求。 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) &#123; int maxi= x==1?0:(int)(Math.log(bound-1)/Math.log(x)); int maxj= y==1?0:(int)(Math.log(bound-1)/Math.log(y)); Set &lt;Integer&gt; set =new HashSet&lt;&gt;(); for(int i=0; i&lt;=maxi; i++) &#123; for(int j=0; j&lt;=maxj; j++) &#123; if(Math.pow(x,i)+Math.pow(y,j)&lt;=bound) &#123; set.add((int)(Math.pow(x,i)+Math.pow(y,j))); &#125; &#125; &#125; return new ArrayList&lt;&gt;(set); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>对数</tag>
        <tag>指数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1037-有效的回旋镖]]></title>
    <url>%2F2020%2F03%2F26%2FLeetCode1037-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96%2F</url>
    <content type="text"><![CDATA[题目描述回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。 给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。 示例 1： 12输入：[[1,1],[2,3],[3,2]]输出：true 示例 2： 12输入：[[1,1],[2,2],[3,3]]输出：false 提示： points.length == 3 points[i].length == 2 0 &lt;= points[i][j] &lt;= 100 解题思路我本来是想三点共线，那么他们的斜率相等，但是分母为零，就不好弄了，除法不行那就化成乘法。 123456789class Solution &#123; public boolean isBoomerang(int[][] points) &#123; int dy=points[1][1]-points[0][1]; int dx=points[1][0]-points[0][0]; int ey=points[2][1]-points[0][1]; int ex=points[2][0]-points[0][0]; return dy*ex!=dx*ey; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode949-给定数字能组成的最大时间]]></title>
    <url>%2F2020%2F03%2F26%2FLeetCode949-%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%E8%83%BD%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目描述给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。 最小的 24 小时制时间是 00:00，而最大的是 23:59。从 00:00 （午夜）开始算起，过得越久，时间越大。 以长度为 5 的字符串返回答案。如果不能确定有效时间，则返回空字符串。 示例 1： 12输入：[1,2,3,4]输出：&quot;23:41&quot; 示例 2： 12输入：[5,5,5,5]输出：&quot;&quot; 提示： A.length == 4 0 &lt;= A[i] &lt;= 9 解题思路四个数字的全排列，找出符合的时间就可以了。 1234567891011121314151617181920212223242526class Solution &#123; public String largestTimeFromDigits(int[] A) &#123; int res=-1; for(int i=0; i&lt;4; i++) &#123; for(int j=0; j&lt;4; j++) &#123; if(i!=j) &#123; for(int k=0; k&lt;4; k++) &#123; if(k!=i&amp;&amp;k!=j) &#123; int l=6-i-j-k; int hour=(A[i]*10+A[j]); int minute=A[k]*10+A[l]; if(hour&lt;24&amp;&amp;minute&lt;60) res=Math.max(res,hour*60+minute); &#125; &#125; &#125; &#125; &#125; return res&gt;=0?String.format("%02d:%02d",res/60,res%60):""; &#125;&#125; 新的知识点String.format(&quot;%02:%02d&quot;,num1,num2);//这和C语言写的格式很相像]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode942-增减字符串匹配]]></title>
    <url>%2F2020%2F03%2F26%2FLeetCode942-%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题目描述给定只含 &quot;I&quot;（增大）或 &quot;D&quot;（减小）的字符串 S ，令 N = S.length。 返回 [0, 1, ..., N] 的任意排列 A 使得对于所有 i = 0, ..., N-1，都有： 如果 S[i] == &quot;I&quot;，那么 A[i] &lt; A[i+1] 如果 S[i] == &quot;D&quot;，那么 A[i] &gt; A[i+1] 示例 1： 12输出：&quot;IDID&quot;输出：[0,4,1,3,2] 示例 2： 12输出：&quot;III&quot;输出：[0,1,2,3] 示例 3： 12输出：&quot;DDI&quot;输出：[3,2,0,1] 提示： 1 &lt;= S.length &lt;= 10000 S 只包含字符 &quot;I&quot; 或 &quot;D&quot;。 解题思路题目的题意是返回 [0, 1, ..., N] 的任意排列 A，并不是返回的数组是满足递增或者递减的条件就行了。搞了半天，题目的意思都理解错了！遍历这个字符串，如果遍历的字符是I,就从0到N中选最小的字符，如果遍历的字符是D,就从0到N中选最大的字符，遍历完整个字符串之后，0到N还剩下一个数字，把剩下的那个字符加入到数组中。 12345678910111213141516class Solution &#123; public int[] diStringMatch(String S) &#123; int [] a=new int [S.length()+1]; int min=0; int max=S.length(); for(int i=0; i&lt;S.length(); i++) &#123; if(S.charAt(i)=='I') a[i]=min++; else a[i]=max--; &#125; a[S.length()]=min; return a; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode914-卡牌分组]]></title>
    <url>%2F2020%2F03%2F26%2FLeetCode914-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X &gt;= 2 时返回 true。 示例 1： 123输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2： 123输入：[1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。 示例 3： 123输入：[1]输出：false解释：没有满足要求的分组。 示例 4： 123输入：[1,1]输出：true解释：可行的分组是 [1,1] 示例 5： 123输入：[1,1,2,2,2,2]输出：true解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 &lt;= deck.length &lt;= 10000 0 &lt;= deck[i] &lt; 10000 解题思路首先判断这个数组的长度可以被每个组的人数（k）整除，然后判断每个数出现的次数是否可以被k整除（也就是判断分组的人数是否正确）。如果可以就返回true。每组的人数要大于等于2，这里卡了我好久。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public boolean hasGroupsSizeX(int[] deck) &#123; int len=deck.length; if(len==1) return false; int [] a=new int [10000]; for(int i=0; i&lt;len; i++) &#123; a[deck[i]]++;//记录每个数字出现的次数 &#125; for(int i=1; i&lt;=len; i++) &#123; if(len%i==0)//分成i组 &#123; int teamnum=len/i;//每组的人数 if(teamnum&gt;=2&amp;&amp;judge(teamnum,a)==true) return true; &#125; &#125; return false; &#125; private boolean judge(int k,int [] a) &#123; for(int i=0; i&lt;10000; i++) &#123; if(a[i]==0||(a[i]%k==0)) continue; else return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode812-最大三角形面积]]></title>
    <url>%2F2020%2F03%2F25%2FLeetCode812-%E6%9C%80%E5%A4%A7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目描述给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。 123456789示例:输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]输出: 2解释: 这五个点如下图所示。组成的橙色三角形是最大的，面积为2。 注意: 3 &lt;= points.length &lt;= 50. 不存在重复的点。 -50 &lt;= points[i][j] &lt;= 50. 结果误差值在 10^-6 以内都认为是正确答案。 解题思路三角形根据坐标求面积的公式。这篇文中写的很详细 1234567891011121314151617181920class Solution &#123; public double largestTriangleArea(int[][] points) &#123; double s=0; for(int i=0; i&lt;points.length; i++)//x1,y1 &#123; for(int j=0; j&lt;points.length; j++)//x2,y2 &#123; for(int k=0; k&lt;points.length; k++)//x3,y3 &#123; double s1=(points[j][0]-points[i][0])*(points[j][1]-points[i][1])/2.0; double s2=(points[j][0]-points[i][0])*(points[i][1]-points[k][1])/2.0; double s3=(points[k][0]-points[j][0])*(points[j][1]-points[i][1])/2.0; if(s1+s2+s3&gt;s) s=s1+s2+s3; &#125; &#125; &#125; return s; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>三角形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode892-三维形体的表面积]]></title>
    <url>%2F2020%2F03%2F25%2FLeetCode892-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目描述在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1： 12输入：[[2]]输出：10 示例 2： 12输入：[[1,2],[3,4]]输出：34 示例 3： 12输入：[[1,0],[0,2]]输出：16 示例 4： 12输入：[[1,1,1],[1,0,1],[1,1,1]]输出：32 示例 5： 12输入：[[2,2,2],[2,1,2],[2,2,2]]输出：46 提示： 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 解题思路这道看起来很复杂，起始很简单，只要计算重复的面的个数，每一个正方体有6个面，每两个正方体相邻的话，就减少了两个面。 123456789101112131415161718192021222324252627class Solution &#123; public int surfaceArea(int[][] grid) &#123; int rows=grid.length; int cols=grid[0].length; int sum=0; for(int i=0; i&lt;rows; i++) &#123; for(int j=0; j&lt;cols; j++) &#123; int temp=grid[i][j]&gt;0?grid[i][j]:0; if(temp&gt;0) sum+=6*temp-(temp-1)*2; if(i-1&gt;=0) &#123; int temp1=Math.min(temp,grid[i-1][j]); sum-=(2*temp1); &#125; if(j-1&gt;=0) &#123; int temp2=Math.min(temp,grid[i][j-1]); sum-=(2*temp2); &#125; &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode645-错误的集合]]></title>
    <url>%2F2020%2F03%2F25%2FLeetCode645-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目描述集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。 给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。 示例 1: 12输入: nums = [1,2,2,4]输出: [2,3] 注意: 给定数组的长度范围是 [2, 10000]。 给定的数组是无序的。 解题思路这题我想了很久也没有想出来，我也是服了自己。直接开一个数组，对应下标记录对应的数，里面的数记录对应数出现的次数。如果一个数出现了两次，这个下标就是重复的数，如果数组中的一个数出现了0次，则这个数的下标就是缺少的数 12345678910111213141516171819class Solution &#123; public int[] findErrorNums(int[] nums) &#123; int len = nums.length; int [] cout=new int [len+1]; int more=-1,miss=-1; for(int i=0; i&lt;len; i++) &#123; cout[nums[i]]++; &#125; for(int i=1; i&lt;=len; i++) &#123; if(cout[i]==2)//重复元素 more=i; if(cout[i]==0)//少的元素 miss=i; &#125; return new int [] &#123;more,miss&#125;; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode633-平方数之和]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1: 123输入: 5输出: True解释: 1 * 1 + 2 * 2 = 5 示例2: 12输入: 3输出: False 解题思路利用sqrt函数就很好解决。用两个指针left和right，left为0，right为sqrt(n),left的平方和right的平方加起来大于n，right向左移动，小于，left向右移动，如果相等则返回true。 12345678910111213141516public class Solution &#123; public boolean judgeSquareSum(int c) &#123; long left=0,right=(long)Math.sqrt(c*1.0); while(left&lt;=right) &#123; long sum=left*left+right*right; if(sum&gt;c) right--; else if(sum&lt;c) left++; else//long型和int型比较时，int会自动转化成long型 return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode628-三个数的最大乘积]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目描述给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1: 12输入: [1,2,3]输出: 6 示例 2: 12输入: [1,2,3,4]输出: 24 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 解题思路先对数组进行排序，如果全部是正数，那么最后三个数的乘积就是最大的，如果包含负数，第一个和第二个数和最后一个数的乘积，最大的情况就包含这两种情况。 123456class Solution &#123; public int maximumProduct(int[] nums) &#123; Arrays.sort(nums); return nums[0]*nums[1]*nums[nums.length-1]&gt;nums[nums.length-3]*nums[nums.length-2]*nums[nums.length-1]?nums[0]*nums[1]*nums[nums.length-1]:nums[nums.length-3]*nums[nums.length-2]*nums[nums.length-1]; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode598-范围求和II]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode598-%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8CII%2F</url>
    <content type="text"><![CDATA[题目描述给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。 示例 1: 123456789101112131415161718192021输入: m = 3, n = 3operations = [[2,2],[3,3]]输出: 4解释: 初始状态, M = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]执行完操作 [2,2] 后, M = [[1, 1, 0], [1, 1, 0], [0, 0, 0]]执行完操作 [3,3] 后, M = [[2, 2, 1], [2, 2, 1], [1, 1, 1]]M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。 注意: m 和 n 的范围是 [1,40000]。 a 的范围是 [1,m]，b 的范围是 [1,n]。 操作数目不超过 10000。 解题思路这道题用暴力通不过，这道题就是求面积的交集，由于都是从下标零开始的，就很好求公共面积。 1234567891011class Solution &#123; public int maxCount(int m, int n, int[][] ops) &#123; for(int []op: ops) &#123; m=Math.min(m,op[0]); n=Math.min(n,op[1]); &#125; return n*m; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode453-最小移动次数使数组元素相等]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode453-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[题目描述给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。 示例: 12345678910输入:[1,2,3]输出:3解释:只需要3次移动（注意每次移动会增加两个元素的值）：[1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 解题思路每次移动可以使n-1个元素增加1，相当于每次减少1。例如[1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 每次减少1：[1,2,3] =&gt; [1,2,2] =&gt; [1,2,1] =&gt; [1,1,1],使用的次数是一样的。 再举个例子：[1,1,2,3] =&gt;[2,2,3,3] =&gt; [3,3,4,3] =&gt; [4,4,4,4] 每次减少1：[1,1,2,3]=&gt;[1,1,1,3]=&gt;[1,1,1,2] =&gt; [1,1,1,1] 123456789101112131415class Solution &#123; public int minMoves(int[] nums) &#123; int sum=0;//统计该数组的所有元素的值 Arrays.sort(nums); int len=nums.length; if(len==1) return 0; int minelement=nums[0]; for(int i=0; i&lt;len; i++) &#123; sum+=(nums[i]-minelement); &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode367-有效的完全平方数]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1： 12输入：16输出：True 示例 2： 12输入：14输出：False 解题思路本来想用暴力解决，但是超时了，利用完全平方数的性质n=1+3+5+7+9+… 比如：4=1+3， 9=1+3+5, 16=1+3+5+7 12345678910111213class Solution &#123; public boolean isPerfectSquare(int num) &#123; int i=1; while(num&gt;0) &#123; num=num-i; i=i+2; &#125; if(num==0) return true; return false; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode231-2的幂]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode231-2%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[题目描述给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 123输入: 1输出: true解释: 20 = 1 示例 2: 123输入: 16输出: true解释: 24 = 16 示例 3: 12输入: 218输出: false 解题思路我的思维还是太死板了，就知道一直乘以2，如果最终的结果等于n，则返回true，否则返回false，然后就超时了。 换另一种方法，如果一个数是2的幂次，那么这个数一定可以n&amp;(n-1)==0 大佬的解释链接 超时代码1234567891011121314151617class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if(n==1) return true; int i=2; while(i&lt;n) &#123; if(i*i&lt;n)//优化 i=i*i; else i=i*2; &#125; if(i==n) return true; return false; &#125;&#125; 优化代码12345class Solution &#123; public boolean isPowerOfTwo(int n) &#123; return n&gt;0&amp;&amp;(n&amp;(n-1))==0; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode204-计数质数]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述统计所有小于非负整数 *n *的质数的数量。 示例: 123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解题思路遍历1到n，判断每一个数是否是质数，这种方法容易超时，只能用筛(shuai)选法去做,别人的详细的思路,我自己就没有那么详细写了。 常规解法123456789101112131415161718192021222324252627class Solution &#123; public int countPrimes(int n) &#123; int cout=0; for(int i=2; i&lt;n; i++) &#123; if(judge(i)) cout++; &#125; return cout; &#125; private boolean judge(int n) &#123; if(n&lt;2) return false; else if(n==2) return true; else &#123; for(int i=2; i&lt;=Math.sqrt(n*1.0); i++) &#123; if(n%i==0) return false; &#125; return true; &#125; &#125;&#125; 但是超时了 筛选法123456789101112131415161718192021222324class Solution &#123; public int countPrimes(int n) &#123; if(n&lt;=2) return 0; int [] a=new int[n]; int cout=0; for(int i=2; i&lt;n; i++) &#123; if(a[i]==0)//这个数是质数，那么它的倍数都不是质数 &#123; for(int j=i+i; j&lt;n; j+=i) &#123; a[j]=1; &#125; &#125; &#125; for(int i=2; i&lt;n; i++)//统计质数的个数 &#123; if(a[i]==0) cout++; &#125; return cout; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode202-快乐数]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode202-%E5%BF%AB%E4%B9%90%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 *示例: * 1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 解题思路看了大佬的解题思路恍然大悟 简而言之，是否可以变成快乐数，如果其中没有死循环的话，就可以变成快乐数，有死循环的话，就不能变成快乐数，相当于链表的有环路。 123456789101112131415161718192021222324class Solution &#123; public boolean isHappy(int n) &#123; int slow=getnum(n);//慢指针 int fast=getnum(getnum(n));//快指针 while(fast!=1)&#123; slow=getnum(slow); fast=getnum(getnum(fast)); if(slow==fast) return false;//有死循环 &#125; return true; &#125; public int getnum(int n) &#123; int s=0; while(n!=0) &#123; int temp=n%10; s+=temp*temp; n=n/10; &#125; return s; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>特殊数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode172-阶乘后的零]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 123输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 123输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: *你算法的时间复杂度应为 *O(log n)。 解题思路我看到时间复杂度为logn直接就不会了。。大佬的解题思路很清晰这道题就是求n的阶乘中因子10的个数，可以简化为求n的阶乘中因子5的个数，因为因子2的个数远超5的个数。举个例子7！=7×6×5×4×3×2×1，因子2有4个，但是5只有一个。 1234567891011class Solution &#123; public int trailingZeroes(int n) &#123; int cout=0; while(n!=0) &#123; cout+=n/5; n=n/5; &#125; return cout; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode面试题17.16-按摩师]]></title>
    <url>%2F2020%2F03%2F24%2FLeetCode%E9%9D%A2%E8%AF%95%E9%A2%9817-16-%E6%8C%89%E6%91%A9%E5%B8%88%2F</url>
    <content type="text"><![CDATA[题目描述一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 注意：本题相对原题稍作改动 示例 1： 123输入： [1,2,3,1]输出： 4解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。 示例 2： 123输入： [2,7,9,3,1]输出： 12解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。 12345示例 3：输入： [2,1,4,5,3,1,1,3]输出： 12解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。 解题思路状态转移方程:dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]); 这题和198.大家劫舍一模一样 123456789101112131415161718class Solution &#123; public int massage(int[] nums) &#123; // dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]); int len = nums.length; if(len&lt;1) return 0; if(len==1) return nums[0]; int [] dp=new int [len];//? dp[0]=nums[0]; dp[1]=Math.max(nums[0],nums[1]); for(int i=2; i&lt;len; i++) &#123; dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[len-1]; &#125;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode168-Excel表列名称]]></title>
    <url>%2F2020%2F03%2F23%2FLeetCode168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... 示例 1: 12输入: 1输出: &quot;A&quot; 示例 2: 12输入: 28输出: &quot;AB&quot; 示例 3: 12输入: 701输出: &quot;ZY&quot; 解题思路这么简单的问题，自己就是想不出来，这和10进制转成二进制是有差别的！ 别人的思路 12345678910111213class Solution &#123; public String convertToTitle(int n) &#123; String str="ABCDEFGHIJKLMNOPQRSTUVWXYZ"; String res=""; while(n!=0) &#123; int temp=(--n)%26; n=n/26; res=str.charAt(temp)+res; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode周赛题5367-最长快乐前缀]]></title>
    <url>%2F2020%2F03%2F22%2FLeetCode%E5%91%A8%E8%B5%9B%E9%A2%985367-%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[题目描述「快乐前缀」是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。 给你一个字符串 s，请你返回它的 最长快乐前缀。 如果不存在满足题意的前缀，则返回一个空字符串。 示例 1： 123输入：s = &quot;level&quot;输出：&quot;l&quot;解释：不包括 s 自己，一共有 4 个前缀（&quot;l&quot;, &quot;le&quot;, &quot;lev&quot;, &quot;leve&quot;）和 4 个后缀（&quot;l&quot;, &quot;el&quot;, &quot;vel&quot;, &quot;evel&quot;）。最长的既是前缀也是后缀的字符串是 &quot;l&quot; 。 示例 2： 123输入：s = &quot;ababab&quot;输出：&quot;abab&quot;解释：&quot;abab&quot; 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。 示例 3： 12输入：s = &quot;leetcodeleet&quot;输出：&quot;leet&quot; 示例 4： 12输入：s = &quot;a&quot;输出：&quot;&quot; 提示： 1 &lt;= s.length &lt;= 10^5 s 只含有小写英文字母 解题思路我本来想用两个字符串来保存从前往后，以及从后往前的到的字符串，返回最长相等的字符串，但是超时了。后来看了别人呢的解题思路，原来这道题就是求KMP算法中next数组。KMP算法讲得很清晰 超时的代码123456789101112131415161718class Solution &#123; public String longestPrefix(String s) &#123; String pre=""; String post=""; String res=""; int i=0,j=s.length()-1; while(i&lt;s.length()-1&amp;&amp;j&gt;0) &#123; pre+=s.charAt(i); post=s.charAt(j)+post; if(pre.equals(post)) res=pre; i++; j--; &#125; return res; &#125;&#125; 求next数组的方法123456789101112131415161718192021222324252627class Solution &#123; public String longestPrefix(String s) &#123; int len=s.length(); int [] next=new int[len+1]; next=getNext(s); int n=next[len]; return s.substring(0,n); &#125; private int [] getNext(String s) &#123; int i=0,k=-1; int [] next=new int [s.length()+1]; next[0]=-1; while(i&lt;s.length()) &#123; if(k==-1||s.charAt(i)==s.charAt(k)) &#123; ++k; ++i; next[i]=k; &#125; else k=next[k]; &#125; return next; &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode字符串笔记</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode周赛题-5366-检查网络中是否存在有效路径]]></title>
    <url>%2F2020%2F03%2F22%2FLeetCode%E5%91%A8%E8%B5%9B%E9%A2%98-5366-%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述给你一个 m x n 的网格 grid。网格里的每个单元都代表一条街道。grid[i][j] 的街道可以是： 1 表示连接左单元格和右单元格的街道。2 表示连接上单元格和下单元格的街道。3 表示连接左单元格和下单元格的街道。4 表示连接右单元格和下单元格的街道。5 表示连接左单元格和上单元格的街道。6 表示连接右单元格和上单元格的街道。 你最开始从左上角的单元格 (0,0) 开始出发，网格中的「有效路径」是指从左上方的单元格 (0,0) 开始、一直到右下方的 (m-1,n-1) 结束的路径。该路径必须只沿着街道走。 注意：你 不能 变更街道。 如果网格中存在有效的路径，则返回 true，否则返回 false 。 示例 1： 123输入：grid = [[2,4,3],[6,5,2]]输出：true解释：如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。 原题链接 解题思路这道用广度优先遍历真的很好解决，但是自己不是很熟，所有在比赛的时候写了很久也没有写出来，呜呜呜 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public boolean hasValidPath(int[][] grid) &#123; Queue &lt;int []&gt; queue=new LinkedList&lt;&gt;(); boolean [][] visit=new boolean[grid.length][grid[0].length]; queue.offer(new int[] &#123;0,0&#125;); visit[0][0]=true; int [] dx=&#123;-1,1,0,0&#125;;//上下左右 int [] dy=&#123;0,0,-1,1&#125;; while(!queue.isEmpty()) &#123; int [] poll=queue.poll(); if(poll[0]==grid.length-1&amp;&amp;poll[1]==grid[0].length-1)//走到了右下角 return true; int way=1;//控制方向，1，2，3，4分别控制上下左右 for(int i=0; i&lt;4; i++)//对该点的上下左右四个方向进行判断 &#123; int newx=poll[0]+dx[i]; int newy=poll[1]+dy[i]; int oldplace=grid[poll[0]][poll[1]];//原来位置的数字 if(newx&gt;=0&amp;&amp;newx&lt;grid.length&amp;&amp;newy&gt;=0&amp;&amp;newy&lt;grid[0].length&amp;&amp;visit[newx][newy]==false) &#123; int newplace=grid[newx][newy];//新位置的数字 if(findpath(oldplace,newplace,way)) &#123; visit[newx][newy]=true; queue.offer(new int[]&#123;newx,newy&#125;); &#125; &#125; way++; &#125; &#125; return false; &#125; private boolean findpath(int oldplace,int newplace,int way)//原位置数字，新位置数字，方向 &#123; if(way==1)//上 &#123; if((oldplace==2||oldplace==5||oldplace==6)&amp;&amp;(newplace==2||newplace==3||newplace==4))//找出符合要求的，原位置的数字为2，5，6则新位置只有2，3，4满足 &#123; return true; &#125; &#125; else if(way==2)//下 &#123; if((oldplace==2||oldplace==3||oldplace==4)&amp;&amp;(newplace==2||newplace==5||newplace==6)) &#123; return true; &#125; &#125; else if(way==3)//左 &#123; if((oldplace==1||oldplace==3||oldplace==5)&amp;&amp;(newplace==1||newplace==4||newplace==6)) &#123; return true; &#125; &#125; else if(way==4)//右 &#123; if((oldplace==1||oldplace==4||oldplace==6)&amp;&amp;(newplace==1||newplace==5||newplace==3)) &#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode周赛题-5178-四因数]]></title>
    <url>%2F2020%2F03%2F22%2FLeetCode%E5%91%A8%E8%B5%9B%E9%A2%98-5178-%E5%9B%9B%E5%9B%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给你一个整数数组 nums，请你返回该数组中恰有四个因数的这些整数的各因数之和。 如果数组中不存在满足题意的整数，则返回 0 。 123456789示例：输入：nums = [21,4,7]输出：32解释：21 有 4 个因数：1, 3, 7, 214 有 3 个因数：1, 2, 47 有 2 个因数：1, 7答案仅为 21 的所有因数的和。 解题思路这道题自己在比赛的时候，写出了O(n^2/2)的代码，但是有的例子超时，哎，看了别人的解题思路后，原来还可以优化到O(n×sqrt{n}),主要是自己写的时候不怎么自信，总感觉会超时。别人利用了set来保存因数，每遍历一个数，只遍历到sqrt（n），就把所有的因数求出来了，自己以前好像还做过类似的题目。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int sumFourDivisors(int[] nums) &#123; int res=0; for(int num:nums) &#123; res+=judge(num); &#125; return res; &#125; public int judge(int num) &#123; Set &lt;Integer&gt; set=new HashSet&lt;&gt; (); for(int i=1; i&lt;=Math.sqrt(num*1.0); i++) &#123; if(num%i==0) &#123; set.add(i); set.add(num/i); &#125; if(set.size()&gt;4) return 0; &#125; if(set.size()&lt;4) return 0; int sum=0; if(set.size()==4) &#123; for(int i:set) &#123; sum+=i; &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>因数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode945-使数组唯一的最小增量]]></title>
    <url>%2F2020%2F03%2F22%2FLeetCode945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目描述给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。 返回使 A 中的每个值都是唯一的最少操作次数。 示例 1: 123输入：[1,2,2]输出：1解释：经过一次 move 操作，数组将变为 [1, 2, 3]。 示例 2: 1234输入：[3,2,1,2,1,7]输出：6解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。 提示： 0 &lt;= A.length &lt;= 40000 0 &lt;= A[i] &lt; 40000 解题思路大佬思路 最终的结果使一样的，虽然增加方式不唯一，但是等价，比如1 3变成3 4，可以是1+3，也可以是1+2，3+1，操作的次数就是最终数列和减去初始数列和，最终的数列要保持递增。 1234567891011121314151617181920class Solution &#123; public int minIncrementForUnique(int[] A) &#123; if(A.length&lt;2) return 0; Arrays.sort(A); int pre=A[0]; int res=0; for(int i=1; i&lt;A.length; i++) &#123; if(A[i]&lt;=pre) &#123; res+=(pre+1-A[i]); pre=pre+1; &#125; else pre=A[i]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode385-迷你语法分析器]]></title>
    <url>%2F2020%2F03%2F21%2FLeetCode385-%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。 列表中的每个元素只可能是整数或整数嵌套列表 提示：你可以假定这些字符串都是格式良好的： 字符串非空 字符串不包含空格 字符串只包含数字0-9, [, - ,, ] 示例 1： 123给定 s = &quot;324&quot;,你应该返回一个 NestedInteger 对象，其中只包含整数值 324。 示例 2： 123456789给定 s = &quot;[123,[456,[789]]]&quot;,返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：1. 一个 integer 包含值 1232. 一个包含两个元素的嵌套列表： i. 一个 integer 包含值 456 ii. 一个包含一个元素的嵌套列表 a. 一个 integer 包含值 789 解题思路这道主要是理解题意比较困难，如果s=&quot;[123,124]&quot;，返回的是一个NestedInteger对象，一个对象里面包含两个NestedInteger对象，一个是123，另一个是124，如果s=&quot;123&quot;,返回的是一个对象，里面的数值是123。 注意点 while里面的i++不要放到continue的后面，不然容易死循环，这个bug找了一个小时！，大晚上的。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * // Constructor initializes an empty nested list. * public NestedInteger(); * * // Constructor initializes a single integer. * public NestedInteger(int value); * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // Set this NestedInteger to hold a single integer. * public void setInteger(int value); * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * public void add(NestedInteger ni); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */class Solution &#123; char [] chars; int i=0;//记录当前遍历的位置 public NestedInteger deserialize(String s) &#123; chars=s.toCharArray(); if(chars[i]!='[')//是一串字符数字 return new NestedInteger(Integer.valueOf(s)); else return getNestedInteger(); &#125; public NestedInteger getNestedInteger() &#123; NestedInteger net=new NestedInteger(); boolean flag=false;//记录是否是负数 int num=0; while(i&lt;chars.length-1) &#123; i++; if(chars[i]==',') continue; else if(chars[i]=='[') &#123; net.add(getNestedInteger()); &#125; else if(chars[i]=='-') flag=true; else if(chars[i]==']') return net; else //是数字 &#123; if(flag==false) num=num*10+chars[i]-'0'; else num=num*10-(chars[i]-'0'); if(chars[i+1]==','||chars[i+1]==']')//数字遍历结束 &#123; net.add(new NestedInteger(num)); flag=false; num=0; &#125; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode字符串笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode227-基本计算器II]]></title>
    <url>%2F2020%2F03%2F21%2FLeetCode227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II%2F</url>
    <content type="text"><![CDATA[题目描述实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格 。 整数除法仅保留整数部分。 示例 1: 12输入: &quot;3+2*2&quot;输出: 7 示例 2: 12输入: &quot; 3/2 &quot;输出: 1 示例 3: 12输入: &quot; 3+5 / 2 &quot;输出: 5 说明： 你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 解题思路用一个栈很好解决 1.如果是数字，就把数字入栈 2.如果是加号，就把加号后面的数字入栈 3.如果是减号，就把减号后面的数字加上负号入栈 4.如果是乘号，就把栈顶的数字取出来，和称号后面的数字相乘的结果后，入栈这个结果 5.如果是除号，就把栈顶的数字取出来，和称号后面的数字相除的结果后，入栈这个结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int calculate(String s) &#123; char [] str=s.toCharArray(); int res=0; Stack &lt;Integer&gt; stack=new Stack&lt;&gt;(); for(int i=0; i&lt;str.length; i++) &#123; if(str[i]==' ')continue; int [] a=new int[2];//a[0]返回数字，a[1]返回下一次遍历的位置 if(str[i]=='+'||Character.isDigit(str[i]))//数字或加号把数字入栈或加号后面的数字进栈 &#123; a=returnnum(str,i); stack.push(a[0]); &#125; else if(str[i]=='-')//减号，后面的数字加上负号入栈 &#123; a=returnnum(str,i); stack.push(-a[0]); &#125; else if(str[i]=='*')//乘法，把对应乘出来的结果入栈 &#123; a=returnnum(str,i); int temp=stack.pop(); stack.push(temp*a[0]); &#125; else if(str[i]=='/')//除号，把栈顶元素除以后面的数字的结果后入栈 &#123; a=returnnum(str,i); int temp=stack.pop(); stack.push(temp/a[0]); &#125; i=a[1]-1;//下次遍历的前一个下标 &#125; for(int i=0; i&lt;stack.size(); i++) &#123; res+=stack.get(i); &#125; return res; &#125; public int [] returnnum(char [] str,int i) &#123; int [] sum=new int[2]; while(i&lt;str.length&amp;&amp;!Character.isDigit(str[i]))//跳过非数字部分 i++; while(i&lt;str.length&amp;&amp;Character.isDigit(str[i])) &#123; sum[0]=sum[0]*10+(str[i]-'0'); i++; &#125; sum[1]=i; return sum; &#125;&#125; 新知识Character.isDigit(c)用来判断字符c是否是数字，如果是，返回true，否则返回false]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>LeetCode字符串笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode365-水壶问题]]></title>
    <url>%2F2020%2F03%2F21%2FLeetCode365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述有两个容量分别为 x升 和* y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 *z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 *z升 *水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: (From the famous *”Die Hard”* example) 12输入: x = 3, y = 5, z = 4输出: True 示例 2: 12输入: x = 2, y = 6, z = 5输出: False 解题思路别人的文章 原题可以理解为mx+ny=z，例子1为：3m+5n=4是否有解 数学定理 1如果k为x和y的最大公约数，则k=mx+ny，m，n为整数 则原问题可以转化为z%k==0,如果是，则有解，如果不是，则无解 123456789101112131415161718192021222324class Solution &#123; public boolean canMeasureWater(int x, int y, int z) &#123; if(x+y&lt;z) return false; if(x==0||y==0) return y==z||x==z; // 让y是x和y中最大的 if(x&gt;y) &#123; int temp=y; y=x; x=temp; &#125; //辗转相除法求最大公约数 while(y%x!=0) &#123; int val=y%x; y=x; x=val; &#125; int k=x; return z%k==0; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>LeetCode数学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode165-比较版本号]]></title>
    <url>%2F2020%2F03%2F21%2FLeetCode165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目描述比较两个版本号 version1 *和 *version2。如果 *version1 *&gt; *version2* 返回 1，如果 *version1 *&lt; *version2* 返回 -1， 除此之外返回 0。 你可以假设版本字符串非空，并且只包含数字和 . 字符。 . 字符不代表小数点，而是用于分隔数字序列。 例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。 你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。 示例 1: 12输入: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;输出: -1 示例 2: 12输入: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;输出: 1 示例 3: 12输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;输出: -1 示例 4： 123输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;输出：0解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。 示例 5： 123输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;输出：0解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。 提示： 版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。 版本字符串不以点开始或结束，并且其中不会有两个连续的点。 解题思路12s.split(&quot;\\.&quot;);//. 在正则里有特殊含义，所以我们需要进行转义。Integer.parseInt(s);//可以把字符串转成整数 123456789101112131415161718192021class Solution &#123; public int compareVersion(String version1, String version2) &#123; String [] num1=version1.split("\\."); String [] num2=version2.split("\\."); int len1=num1.length; int len2=num2.length; int i=0,j=0; while(i&lt;len1||j&lt;len2) &#123; int s1=i&gt;=len1?0:Integer.parseInt(num1[i]); int s2=j&gt;=len2?0:Integer.parseInt(num2[i]); if(s1&gt;s2) return 1; if(s1&lt;s2) return -1; i++; j++; &#125; return 0; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode字符串笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode151-翻转字符串里的单词]]></title>
    <url>%2F2020%2F03%2F20%2FLeetCode151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串，逐个翻转字符串中的每个单词。 示例 1： 12输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot; 示例 2： 123输入: &quot; hello world! &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 123输入: &quot;a good example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 解题思路trim函数可以去掉字符串首部和尾部的空格，还有s.split(&quot; &quot;)会把&quot;a good example&quot;空格后面的空格变成空字符数组，这个要注意一下。 12345678910111213class Solution &#123; public String reverseWords(String s) &#123; String [] str=s.trim().split(" ");//trim函数去掉字符串首部和尾部的空格，然后按照空格划分成字符数组 int len=str.length; StringBuilder builder=new StringBuilder(); for(int i=len-1; i&gt;=0; i--) &#123; if(!str[i].equals(""))//空格后面的空格会变成空字符数组 builder.append(str[i]+" "); &#125; return builder.toString().trim(); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode字符串笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode93-复原IP地址]]></title>
    <url>%2F2020%2F03%2F20%2FLeetCode93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[题目描述给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 12输入: &quot;25525511135&quot;输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 解题思路看了liweiwei1419的解法，讲得很容易理解，我回溯法这方面还要加强锻炼。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; int len=s.length(); List&lt;String&gt; list=new ArrayList&lt;&gt;();//保存最终结果 if(len&lt;4||len&gt;12)//字符串的长度小于4或者大于12，不可能有符合的ip地址 return list; int splittime=0; Deque&lt;String&gt; path=new ArrayDeque&lt;&gt;(4);//保存符合的子路径，例如255，11，111 helprestoreIpAddresses(s,list,path,len,0,splittime); return list; &#125; public void helprestoreIpAddresses(String s,List&lt;String&gt; list,Deque&lt;String&gt;path,int len,int start,int splittime)//start是这次遍历的起始位置下标,splittime是符合条件遍历的次数 &#123; if(start==len)//结束条件 &#123; if(splittime==4) &#123; list.add(String.join(".",path)); return; &#125; &#125; if((len-start)&lt;4-splittime||len-start&gt;(4-splittime)*3)//去掉一些不符合的遍历 return; for(int i=0; i&lt;3; i++) &#123; int flag=judge(start,start+i,s); if(flag!=-1)//符合条件的字符串 &#123; path.addLast(flag+""); helprestoreIpAddresses(s,list,path,len,start+i+1,splittime+1); path.removeLast(); &#125; &#125; &#125; public int judge(int start,int end, String s) &#123; int len=end-start+1;//判断这次字符串的长度 if(len&gt;1&amp;&amp;s.charAt(start)=='0')//如果字符串的首字母为0，则不符合 return -1; if(end&gt;=s.length()) return -1; int sum=0; for(int i=start; i&lt;=end; i++) &#123; sum=sum*10+(s.charAt(i)-'0'); &#125; if(sum&gt;255)//只有一个0是符合的 return -1; return sum; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode回溯法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode409-最长回文串]]></title>
    <url>%2F2020%2F03%2F19%2FLeetCode409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1: 12345678输入:&quot;abccccdd&quot;输出:7解释:我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。 解题思路统计每个字符出现的次数，如果这个字符出现偶数，则把次数用s加起来，如果字符出现奇数，则s加出现次数的-1.例如：aaa.最后的结果s如果小于字符串的长度，则返回s+1，如果s等于字符串的长度，则返回s 123456789101112131415161718192021222324252627class Solution &#123; public int longestPalindrome(String s) &#123; int len=s.length(); int [] a=new int[300]; for(int i=0; i&lt;len; i++)//统计每个字符出现的次数 &#123; int temp=s.charAt(i)-'0'; a[temp]++; &#125; int sum=0; for(int i=0; i&lt;300; i++) &#123; if(a[i]%2==0) &#123; sum+=a[i]; &#125; else//奇数次也只加偶数次的份 &#123; sum+=(a[i]-1); &#125; &#125; if(sum&lt;len) return sum+1; else return sum; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode字符串笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode836-矩形重叠]]></title>
    <url>%2F2020%2F03%2F18%2FLeetCode836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[题目描述矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。 示例 1： 12输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]输出：true 示例 2： 12输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]输出：false 提示： 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。 矩形中的所有坐标都处于 -10^9 和 10^9 之间。 x 轴默认指向右，y 轴默认指向上。 你可以仅考虑矩形是正放的情况。 解题思路我开始想的是矩形二的四个点有一个落在第一个矩形中就重叠了，但是有特殊情况，有一条边恰好落在矩形一的一条边上，这样就会判断出错。 看了别人的解题思路后，只要矩形一在矩形二的左侧或者在矩形二的右侧，或者矩形二的上侧，或者在矩形二的下侧。 1234rec1[2]&lt;=rec2[0];//左侧rec1[0]&gt;=rec2[2];//右侧rec1[1]&gt;=rec2[3];//上侧rec1[3]&lt;=rec2[1];//下侧 12345678class Solution &#123; public boolean isRectangleOverlap(int[] rec1, int[] rec2) &#123; return !(rec1[2]&lt;=rec2[0]||//左侧 rec1[0]&gt;=rec2[2]||//右侧 rec1[1]&gt;=rec2[3]||//上侧 rec1[3]&lt;=rec2[1]); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode91-解码方法]]></title>
    <url>%2F2020%2F03%2F17%2FLeetCode91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目描述一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 123输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2: 123输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 解题思路利用动态规划，多谢Edward文章 dp[i]是前i个数字可以解码的方法，例如123ab，可以分成以下几种情况 1.如果a==’0’&amp;&amp;b==’0’,则返回0 2.如果a==’0’,则dp[i]=dp[i-2],注意不是dp[i]=dp[i-1],即和前i-2个数字解码的方法一样多 3.如果b==’0’,则要根据ab组成的数字进行判断，如果这个数字大于26，即大于等于30，返回0，如果这个数字小于等于26，则返回dp[i]=dp[i-1] 4.如果都不等于0，则根据ab组成的数字进行判断，如果这个数字大于26，返回dp[i]=dp[i-1]，如果这个数字小于等于26，则返回dp[i]=dp[i-1]+dp[i-2] 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int numDecodings(String s) &#123; char [] str=s.toCharArray(); int [] dp=new int [s.length()+1]; dp[0]=1; dp[1]=str[0]=='0'?0:1; for(int i=2; i&lt;=s.length(); i++) &#123; int num=(str[i-2]-'0')*10+(str[i-1]-'0'); if(str[i-2]=='0'&amp;&amp;str[i-1]=='0') return 0; else if(str[i-1]=='0'&amp;&amp;str[i-2]!='0') &#123; if(num&gt;26) return 0; dp[i]=dp[i-2]; &#125; else if(str[i-1]!='0'&amp;&amp;str[i-2]=='0') &#123; dp[i]=dp[i-1]; &#125; else if(str[i-1]!='0'&amp;&amp;str[i-2]!='0') &#123; if(num&gt;26) dp[i]=dp[i-1]; else dp[i]=dp[i-1]+dp[i-2]; &#125; &#125; return dp[dp.length-1]; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode字符串笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode71-简化路径]]></title>
    <url>%2F2020%2F03%2F16%2FLeetCode71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1： 123输入：&quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。 示例 2： 123输入：&quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 示例 3： 123输入：&quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4： 12输入：&quot;/a/./b/../../c/&quot;输出：&quot;/c&quot; 示例 5： 12输入：&quot;/a/../../b/../c//.//&quot;输出：&quot;/c&quot; 示例 6： 12输入：&quot;/a//b////c/d//././/..&quot;输出：&quot;/a/b/c&quot; 解题思路看了StackOverflow的解题思路，才知道这道题用栈解题十分容易，把字符串用/分成字符数组 如果字符数组是..,并且栈不为空，则出栈 如果字符数组不是&quot;.&quot;,&quot;..&quot;,&quot;&quot;,则进栈 遍历结束后，如果栈为空，则返回/ 1234567891011121314151617181920212223class Solution &#123; public String simplifyPath(String path) &#123; Stack &lt;String&gt; stack=new Stack&lt;&gt;(); String [] str=path.split("/"); for(String s:str) &#123; if(!stack.isEmpty()&amp;&amp;s.equals("..")) &#123; stack.pop(); &#125; else if(!s.equals(".")&amp;&amp;!s.equals("..")&amp;&amp;!s.equals("")) stack.push(s); &#125; if(stack.isEmpty()) return "/"; StringBuilder builder=new StringBuilder(); for(int i=0; i&lt;stack.size(); i++)//注意是从栈底到栈顶 &#123; builder.append("/"+stack.get(i)); &#125; return builder.toString(); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode字符串笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode49-字母异位词分组]]></title>
    <url>%2F2020%2F03%2F16%2FLeetCode49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 ​ 解题思路1.对每个字符串进行排序 2.如果对应的HashMap中通过键能找到对应的值，就把字符添加到对应的值中，如果没有就新建对应的键和值 3.返回对应的value 123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String,List&lt;String&gt;&gt; map=new HashMap&lt;&gt;(); for(String str:strs) &#123; char [] s=str.toCharArray(); Arrays.sort(s); String temp=new String(s); if(map.containsKey(temp)) &#123; List&lt;String&gt; arr=map.get(temp);//通过键找到对应的值 arr.add(str);//值中添加字符串 map.put(temp,arr);//map中添加对应的键值 &#125; else &#123; List &lt;String&gt; newarr=new ArrayList&lt;&gt;(); newarr.add(str); map.put(temp,newarr); &#125; &#125; return new ArrayList&lt;&gt;(map.values()); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1383-最大的团队表现值]]></title>
    <url>%2F2020%2F03%2F16%2FLeetCode1383-%E6%9C%80%E5%A4%A7%E7%9A%84%E5%9B%A2%E9%98%9F%E8%A1%A8%E7%8E%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述公司有编号为 1 到 n 的 n 个工程师，给你两个数组 speed 和 efficiency ，其中 speed[i] 和 efficiency[i] 分别代表第 i 位工程师的速度和效率。请你返回由最多 k 个工程师组成的 最大团队表现值 ，由于答案可能很大，请你返回结果对 10^9 + 7 取余后的结果。 团队表现值 的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。 示例 1： 1234输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2输出：60解释：我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。 示例 2： 1234输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3输出：68解释：此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。 示例 3： 12输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4输出：72 提示： 1234561 &lt;= n &lt;= 10^5speed.length == nefficiency.length == n1 &lt;= speed[i] &lt;= 10^51 &lt;= efficiency[i] &lt;= 10^81 &lt;= k &lt;= n 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-performance-of-a-team著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路fanhua的思路 先按照效率进行降序排序，然后按照效率从达到小的顺序遍历，遍历对应的效率作为最低效率，从左侧找出k-1个速度，加上这个速度为k个，找出最大的结果。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int maxPerformance(int n, int[] speed, int[] efficiency, int k) &#123; member [] meb=new member[n]; for(int i=0; i&lt;n; i++) &#123; meb[i]=new member(speed[i],efficiency[i]); &#125; PriorityQueue &lt;Integer&gt; que=new PriorityQueue &lt;Integer&gt;(); Arrays.sort(meb,(member e1,member e2)-&gt;(e2.efficiency-e1.efficiency));//按照效率逆序排序 long sum=0; long res=-1; for(int i=0; i&lt;n; i++) &#123; if(que.size()&gt;k-1) &#123; sum-=que.poll(); &#125; res=Math.max(res,(sum+meb[i].speed)*meb[i].efficiency); sum+=meb[i].speed; que.add(meb[i].speed); &#125; return (int)(res%((int)1e9+7)); &#125;&#125;class member&#123;//这样做有时候对做题很有帮助 int speed; int efficiency; public member(int speed,int efficiency)&#123; this.speed=speed; this.efficiency=efficiency; &#125;&#125; 注意点对类进行排序1Arrays.sort(meb,(member e1,member e2)-&gt;(e2.efficiency-e1.efficiency));//按照效率逆序排序 优先队列优先队列默认是升序的，即队首到队尾是升序的，出队的是最小的元素。]]></content>
      <tags>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1382-将二叉搜索树变平衡]]></title>
    <url>%2F2020%2F03%2F16%2FLeetCode1382-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[题目描述给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。 如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。 如果有多种构造方法，请你返回任意一种。 示例： 123输入：root = [1,null,2,null,3,null,4,null,null]输出：[2,1,3,null,null,null,4]解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。 提示： 树节点的数目在 1 到 10^4 之间。 树节点的值互不相同，且在 1 到 10^5 之间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/balance-a-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路这是3月15号的周赛题，自己还是太菜了，不会做，看了别人的解题思路后 先对二叉树进行中序遍历，再二分建树。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode balanceBST(TreeNode root) &#123; List &lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); midorder(list,root);//进行中序遍历，并对应的数字放到list中 return build(list,0,list.size()-1);//二分建树 &#125; public void midorder(List&lt;Integer&gt; list,TreeNode root) &#123; if(root==null) return; midorder(list,root.left); list.add(root.val); midorder(list,root.right); &#125; public TreeNode build(List&lt;Integer&gt; list,int start,int end) &#123; if(start&gt;end) return null; int mid=(start+end)/2; TreeNode root=new TreeNode(list.get(mid)); root.left=build(list,start,mid-1); root.right=build(list,mid+1,end); return root; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode周赛题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode300-最长上升子序列]]></title>
    <url>%2F2020%2F03%2F14%2FLeetCode300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 解题思路首先自己看清题目意思，不要题目都没看清就去看别人的解题思路。 这道题用动态规划，别人的解题思路 12345678910111213141516171819202122class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int len=nums.length; if(len==0) return 0; int [] dp=new int[len]; Arrays.fill(dp,1);//给数组赋值 int res=0; for(int i=0; i&lt;len; i++) &#123; for(int j=0; j&lt;i; j++) &#123; if(nums[i]&gt;nums[j]) &#123; dp[i]=Math.max(dp[i],dp[j]+1); &#125; &#125; res=Math.max(res,dp[i]); &#125; return res; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode43-字符串相乘]]></title>
    <url>%2F2020%2F03%2F13%2FLeetCode43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 12输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot; 示例 2: 12输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot; 说明： 1.num1 和 num2 的长度小于110。2.num1 和 num2 只包含数字 0-9。3.num1 和 num2 均不以零开头，除非是数字 0 本身。4.不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解题思路即模拟两个数的乘法运算，num2的每一位与num1进行乘法后，最后加起来，就得到了结果。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public String multiply(String num1, String num2) &#123; if(num1.equals("0")||num2.equals("0")) return "0"; String res="0"; for(int i=num2.length()-1; i&gt;=0; i--) &#123; StringBuilder builder=new StringBuilder(); for(int j=0; j&lt;num2.length()-1-i;j++)//添零(模拟乘法) &#123; builder.append(0); &#125; int n2=num2.charAt(i)-'0'; int carry=0; for(int j=num1.length()-1; j&gt;=0||carry&gt;0; j--) &#123; int n1=j&lt;0?0:(num1.charAt(j)-'0'); int product=(n1*n2+carry)%10; builder.append(product); carry=(n1*n2+carry)/10; &#125; res=add(res,builder.reverse().toString()); &#125; return res; &#125; public String add(String str1,String str2) &#123; int carry=0; StringBuilder result=new StringBuilder(); for(int i=str1.length()-1,j=str2.length()-1;i&gt;=0||j&gt;=0||carry&gt;0;i--,j--) &#123; int s1=i&lt;0?0:(str1.charAt(i)-'0'); int s2=j&lt;0?0:(str2.charAt(j)-'0'); int sum=(s1+s2+carry)%10; result.append(sum); carry=(s1+s2+carry)/10; &#125; return result.reverse().toString(); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode22-括号生成]]></title>
    <url>%2F2020%2F03%2F13%2FLeetCode22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n *= *3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 解题思路感谢大佬的解题思路 采用深度遍历的方法，深度遍历的终止条件是左括号剩余数等于0并且右括号剩余数为0. 左括号剩余数要小于右括号剩余数。 左括号剩余数要大于0，右括号剩余数要大于0. 盗的图… 1234567891011121314151617181920212223class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List &lt;String&gt; list=new ArrayList&lt;String&gt;(); String str=""; int left=0,right=0; generatehelp(str,n,n,list); return list; &#125; public void generatehelp(String str,int left,int right,List&lt;String&gt; list) &#123; if(left==0&amp;&amp;right==0) &#123; list.add(str); return; &#125; if(left&gt;right)//如果左括号数小于右括号数，则不符合返回 return; if(left&gt;0) generatehelp(str+"(",left-1,right,list); if(right&gt;0) generatehelp(str+")",left,right-1,list); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode17-电话号码的字母组合]]></title>
    <url>%2F2020%2F03%2F12%2FLeetCode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解题思路自己想到了用很多层的循环，但就是没想到用递归。 别人的解题思路 1234567891011121314151617181920212223242526class Solution &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); String [] str=&#123; "","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz" &#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; if(digits.length()==0) return list; String s=""; combinationhelp(digits,0,s); return list; &#125; public void combinationhelp(String digits,int index,String s) &#123; if(index==digits.length())//递归终止条件 &#123; list.add(s); return; &#125; int number=digits.charAt(index)-'0'; for(int i=0; i&lt;str[number].length(); i++) &#123; combinationhelp(digits,index+1,s+str[number].charAt(i)); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode12-整数转罗马数字]]></title>
    <url>%2F2020%2F03%2F12%2FLeetCode12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 12输入: 3输出: &quot;III&quot; 示例 2: 12输入: 4输出: &quot;IV&quot; 示例 3: 12输入: 9输出: &quot;IX&quot; 示例 4: 12输入: 58输出: &quot;LVIII&quot; 示例 5: 123输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路这道题利用贪心算法，真的很简单，很感谢解题思路，给定的数尽可能减去较大的数，这些数包括： 阿拉伯数字 罗马数字 1000 M 900 CM 500 D 400 CD 100 C 90 XC 50 L 40 XL 10 X 9 IX 5 V 4 IV 1 I 例如6：6先减去1000，不够减，再减900，不够减，一直减到5，够减，6-5=1，1减5不够减，1减4不够减，1减1等于0，那么6的罗马数字为vI。 123456789101112131415161718class Solution &#123; public String intToRoman(int num) &#123; int [] nums=&#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String [] string=&#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; StringBuilder builder=new StringBuilder(); int index=0; while(num&gt;0) &#123; while(num&gt;=nums[index]) &#123; num=num-nums[index]; builder.append(string[index]); &#125; index++; &#125; return builder.toString(); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode680-验证回文字符串II]]></title>
    <url>%2F2020%2F03%2F12%2FLeetCode680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2II%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 12输入: &quot;aba&quot;输出: True 示例 2: 123输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解题思路这道题自己又想复杂了，直接双指针法就行了，前指针i，后指针j，遇到不相等的字符i++或者j–，在后面的比较如果不相等，就返回false。 123456789101112131415161718192021222324252627282930313233//自己开始写的代码class Solution &#123; public boolean validPalindrome(String s) &#123; int i=0;//起始坐标 int j=s.length()-1;//末尾坐标 boolean flag=false; while(i&lt;j) &#123; if(s.charAt(i)!=s.charAt(j)&amp;&amp;s.charAt(i)==s.charAt(j-1)&amp;&amp;flag==false) &#123; j--; flag=true;//删除了一个字符 &#125; else if(s.charAt(i)!=s.charAt(j)&amp;&amp;s.charAt(i+1)==s.charAt(j)&amp;&amp;flag==false) &#123; i++; flag=true; &#125; else if(s.charAt(i)==s.charAt(j)) &#123; i++; j--; &#125; else if(s.charAt(i)!=s.charAt(j)&amp;&amp;flag==true)&#123;//不相等 break; &#125; &#125; if(i==j) return true; else return false; &#125;&#125; 正确代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean validPalindrome(String s) &#123; int i=0;//起始坐标 int j=s.length()-1;//末尾坐标 while(i&lt;j) &#123; if(s.charAt(i)!=s.charAt(j)) &#123; return judge(s,i+1,j)||judge(s,i,j-1); &#125; else &#123; i++; j--; &#125; &#125; return true; &#125; public boolean judge(String s,int i,int j) &#123; while(j&gt;i) &#123; if(s.charAt(i)!=s.charAt(j)) &#123; return false; &#125; else &#123; i++; j--; &#125; &#125; return true; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode551-学生出勤记录I]]></title>
    <url>%2F2020%2F03%2F11%2FLeetCode551-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95I%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符： ‘A’ : Absent，缺勤‘L’ : Late，迟到‘P’ : Present，到场如果一个学生的出勤记录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。 你需要根据这个学生的出勤记录判断他是否会被奖赏。 示例 1: 12输入: &quot;PPALLP&quot;输出: True 示例 2: 12输入: &quot;PPALLL&quot;输出: False 接替思路这道题主要是理解题意，不超过两个连续的’L’(迟到),指LLL将不会被奖赏，但是LLALL将会被奖赏。 12345678910111213141516171819class Solution &#123; public boolean checkRecord(String s) &#123; int absent=0; int late=0;//记录是否有连续迟到 int present=0; for(int i=0; i&lt;s.length(); i++) &#123; if(s.charAt(i)=='A') absent++; else if(i+2&lt;s.length()&amp;&amp;s.charAt(i)=='L'&amp;&amp;s.charAt(i+1)=='L'&amp;&amp;s.charAt(i+2)=='L') late=1; else if(s.charAt(i)=='P') present++; &#125; if(absent&lt;=1&amp;&amp;late&lt;1) return true; return false; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode521-最长特殊序列I]]></title>
    <url>%2F2020%2F03%2F11%2FLeetCode521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97I%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。 子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。 输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。 示例 : 123输入: &quot;aba&quot;, &quot;cdc&quot;输出: 3解析: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;) 说明: 两个字符串长度均小于100。字符串中的字符仅含有 ‘a’~’z’。 解题思路这道题自己想复杂了！如果两个字符串的长度不相等，则最长的子序列就是长的字符串，如果两个字符串的长度相等，内容相同，就返回-1，内容不相同，返回任何一个字符串即可。 12345678910class Solution &#123; public int findLUSlength(String a, String b) &#123; if(a.equals(b)) return -1; if(a.length()&gt;b.length()) return a.length(); else return b.length(); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode459-重复的子字符串]]></title>
    <url>%2F2020%2F03%2F11%2FLeetCode459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 示例 1: 123输入: "abab"输出: True解释: 可由子字符串 "ab" 重复两次构成。 示例 2: 12输入: "aba"输出: False 示例 3: 123输入: "abcabcabcabc"输出: True解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。) 解题思路参考了这篇文章 如果您的字符串S包含一个重复的子字符串，那么这意味着您可以多次“移位和换行”您的字符串，并使其与原始字符串匹配。例如:abcabc转变:cabcab改变两次:bcabca改变三次:abcabc 现在字符串和原字符串匹配了，所以可以得出结论存在重复的子串 为了避免这种无用的环绕，可以创建一个新的字符串str,它等于原来的字符串S再加上S自身，这样其实就包含了所有移动的字符串。 比如字符串：S = acd，那么str = S + S = acdacd acd移动的可能：dac、cda。其实都包含在了str中了。就像一个滑动窗口 一开始acd (acd) ，移动一次ac(dac)d,移动两次a(cda)cd。循环结束 所以可以直接判断str中去除首尾元素之后，是否包含自身元素。如果包含。则表明存在重复子串。 1234567class Solution &#123; public boolean repeatedSubstringPattern(String s) &#123; String str=s+s; int len=str.length(); return str.substring(1,len-1).contains(s); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode443-压缩字符串]]></title>
    <url>%2F2020%2F03%2F10%2FLeetCode443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。 示例 1： 输入：[“a”,”a”,”b”,”b”,”c”,”c”,”c”] 输出：返回6，输入数组的前6个字符应该是：[“a”,”2”,”b”,”2”,”c”,”3”] 说明：“aa”被”a2”替代。”bb”被”b2”替代。”ccc”被”c3”替代。示例 2： 输入：[“a”] 输出：返回1，输入数组的前1个字符应该是：[“a”] 说明：没有任何字符串被替代。示例 3： 输入：[“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”] 输出：返回4，输入数组的前4个字符应该是：[“a”,”b”,”1”,”2”]。 说明：由于字符”a”不重复，所以不会被压缩。”bbbbbbbbbbbb”被“b12”替代。注意每个数字在数组中都有它自己的位置。注意： 所有字符都有一个ASCII值在[35, 126]区间内。1 &lt;= len(chars) &lt;= 1000。 解题思路使用双指针法，start记录起始的下标，write记录写的坐标。如果遍历到字符串的末尾或者下一个字符和下标start记录的字符不同时，就要进行相应的记录。i-start+1为当前连续字符的长度，遍历结束后write的大小为字符的长度。 1234567891011121314151617181920212223class Solution &#123; public int compress(char[] chars) &#123; int len=chars.length; // 采用双指针法，简单明了 int start=0,write=0; for(int i=0; i&lt;len; i++) &#123; if(i+1==len||chars[i+1]!=chars[i])//下一个到字符串末尾或者和当前的字符不同时 &#123; chars[write++]=chars[i]; if(i&gt;start)//记录对应字符出现的次数 &#123; for(char c:String.valueOf(i-start+1).toCharArray()) &#123; chars[write++]=c; &#125; &#125; start=i+1; &#125; &#125; return write; &#125;&#125; 注意点12for(char c:String.valueOf(i-start+1).toCharArray());//把数字转换成字符数组，并进行遍历String.valueOf(i-start+1);//把数字转换成字符串，是valueOf函数]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode345-反转字符串中的元音字母]]></title>
    <url>%2F2020%2F03%2F09%2FLeetCode345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 12输入: &quot;hello&quot;输出: &quot;holle&quot; 示例 2: 12输入: &quot;leetcode&quot;输出: &quot;leotcede&quot; 说明:元音字母不包含字母”y”。 解题思路开始把题目看错了，我以为是把i和len-i-1位置上的元音字母对调，然后我把0打错成o了，难怪搞了半天没搞出来！！ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; String str="aeiou"; public String reverseVowels(String s) &#123; char [] sum=s.toCharArray(); int len=sum.length; int i=0,j=len-1; while(j&gt;i) &#123; if(!judges(sum[i])&amp;&amp;!judges(sum[j]))//两个都不是元音字母 &#123; i++; j--; &#125; else if(judges(sum[i])&amp;&amp;judges(sum[j]))//两个都是元音字母 &#123; char temp=sum[i]; sum[i]=sum[j]; sum[j]=temp; i++; j--; &#125; else if(!judges(sum[i])&amp;&amp;judges(sum[j]))//右边是元音字母 &#123; i++; &#125; else if(judges(sum[i])&amp;&amp;!judges(sum[j]))//左边是元音字母 &#123; j--; &#125; &#125; String newstr=new String(sum);//将char[]转换成String类型 return newstr; &#125; public boolean judges(char c) &#123; if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'||c=='A'||c=='E'||c=='I'||c=='O'||c=='U') return true; return false; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode125-验证回文串]]></title>
    <url>%2F2020%2F03%2F08%2FLeetCode125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true示例 2: 输入: “race a car”输出: false 解题思路新的知识点就是将大写字母转换成小写字母的函数，toLowerCase函数， 将小写转化成大写的函数，toUpperCase函数 12345678910111213141516171819202122class Solution &#123; public boolean isPalindrome(String s) &#123; if(s.length()==0) return true; s=s.toLowerCase();//将大写转化小写 String str=""; for(int i=0; i&lt;s.length(); i++) &#123; if((s.charAt(i)&gt;='a'&amp;&amp;s.charAt(i)&lt;='z')||(s.charAt(i)&gt;='0'&amp;&amp;s.charAt(i)&lt;='9')) str+=s.charAt(i); &#125; int len=str.length(); if(len==0) return true; for(int i=0; i&lt;=len/2; i++) &#123; if(str.charAt(i)!=str.charAt(len-1-i)) return false; &#125; return true; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode58-最后一个单词的长度]]></title>
    <url>%2F2020%2F03%2F08%2FLeetCode58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。 示例: 12输入: &quot;Hello World&quot;输出: 5 解题思路从前往后解这道题不好解，但是从后往前遍历，比较好解决。 第一种：”Hello World”这种从后往前遍历，遍历到空格为止，最后一个单词的长度为5。 第二种：”Hello World “先跳过最后一个空格，记录第一个不为” “的下标，然后继续往前遍历，遍历到空格为止，记录这个下标，最后一个单词的长度就是这两个下标相减。 123456789101112131415class Solution &#123; public int lengthOfLastWord(String s) &#123; if(s.length()==0) return 0; int end=s.length()-1; while(end&gt;=0&amp;&amp;s.charAt(end)==' ') end--; int start=end; while(start&gt;=0&amp;&amp;s.charAt(start)!=' ') &#123; start--; &#125; return end-start; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode28-实现strStr()]]></title>
    <url>%2F2020%2F03%2F08%2FLeetCode28-%E5%AE%9E%E7%8E%B0strStr%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = “hello”, needle = “ll”输出: 2示例 2: 输入: haystack = “aaaaa”, needle = “bba”输出: -1说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解题思路一这是我开始的想法，用两层for循环，查找haystack中是否有needle的字串，但是这样做起来，有很多的条件，很容易出错，代码如下 12345678910111213141516171819202122232425262728class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle.length()==0||haystack.equals(needle)) return 0; if(needle.length()&gt;haystack.length()) return -1; int len=haystack.length(); for(int i=0; i&lt;len; i++) &#123; boolean flag=true; int j=0; for(j=0; j&lt;needle.length(); j++) &#123; //比较的下标超界或者对应的字符不相等 if((i+j)&gt;=len||needle.charAt(j)!=haystack.charAt(i+j)) &#123; flag=false; break; &#125; &#125; if(flag==true&amp;&amp;j==needle.length())//j遍历到了末尾 &#123; return i; &#125; &#125; return -1; &#125;&#125; 解题思路二采用双指针法 12345678910111213141516171819202122class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle.length()==0||haystack.equals(needle)) return 0; int i=0,j=0; while(i&lt;haystack.length()) &#123; if(haystack.charAt(i++)==needle.charAt(j)) &#123; j++; &#125; else &#123; i=i-j; j=0; &#125; if(j==needle.length()) return i-j; &#125; return -1; &#125;&#125; 做LeetCode注意点要先执行代码，然后再提交，不然修改的代码，直接提交，提交的还是之前的代码。]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode20-有效的括号]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目描述自己想到了用栈去解决，但是就是不知道怎么写代码，自己真的太菜了。主要要判断读到的是左括号还是右括号，如果是左括号，则进栈，如果是右括号，则要判断栈顶的元素是否和这个符号是否匹配，匹配就把栈顶元素出栈，不匹配就返回false。 123456789101112131415161718192021222324252627282930class Solution &#123; Stack &lt;Character&gt; stack=new Stack&lt;&gt;(); public boolean isValid(String s) &#123; int len=s.length(); for(int i=0; i&lt;len; i++) &#123; if(s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='&#123;') stack.push(s.charAt(i)); else &#123; char temp=s.charAt(i); if(!stack.isEmpty()) &#123; char stackout=stack.peek(); if(stackout=='('&amp;&amp;temp==')') stack.pop(); else if(stackout=='['&amp;&amp;temp==']') stack.pop(); else if(stackout=='&#123;'&amp;&amp;temp=='&#125;') stack.pop(); else return false; &#125; else return false; &#125; &#125; return stack.isEmpty(); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode14-最长公共前缀]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。说明: 所有输入只包含小写字母 a-z 。 解题思路最长公共前缀就是在字符串中找到最短的字符串。例如最短的字符串为”abcd”,它的前缀有a，ab，abc，abcd。判断前缀是否是其他的字符串的最长公共前缀。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs.length==0) return ""; int minlen=strs[0].length(); String Minstr=strs[0]; for(int i=1; i&lt;strs.length; i++) &#123; if(strs[i].length()&lt;minlen) &#123; Minstr=strs[i]; minlen=strs[i].length(); &#125; &#125; int index=Minstr.length(); while(index&gt;0) &#123; String subs=Minstr.substring(0,index); boolean flag=true; for(int i=0; i&lt;strs.length; i++) &#123; if(strs[i].startsWith(subs)==false) &#123; flag=false; break; &#125; &#125; if(flag) &#123; break; &#125; index--; &#125; return Minstr.substring(0,index); &#125;&#125; 注意点123String [] str的长度为str.length;判断字符串str是否是"abc"开头str.startsWith("abc");是的话返回true，否则返回false]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode面试题59—-II.队列的最大值]]></title>
    <url>%2F2020%2F03%2F07%2FLeetCode%E9%9D%A2%E8%AF%95%E9%A2%9859%E2%80%94-II-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例 1： 1234输入: [&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[1],[2],[],[],[]]输出: [null,null,null,2,1,2] 示例 2： 1234输入: [&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[],[]]输出: [null,-1,-1] 限制： 121 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 100001 &lt;= value &lt;= 10^5 解题思路由题意知道总操作数为10000，可以开两个数组模拟队列的入队和出队，以及队列的最大值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MaxQueue &#123; int []queue; int queuehead=0; int queuetail=0; int [] Maxqueue; int Maxqueuehead=0; int Maxqueuetail=0; public MaxQueue() &#123; queue=new int[10000]; Maxqueue=new int[10000]; &#125; public int max_value() &#123; if(Maxqueuehead==Maxqueuetail)//队头和队尾的指针相等 return -1; return Maxqueue[Maxqueuehead]; &#125; public void push_back(int value) &#123; queue[queuetail++]=value; while(Maxqueuehead!=Maxqueuetail&amp;&amp;Maxqueue[Maxqueuetail-1]&lt;value)//最大队不为空，插入这个数大于队头的数 &#123; Maxqueuetail--; &#125; Maxqueue[Maxqueuetail++]=value; &#125; public int pop_front() &#123; if(queuehead==queuetail) return -1; int res=queue[queuehead++]; //最大队列中下标的变化,如果出的最大值，最大队列的队首下标要进行变化 if(res==Maxqueue[Maxqueuehead]) &#123; Maxqueuehead++; &#125; return res; &#125;&#125;/** * Your MaxQueue object will be instantiated and called as such: * MaxQueue obj = new MaxQueue(); * int param_1 = obj.max_value(); * obj.push_back(value); * int param_3 = obj.pop_front(); */]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode面试题57-II.和为s的连续正数序列]]></title>
    <url>%2F2020%2F03%2F06%2FLeetCode%E9%9D%A2%E8%AF%95%E9%A2%9857-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例 1： 12输入：target = 9输出：[[2,3,4],[4,5]] 示例 2： 12输入：target = 15输出：[[1,2,3,4,5],[4,5,6],[7,8]] 限制： ​ 1 &lt;= target &lt;= 10^5 解题思路这道题使用双指针法，这道题的难点是我不会List &lt;int []&gt; a=new ArrayList&lt;&gt;();左指针i，右指针j，使用等差数列的求和公式，比较和目标值的大小 小于目标值，则右指针右移 大于目标值，则左指针右移 等于目标值，则左右指针右移 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int[][] findContinuousSequence(int target) &#123; int i=1; int j=2; // int index=0; List &lt;int []&gt; list=new ArrayList&lt;&gt;(); while(i&lt;j) &#123; int sum=(i+j)*(j-i+1)/2; if(sum&lt;target)//和小于给定值，右指针右移 &#123; j++; &#125; else if(sum&gt;target)//和大于给定值时，走指针右移 &#123; i++; &#125; else//如果相等，左右指针右移 &#123; int [] a=new int[j-i+1]; for(int k=i; k&lt;=j; k++) &#123; a[k-i]=k; &#125; list.add(a); i++; j++; &#125; &#125; return list.toArray(new int[0][]); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的启动和登录]]></title>
    <url>%2F2020%2F03%2F05%2FMySQL%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[MySQL服务的启动和停止1234方式一：计算机——右击管理——服务方式二：通过管理员身份运行net start 服务名（启动服务）net stop 服务名（停止服务） MySQL服务的登录和退出123456789方式一：通过mysql自带的客户端只限于root用户方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C MySQL的常见命令12345678910111213141516171.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名( 列名 列类型, 列名 列类型， 。。。);6.查看表结构desc 表名; 12345建表：create table account（id int primary key auto_increment,name varchar(40),money float)character set utf8 collate utf8_general_ci; 1234插入值：insert into account(name,monkey) values(&apos;aaa&apos;,1000);insert into account(name,monkey) values(&apos;bbb&apos;,2000);insert into account(name,monkey) values(&apos;ccc&apos;,3000); 建表 1234567CREATE TABLE `user`( `id` int(20) AUTO_INCREMENT PRIMARY KEY , `username` varchar(32) NOT NULL COMMENT &apos;用户名称&apos;, `birthday` datetime NOT NULL COMMENT &apos;生日&apos;, `sex` char(1) DEFAULT NULL COMMENT &apos;性别&apos;, `address` varchar(256) DEFAULT NULL COMMENT &apos;地址&apos;) ENGINE=InnoDB DEFAULT CHARSET=utf8 ; 12insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,&apos;老王&apos;,&apos;2018-08-08 12:12:12&apos;,&apos;男&apos;,&apos;北京&apos;);insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (33,&apos;老张&apos;,&apos;2013-08-08 12:12:12&apos;,&apos;男&apos;,&apos;广州&apos;),(51,&apos;老凌&apos;,&apos;2017-08-08 12:12:12&apos;,&apos;男&apos;,&apos;河南&apos;),(22,&apos;老孙&apos;,&apos;2012-08-08 12:12:12&apos;,&apos;男&apos;,&apos;纽约&apos;),(21,&apos;小丽&apos;,&apos;2016-08-08 12:12:12&apos;,&apos;女&apos;,&apos;上海&apos;),(31,&apos;老李&apos;,&apos;2017-08-08 12:12:12&apos;,&apos;男&apos;,&apos;娄底&apos;);]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2020%2F03%2F05%2FSpring%2F</url>
    <content type="text"><![CDATA[1.框架：高度抽取可重用代码的一种设计，高度的通用性。 2.Spring框架容器（可以管理所有的组件（类））框架； 核心关注：IOC和AOP； 2.1 IOCIOC:控制反转的缩写，把创建对象的权利交给框架，是框架的重要特征，并非面对对象编程的重要术语。 明确ioc的作用： ​ 削剪计算机程序的耦合，即解除我们代码中的依赖关系。 1234ApplicationContext的三个常用实现类： ClassPathXmlApplicationContext,它可以加载类路径下的配置文件，要求配置文件必须在类路径下，不在的话，加载不了 FileSystemXmlApplicationContext,它可以加载磁盘任意文件(必须有访问权限) AnnotationConfigApplicationContext,它是用于读取注解创建容器的。 12345核心容器的两个接口引出的问题ApplicationContext:单例对象适用，在实际开发采用此接口 它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建文件中配置的对象。BeanFactory:多例对象适用 它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。 3.创建bean的三种方式第一种方式，使用默认构造函数创建 在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。 采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建. 1&lt;bean id="accountService" class="service.Impl.AccountServiceImpl"&gt;&lt;/bean&gt; 12345678910111213import service.IAccountService;/** * 账户业务层实现类 */public class AccountServiceImpl implements IAccountService &#123;// private IAccountDao accountDao =(IAccountDao) BeanFactory.getBean("accountDao"); public AccountServiceImpl()&#123; System.out.println("对象创建了"); &#125; public void saveAccount()&#123; System.out.println("service中的saveAccount执行了。。。"); &#125;;&#125; 1234public interface IAccountService &#123;// 模拟保存 void saveAccount();&#125; 12345678910111213141516171819package UI;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import service.IAccountService;/** * 模拟表现层，调用业务层 */public class client &#123;// 获取spring的ioc容器，并根据id获取对象 public static void main(String[] args) &#123;// 获取核心容器对象 ApplicationContext ac=new ClassPathXmlApplicationContext("bean.xml");// 根据id获取对象 IAccountService as=(IAccountService) ac.getBean("accountService"); //IAccountService as=new AccountServiceImpl(); //IAccountService as=(IAccountService) BeanFactory.getBean("accountService"); as.saveAccount(); &#125;&#125; ​ 第二种方式，使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器. 12&lt;bean id="instanceFactory" class="factory.InstanceFactory"&gt;&lt;/bean&gt;&lt;bean id="accountService" factory-bean="instanceFactory" factory-method="getAccountService"&gt;&lt;/bean&gt; 12345public class InstanceFactory &#123; public IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;;&#125; 第三种方式，使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象，并存入spring容器. 1&lt;bean id="accountService" class="factory.StaticFactory" factory-method="getAccountService"&gt;&lt;/bean&gt; 12345public class StaticFactory &#123; public static IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;;&#125; 4.bean的作用范围bean标签的scope属性： ​ 作用，用于指定bean的作用范围 ​ 取值： ​ singleton：单例的（默认值） ​ prototype:多例的 ​ request：作用于web应用的请求范围 ​ session：作用于web应用的会话范围 ​ global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session 1&lt;bean id="accountService" class="service.Impl.AccountServiceImpl" scope="prototype"&gt;&lt;/bean&gt; 5.bean的生命周期​ 单例对象 ​ 出生：当容器创建时对象出生 ​ 活着：只要容器还在，对象一直活着 ​ 死亡：容器销毁，对象消亡 ​ 总结：单例对象的生命周期和容器相同 ​ 多例对象 ​ 出生: 当我们使用对象时，spring框架为我们创建 ​ 活着：对象只要是在使用过程中就一直活着 ​ 死亡：当对象长时间不用，且没有别的对象，由Java的垃圾回收器回收 6.依赖注入spring中的依赖注入 依赖注入： ​ Dependency Injection ​ IOC的作用：降低程序的耦合性（依赖关系） ​ 依赖关系的管理：以后都交给spring来维护 ​ 在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明依赖关系的维护，就称之为依赖注入。 ​ 依赖注入: ​ 能注入的类型，有三类 ​ 基本类型和String ​ 其他bean类型（在配置文件中或者注解配置过的bean） ​ 复杂类型/集合类型 ​ 注入的方式：有三种 ​ 第一种：使用构造函数提供 ​ 第二种：使用set方法提供 ​ 第三种：使用注解提供 6.1构造函数注入12345678910 构造函数注入 使用的标签：constructor-arg 标签出现的位置：bean标签的内部 标签中的属性 type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型 index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置是从0开始 name：用于指定给构造函数中指定名称的参数赋值（常用）===========以上三个用于指定给构造函数中哪个参数赋=============== value:用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据，它指的就是在spring的Ioc核心容器中出现过的bean对象 12345678&lt;bean id="accountService" class="service.Impl.AccountServiceImpl"&gt; &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="name" value="test"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;!-- 配置一个日期对象--&gt; &lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 优势：在获取bean对象时，注入数据是必须的操作，否则无法创建成功 弊端：改变了bean对象的实例化方式，是我们在创建对象时，如果用不到这些数据，也必须提供 6.2 set方法注入12345678set方法注入（更常用） 涉及的标签：property 出现的位置：bean标签的内部 标签的属性：name：用于指定注入时所调用的set方法名称 value:用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据，它指的就是在spring的Ioc核心容器中出现过的bean对象优势：创建对象时没有明确的限制，可以直接使用默认构造函数弊端：如果有某个成员必须有值，则获取对象是有可能set方法没有执行 12345&lt;bean id=&quot;accountService2&quot; class=&quot;service.Impl.AccountServiceImpl2&quot;&gt; &lt;property name=&quot;useName&quot; value=&quot;test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;19&quot;&gt;&lt;/property&gt; &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 1234567891011121314151617181920212223public class AccountServiceImpl2 implements IAccountService &#123;// private IAccountDao accountDao =(IAccountDao) BeanFactory.getBean("accountDao");// private String name; private Integer age; private Date Birthday; public void setUseName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; Birthday = birthday; &#125; public void saveAccount()&#123; System.out.println("service中的saveAccount执行了。。。"+name+","+age+","+Birthday); &#125;;&#125; 123456789101112public class client &#123;// 获取spring的ioc容器，并根据id获取对象 public static void main(String[] args) &#123;// 获取核心容器对象 ApplicationContext ac=new ClassPathXmlApplicationContext("bean.xml");// 根据id获取对象 IAccountService as=(IAccountService) ac.getBean("accountService2"); //IAccountService as=new AccountServiceImpl(); //IAccountService as=(IAccountService) BeanFactory.getBean("accountService"); as.saveAccount(); &#125;&#125; 6.3 复杂类型注入1234复杂类型的注入/集合类型的注入 用于给List结构集合注入的标签： list array set 用于给Map结构集合注入的标签： map props 结构相同，标签可以互换 1234567891011121314151617181920212223242526272829303132333435363738&lt;bean id="accountService3" class="service.Impl.AccountServiceImpl3"&gt; &lt;property name="mystrs"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="mylist"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="mySet"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="mymap"&gt; &lt;map&gt; &lt;entry key="testa" value="aaa"&gt;&lt;/entry&gt; &lt;entry key="testb"&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="myProps"&gt; &lt;props&gt; &lt;prop key="testc"&gt;ccc&lt;/prop&gt; &lt;prop key="testd"&gt;ddd&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839public class AccountServiceImpl3 implements IAccountService &#123;// private IAccountDao accountDao =(IAccountDao) BeanFactory.getBean("accountDao");// private String [] mystrs; private List&lt;String&gt; mylist; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; mymap; private Properties myProps; public void setMystrs(String[] mystrs) &#123; this.mystrs = mystrs; &#125; public void setMylist(List&lt;String&gt; mylist) &#123; this.mylist = mylist; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMymap(Map&lt;String, String&gt; mymap) &#123; this.mymap = mymap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; public void saveAccount()&#123; System.out.println(Arrays.toString(mystrs)); System.out.println(mylist); System.out.println(mySet); System.out.println(mymap); System.out.println(myProps); &#125;;&#125; 1234567891011public class client &#123;// 获取spring的ioc容器，并根据id获取对象 public static void main(String[] args) &#123;// 获取核心容器对象 ApplicationContext ac=new ClassPathXmlApplicationContext("bean.xml");// 根据id获取对象 IAccountService as=(IAccountService) ac.getBean("accountService3");//s后面是bean文件对应id的值 //IAccountService as=new AccountServiceImpl(); //IAccountService as=(IAccountService) BeanFactory.getBean("accountService"); as.saveAccount(); &#125; 7 基于注解的IOC配置7.1 明确​ 即注解配置和xml配置要实现的功能都是一样的，都是要降低程序的耦合，只是配置的形式不一样。 123456789101112131415161718192021222324曾经XML的配置 &lt;bean id="accountService" class="service.Impl.AccountServiceImpl" scope="", init-method="", destroy-method=""&gt; &lt;property name="" value=""|ref=""&gt;&lt;/property&gt; &lt;/bean&gt; 用于创建对象的:他们的作用就和在XML配置文件中编写一个&lt;bean&gt;标签实现的功能是一样的 @Component: 作用：用于把当前对象存入spring容器中 属性： value：用于指定bean的id，当我们不写时，它的默认值是当前类名，且首字母小写 @Controller：一般用在表现层 @Service：一般用在业务层 @Repository：一般用在持久层 以上三个注解他们的作用和属性Component是一模一样的。 他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰 用于注入数据的：他们的作用就和在XML配置文件中编写一个&lt;property&gt;标签实现的功能是一样的 @Autowired: 作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功，如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。如果ioc容器中有多个类型匹配时 出现位置：可以是变量上，也可以是方法上 细节：在使用注解注入时，set方法就不是必须的了 用于改变作用范围的：他们的作用就和在bean标签中使用scope属性实现的功能是一样的 和生命周期相关：他们的作用就和在bean标签中使用init-method和destory-method方法是一样的 1234567891011121314&lt;--bean.xml文件--!&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的标签中，而是一个名称为context名称空间和约束中--&gt; &lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 1234567891011121314151617181920212223242526272829303132//AccountServiceImpl文件package com.service.Impl;import com.dao.IAccountDao;import com.dao.Impl.AccountDaoImpl;//import factory.BeanFactory;import org.springframework.stereotype.Component;import service.IAccountService;/** * @author shkstart * @create 2020-03-06 11:57 * 账户业务层实现类 * 曾经XML的配置 * &lt;bean id="accountService" class="service.Impl.AccountServiceImpl" * scope="", init-method="", destroy-method=""&gt; * &lt;property name="" value=""|ref=""&gt;&lt;/property&gt; * &lt;/bean&gt; * * 用于创建对象的:他们的作用就和在XML配置文件中编写一个&lt;bean&gt;标签实现的功能是一样的 * 用于注入数据的：他们的作用就和在XML配置文件中编写一个&lt;property&gt;标签实现的功能是一样的 * 用于改变作用范围的：他们的作用就和在bean标签中使用scope属性实现的功能是一样的 * 和生命周期相关：他们的作用就和在bean标签中使用init-method和destory-method方法是一样的 */@Componentpublic class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl();// private IAccountDao accountDao =(IAccountDao) BeanFactory.getBean("accountDao"); public void saveAccount()&#123; accountDao.saveAccount(); &#125;;&#125; 1234567891011121314151617181920212223package com.UI;//import factory.BeanFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import service.IAccountService;/** * @author shkstart * @create 2020-03-06 12:15 * 模拟表现层，调用业务层 */public class client &#123;// 获取spring的ioc容器，并根据id获取对象 public static void main(String[] args) &#123;// 获取核心容器对象 ApplicationContext ac=new ClassPathXmlApplicationContext("bean.xml");// 根据id获取对象 IAccountService as=(IAccountService) ac.getBean("accountServiceImpl"); System.out.println(as); //as.saveAccount(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839* spring中的新注解* @Configuration* 作用：指定当前类是一个配置类* 细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。* @ComponentScan* 作用：用于通过注解指定spring在创建容器时要扫描的包* 属性：* value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包* 我们使用此注解就等同于在xml中配置了：* &lt;!-- 告知spring在创建容器要扫描的包--&gt;* &lt;context:component-scan base-package=&quot;com&quot;&gt;&lt;/context:component-scan&gt;** @Bean* 作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中* 属性：用于指定bean的id，当不写时，默认值是当前方法的名称* 细节：* 当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。* 查找的方式和Autowired注解的作用是一样的* @Import* 作用：用于导入其他的配置类 属性： value：用于指定其他配置类的字节码 当我们使用Import的注解之后，有Import注解的类就是父配置类，而导入的都是子配置类。 @PropertySource（不重要） * 作用：用于指定properties文件的位置 * 属性： * value:指定文件的名称和路径 * 关键字：classpath:表示类路径下 使用Junit单元测试，测试我们的配置 Spring整合junit配置 1.导入Spring整合的junit的jar（坐标） 2.使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的@Runwith 3.告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置 @ContextConfiguration location:指定xml文件的位置，加上classpath关键字，表示在类路径下 classes：指定注解类所在位置 当我们使用spring 5.x版本的时候，要求junit的jar必须是4.12及以上 8.AOP8.1什么是AOPAOP是面向切面编程，简单的说，他就是把我们程序的重复代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。 8.2AOP的作用及优势作用：在程序运行期间，不修改源码对己有的方法进行增强。 优势： ​ 减少重复代码 ​ 提高开发效率 ​ 维护方便 8.3 AOP的实现方式使用动态代理技术 8.4spring中基于XML的AOP配置步骤1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!--配置spring的IOC，把service对象配置进来--&gt; &lt;bean id="accountService" class="com.service.Impl.AccountServiceImpl"&gt;&lt;/bean&gt;&lt;!-- spring中基于XML的AOP配置步骤 1.把通知Bean也交给spring来管理 2.使用aop:config标签表明开始AOP配置 3.使用aop:aspect标签表明配置切面 id属性：是给切面提供一个唯一标识 ref属性：是指定通知类bean的Id 4.在aop:aspect标签的内部使用对应标签来配置通知的类型 我们现在示例是让printLog方法在切入点方法执行之前，所以是前置通知 aop:before:表示配置前置通知 method属性：用于指定Logger类中哪个方法是前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 切入点表达式写法： 关键字：execution(表达式) 表达式： 访问修饰符 返回值 包名.包名.包名...类名.方法名（参数列表） 标准的表达式写法： public void com.service.Impl.AccountServiceImpl.saveAccount() 访问修饰符可以省略 void com.service.Impl.AccountServiceImpl.saveAccount() 返回值可以使用通配符，表示返回任意返回值 * com.service.Impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包，但是有几级包，就需要写几个*. *.*.*.*.AccountServiceImpl.saveAccount() 包名可以使用*..表示当前包及其字包 * *..AccountServiceImpl.saveAccount() 类名和方法名都可以使用*来实现通配 * *..*.*() 参数列表： 可以直接写数据类型： 基本类型直接写名称 int 引用类型写包名.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以..表示有无参数均可，有参数可以是任意类型 全通配写法 * *..*.*(..) 实际开发中切入点表达式的通常写法: 切到业务层实现类下的所有方法 * com.service.Impl.*.*(..) --&gt;&lt;!-- 配置Logger类--&gt; &lt;bean id="logger" class="com.utils.Logger"&gt;&lt;/bean&gt;&lt;!-- 配置aop--&gt; &lt;aop:config&gt;&lt;!-- 配置切面--&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt;&lt;!-- 配置通知的类型，并且建立通知方法和切入点方法的关联--&gt; &lt;aop:before method="printLog" pointcut="execution(public void com.service.Impl.AccountServiceImpl.saveAccount())"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 9 spring中的JdbcTemplateJdbcTemplate的作用：它就是用于和数据库交互的，实现对表的CRUD操作。 9.1 Spring事务控制我们要明确的第一： JavaEE体系进行分层开发，事务处理位于业务层，Spring提供了分层设计业务层的事务处理解决方案。 第二：spring框架为我们提供了一组事务控制的接口。这组接口是在spring-tx-5.0.2RELEASE.jar中。 第三：spring的事务控制都是基于AOP的。它既可以使用编程的方式实现，也可以使用配置的方式实现。我们学习的重点是使用配置的方式实现。 9.2 Spring中事务控制的API介绍PlatformTransactionManager真正管理事务的对象 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用SpringJDBC或IBatis进行持久化数据时使用]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode8-字符串转换成整数]]></title>
    <url>%2F2020%2F03%2F04%2FLeetCode8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4: 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−2^31) 。 解题思路以前做过类似的题，但是自己对溢出的判断不怎么熟悉了，今天又复习整数的溢出，我要吐槽这道题，真的烦，搞了几个小时，不是这里错，就是那里错，但是最后终于AC了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int myAtoi(String str) &#123; char [] c=str.toCharArray(); int i=0; int isnegative=1;//判断正负 for(i=0; i&lt;c.length; i++)//去掉前面的空格 &#123; if(c[i]==' ') continue; else if(c[i]=='+') &#123; isnegative=1; i++; break; &#125; else if(c[i]=='-') &#123; isnegative=-1; i++; break; &#125; else if(c[i]&lt;'0'||c[i]&gt;'9') return 0; else break; &#125; if(i==c.length)//字符串为空 return 0; int sum=0; for(int j=i; j&lt;c.length; j++) &#123; if(c[j]&gt;='0'&amp;&amp;c[j]&lt;='9') &#123; int temp=(c[j]-'0'); int overvulue=sum*isnegative;//用来判断是否溢出 if(isnegative==1) &#123; if(overvulue&gt;Integer.MAX_VALUE/10||(overvulue==Integer.MAX_VALUE/10&amp;&amp;temp&gt;7)) return Integer.MAX_VALUE; &#125; if(isnegative==-1) &#123; if(overvulue&lt;Integer.MIN_VALUE/10||(overvulue==Integer.MIN_VALUE/10&amp;&amp;temp&gt;8)) return Integer.MIN_VALUE; &#125; sum=sum*10+temp; &#125; else break; &#125; return sum*isnegative; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode994-腐烂的橘子]]></title>
    <url>%2F2020%2F03%2F04%2FLeetCode994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 解题思路利用队列解决，遍历二维数组，如果遍历到腐烂的橘子，则入队，判断该位置周围的位置是否有新鲜橘子，先自己出队，有则让他们腐烂，并让时间加1，让腐烂橘子入队，一直到队列为空，则结束。结束如果二维数组中有新鲜橘子，则返回-1，负责返回时间minute。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class position&#123; int x,y,minute; public position(int x1,int y1,int minute1) &#123; x=x1; y=y1; minute=minute1; &#125;&#125;class Solution &#123; public int orangesRotting(int[][] grid) &#123; int cols=grid.length;//行数 int rows=grid[0].length;//列数 Queue &lt;position&gt; s=new LinkedList&lt;position&gt;(); int minute=0; for(int i=0; i&lt;cols; i++) &#123; for(int j=0; j&lt;rows; j++) &#123; if(grid[i][j]==2) &#123; s.add(new position(i,j,minute));//队列是add入队 &#125; &#125; &#125; int [] dx=&#123;0,0,-1, 1&#125;; int [] dy=&#123;1, -1, 0, 0&#125;; while(!s.isEmpty()) &#123; position temp=s.poll(); for(int i=0; i&lt;4 ;i++) &#123; int tempx=temp.x+dx[i];//第几行 int tempy=temp.y+dy[i];//第几列 minute=temp.minute; if(tempx&gt;=0&amp;&amp;tempx&lt;cols&amp;&amp;tempy&gt;=0&amp;&amp;tempy&lt;rows&amp;&amp;grid[tempx][tempy]==1) &#123; grid[tempx][tempy]=2;//让该橘子腐烂 s.add(new position(tempx,tempy,temp.minute+1));//入队 &#125; &#125; &#125; //遍历结束后，判断二维数组是否有新鲜橘子 for(int i=0; i&lt;cols; i++) &#123; for(int j=0; j&lt;rows; j++) &#123; if(grid[i][j]==1)//还有新鲜的橘子，返回-1 return -1; &#125; &#125; return minute; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode6-Z字形变换]]></title>
    <url>%2F2020%2F03%2F04%2FLeetCode6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1: 12输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2: 12345678输入: s = "LEETCODEISHIRING", numRows = 4输出: "LDREOEIIECIHNTSG"解释:L D RE O E I IE C I H NT S G 解题思路这篇解题思路很好 遍历这个字符串，在遍历字符串的同时把字符填到正确的res[i]中。算法流程如下:按顺序遍历字符串； 1.res[i]+=c,把每个字符c放到对应的res[i]中 2.i+=flag，更新当前字符c对应的行索引 3.flag=-flag，即开始行和最后一行时，也就是Z字形转折点时，执行反向 123456789101112131415161718192021222324class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows&lt;2)//如果只有一行，直接返回 return s; List &lt;StringBuilder&gt; ans=new ArrayList&lt;StringBuilder&gt;(); for(int i=0; i&lt;numRows; i++) ans.add(new StringBuilder()); int i=0,flag=-1;//flag是这道题的解题的精髓 for(char c:s.toCharArray()) /* char[] cs = s.toCharArray(); for(int i=0;i&lt;cs.length;i++)&#123; char c = cs[i]; &#125; */ &#123; ans.get(i).append(c); if(i==0||i==numRows-1) flag=-flag; i+=flag; &#125; StringBuilder res=new StringBuilder(); for(StringBuilder temp : ans)//把ans[i]中的字符加到res后面 res.append(temp); return res.toString(); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5-最长回文子串]]></title>
    <url>%2F2020%2F03%2F03%2FLeetCode5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 解题思路这道题用动态规划，参考了这篇文章，重要的点，p(i,j)=true,则s[i,j]是回文串，p(i,j)=false,s[i,j]不是回文串，p(i,j)=(p(i+1,j-1)&amp;&amp;s[i]==s[j]),这个递推公式，长度为1，2要初始化。 12345678910111213141516171819202122232425262728class Solution &#123; public String longestPalindrome(String s) &#123; int len=s.length(); boolean [][] dp=new boolean [len][len]; String maxs=""; int maxlen=0; for(int i=1; i&lt;=len; i++)//字符串的长度 &#123; for(int start=0; start&lt;len; start++) &#123; int end=start+i-1; if(end&gt;=len)//尾下标出界 &#123; break; &#125; //长度为1和2的字符串单独判断 //其他长度靠公式推导 dp[start][end]=(i==1||i==2||dp[start+1][end-1])&amp;&amp;s.charAt(start)==s.charAt(end); if(dp[start][end]==true&amp;&amp;i&gt;maxlen) &#123; maxs=s.substring(start,end+1); maxlen=i; &#125; &#125; &#125; return maxs; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode3-无重复字符的最长子串]]></title>
    <url>%2F2020%2F03%2F03%2FLeetCode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串，请你找出其中不含有重复字符的 *最长子串 *的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路这道题利用滑动窗口，我们把字符串[i,j]的字符串保存到HashSet中，从左往右遍历，如果遍历到下标为j的字符不在HashSet中，则继续往右遍历，如果遍历到重复的字符，则找到i，到j的不重复字符串。 12345678910111213141516171819202122class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len=s.length(); Set &lt;Character&gt; set=new HashSet&lt;Character&gt;(); int ans=0,i=0,j=0; while(i&lt;len&amp;&amp;j&lt;len) &#123; if(!set.contains(s.charAt(j)))//HashSet中不包含这个字符 &#123; set.add(s.charAt(j)); j++; ans=Math.max(ans,j-i); &#125; else &#123; set.remove(s.charAt(i)); i++; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode445-两数相加II]]></title>
    <url>%2F2020%2F03%2F03%2FLeetCode445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 进阶: 如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。 示例: 12输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出: 7 -&gt; 8 -&gt; 0 -&gt; 7 解题思路我开始用的是把链表的数转化成数，把两个链表相加后的结果，然后在转化成链表，可是没想到大整数相加。这道题用栈很好解决。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; Stack &lt;Integer&gt; stack1=new Stack &lt;Integer&gt; (); Stack &lt;Integer&gt; stack2=new Stack &lt;Integer&gt; (); while(l1!=null) &#123; stack1.push(l1.val); l1=l1.next; &#125; while(l2!=null) &#123; stack2.push(l2.val); l2=l2.next; &#125; ListNode newHead=new ListNode(-1); ListNode p=newHead.next; int cout=0;//记录进位 while(!stack1.isEmpty()&amp;&amp;!stack2.isEmpty()) &#123; int temp1=stack1.pop(); int temp2=stack2.pop(); int s=temp1+temp2+cout; int value=s%10; cout=s/10; ListNode newp=new ListNode(value); newHead.next=newp; newp.next=p; p=newp; &#125; if(!stack1.isEmpty()) &#123; while(!stack1.isEmpty()) &#123; int temp1=stack1.pop(); int s=temp1+cout; int value=s%10; cout=s/10; ListNode newp=new ListNode(value); newHead.next=newp; newp.next=p; p=newp; &#125; &#125; if(!stack2.isEmpty()) &#123; while(!stack2.isEmpty()) &#123; int temp2=stack2.pop(); int s=temp2+cout; int value=s%10; cout=s/10; ListNode newp=new ListNode(value); newHead.next=newp; newp.next=p; p=newp; &#125; &#125; if(cout!=0) &#123; ListNode newp=new ListNode(cout); newHead.next=newp; newp.next=p; p=newp; &#125; return newHead.next; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode148-排序链表]]></title>
    <url>%2F2020%2F03%2F02%2FLeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路自己对归并排序原理还是理解的，但是对链表的归并排序没有写过，看了leetcode的题解后，自己写出了下面代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; if(head==null||head.next==null)//如果只有一个或者零个结点 return head; return HelpsortList(head); &#125; public ListNode HelpsortList(ListNode head) &#123; if(head==null||head.next==null)//如果字链表只有一个结点或者空链表，则返回字链表的头结点，这就是递归的出口 return head; ListNode slow=head,fast=head.next.next,l,r; while(fast!=null&amp;&amp;fast.next!=null)//将链表分成两半 &#123; slow=slow.next; fast=fast.next.next; &#125; //上面循环结束后，slow指针前一半链表的尾节点 l=HelpsortList(slow.next);//slow.next为右半链表的头结点,对右半边链表进行拆分 slow.next=null; r=HelpsortList(head); return mergesort(l,r);//对左右两边进行合并排序 &#125; public ListNode mergesort(ListNode l,ListNode r) &#123; ListNode head=new ListNode(-1); ListNode p=head; while(l!=null&amp;&amp;r!=null) &#123; if(l.val&lt;r.val) &#123; p.next=l; l=l.next; p=p.next; &#125; else &#123; p.next=r; r=r.next; p=p.next; &#125; &#125; if(l!=null) p.next=l; if(r!=null) p.next=r; return head.next;//返回真正的头节点 &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剪绳子]]></title>
    <url>%2F2020%2F02%2F26%2F%E5%89%AA%E7%BB%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 输入描述: 1输入一个数n，意义见题面。（2 &lt;= n &lt;= 60） 输出描述: 1输出答案。 解题思路用动态规划，当绳子长度为1时，最大乘积为0，当绳子长度为2时，最大乘积为1，当绳子长度为3时，最大乘积为2. 其余的用公式：f(n)=max(f(n-i)*f(i)),n≥i≥0 初始化：f(0)=0,f(1)=1,f(2)=2,f(3)=3; f(4)=f(2)*f(2)=4 f(5)=f(2)*f(3)=6 f(6)=f(3)*f(3)=9 f(7)=f(5)*f(2)=12 … 12345678910111213141516171819202122232425262728public class Solution &#123; public int cutRope(int target) &#123; if(target==1) return 0; if(target==2) return 1; if(target==3) return 2; int [] dp=new int[target+1]; dp[0]=0;//对应长度已经计算出来，这里初始化是为了下面的计算方便，长度大于等于4的计算 dp[1]=1; dp[2]=2; dp[3]=3; for(int i=4; i&lt;=target; i++) &#123; int maxs=0; for(int j=0; j&lt;=i/2; j++) &#123; if(maxs&lt;dp[j]*dp[i-j]) &#123; maxs=dp[j]*dp[i-j]; dp[i]=maxs; &#125; &#125; &#125; return dp[target]; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵中的路径]]></title>
    <url>%2F2020%2F02%2F25%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如$$\begin{matrix} a &amp; b &amp; c &amp; e \ s &amp; f &amp; c &amp; s \ a &amp; d &amp; e &amp; e \end{matrix}$$ 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解题思路这是走路径问题，需要判断每一个结点是否可以找到对应的路径，并且开一个和原矩阵一样大小的二维数组，用来标记对应位置是否被走过，如果走过置为1，如果该位置和路径中第一个字符相等，则分别向上，向下，向左，向右遍历，如果有符合的路径，则返回true，没有符合的路径，特别注意对应走过的位置要重新置为0，返回false。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; int [] [] visit=new int [rows+1][cols+1]; char [][] array=new char [rows+1][cols+1]; int cout=0; for(int i=0; i&lt;rows; i++) &#123; for(int j=0; j&lt;cols; j++) &#123; array[i][j]=matrix[i*cols+j]; &#125; &#125; for(int i=0; i&lt;rows; i++) &#123; for(int j=0; j&lt;cols; j++) &#123; if(searchpath(visit,array,rows,cols,str,i,j,0)==true) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean searchpath(int [][] visit,char [][] array,int rows,int cols,char [] str,int i,int j,int index) &#123; if(index==str.length) return true; if(i&lt;0||i&gt;=rows||j&lt;0||j&gt;=cols||array[i][j]!=str[index]||visit[i][j]==1)//一定先要判断是否越界 &#123; return false; &#125; visit[i][j]=1; boolean result=searchpath(visit,array,rows,cols,str,i+1,j,index+1)|| searchpath(visit,array,rows,cols,str,i,j+1,index+1)|| searchpath(visit,array,rows,cols,str,i-1,j,index+1)|| searchpath(visit,array,rows,cols,str,i,j-1,index+1); visit[i][j]=0;//注意点， return result; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据流中的中位数]]></title>
    <url>%2F2020%2F02%2F25%2F%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解题思路自己想的本来是开一个ArrayList数组，把整数加入到数组中，然后对数组进行排序，如果数组的长度是奇数个，那么中间那个就是我们想要的结果，如果数组的长度是偶数个，那么是中间两个的平均值。 12345678910111213141516171819202122import java.util.*;public class Solution &#123; ArrayList &lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); public void Insert(Integer num) &#123; list.add(num); &#125; public Double GetMedian() &#123; int len=list.size(); Collections.sort(list); if(len%2==1) &#123; return list.get(len/2)/1.0; &#125; else &#123; return (list.get(len/2-1)+list.get(len/2))/2.0; &#125; &#125;&#125; 思路二:参考了大佬的思路 利用最大堆和最小堆来实现，最大堆堆顶元素就是这堆的最大元素，最小堆堆顶元素就是这堆的最小元素。总要保证最大堆中元素和最小堆中的元素的数量不超过1.当第奇数个数要放到最大堆（如果插入的元素大于最小堆堆顶的元素，则最小堆堆顶元素插入最大堆，这个数插入最小堆），第偶数个数要放到最小堆（如果插入的元素小于最大堆堆顶的元素，则最大堆堆顶元素插入最小堆，这个数插入最大堆） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;public class Solution &#123; PriorityQueue&lt;Integer&gt; minheap=new PriorityQueue&lt;Integer&gt;(); PriorityQueue&lt;Integer&gt; maxheap=new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;()&#123; //@Override public int compare(Integer x,Integer y)&#123; return y-x; &#125; &#125;); public int cout=0; public void Insert(Integer num) &#123; cout++; if(cout%2==1)//加入最大堆 &#123; if(minheap.isEmpty()==false&amp;&amp;num&gt;minheap.peek()) &#123; int temp=minheap.poll(); minheap.add(num); maxheap.add(temp); &#125; else &#123; maxheap.add(num); &#125; &#125; else//放入最小堆 &#123; if(maxheap.isEmpty()==false&amp;&amp;num&lt;maxheap.peek()) &#123; int temp=maxheap.poll(); minheap.add(temp); maxheap.add(num); &#125; else &#123; minheap.add(num); &#125; &#125; &#125; public Double GetMedian() &#123; if(maxheap.size()==minheap.size()) &#123; return (minheap.peek()+maxheap.peek())/2.0; &#125; else &#123; return maxheap.peek()/1.0; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化二叉树]]></title>
    <url>%2F2020%2F02%2F25%2F%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 解题思路这道题第一次做，对自己来说还是很困难的，自己的字符串功底比较弱，加上递归，这道题做了很久。 首先是二叉树的前序遍历，二叉树的遍历，如果是空树，就加上”#！”，不是空树，就加上树的数值和”!” 第二步，利用字符串重新建立二叉树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.*;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; String Serialize(TreeNode root) &#123; if(root==null) return ""; StringBuffer s=new StringBuffer(); return helpSerialize(root,s).toString(); &#125; public StringBuffer helpSerialize(TreeNode root,StringBuffer s) &#123;//前序遍历 if(root==null) return s; s.append(root.val).append("!"); if(root.left!=null) &#123; helpSerialize(root.left,s); &#125; else &#123; s.append("#!"); &#125; if(root.right!=null) &#123; helpSerialize(root.right,s); &#125; else &#123; s.append("#!"); &#125; return s; &#125; public int index=0; TreeNode Deserialize(String str) &#123; if(str.length()==0) return null; String[] newstr=str.split("!"); return helpDeserialize(newstr); &#125; public TreeNode helpDeserialize(String [] newstr) &#123; if(newstr[index].equals("#")) &#123; index++; return null; &#125; TreeNode root=new TreeNode(Integer.valueOf(newstr[index])); index++; root.left=helpDeserialize(newstr); root.right=helpDeserialize(newstr); return root; &#125;&#125; 注意点1String[] newstr=str.split("!");//利用！作为分割点建立二维字符数组 1newstr[index].equals("#");//字符数组的比较，用的是equals函数 1Integer.valueOf(newstr[index]);//将字符数组newstr[index]转化成整数]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按之字形顺序打印二叉树]]></title>
    <url>%2F2020%2F02%2F24%2F%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路这道题其实就是二叉树的层序遍历，不过在层序遍历的基础上，加了一点难度，奇数行从左到右，偶数行从右到左。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.ArrayList;import java.util.Queue;import java.util.LinkedList;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; list=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue=new LinkedList&lt;TreeNode&gt;(); if(pRoot==null) return list; boolean flag=true; queue.offer(pRoot); while(queue.isEmpty()==false) &#123; int len=queue.size(); ArrayList&lt;Integer&gt; sublist=new ArrayList&lt;Integer&gt;(); for(int i=0; i&lt;len; i++) &#123; TreeNode p=queue.poll(); if(flag==true) &#123; sublist.add(p.val); &#125; else &#123; sublist.add(0,p.val); &#125; if(p.left!=null) queue.offer(p.left); if(p.right!=null) queue.offer(p.right); &#125; flag=!flag; list.add(sublist); &#125; return list; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称的二叉树]]></title>
    <url>%2F2020%2F02%2F24%2F%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解题思路自己知道用递归，就是不知道动手，看了别人的代码，恍然大悟！ 12345678910111213141516171819202122232425262728293031323334/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; if(pRoot==null) return true; return judgeIsSymmetrical(pRoot.left,pRoot.right); &#125; public boolean judgeIsSymmetrical(TreeNode p1,TreeNode p2) &#123; if(p1==null&amp;&amp;p2==null) return true; else if(p1==null||p2==null) return false; if(p1.val==p2.val) &#123; return judgeIsSymmetrical(p1.left,p2.right)&amp;&amp;judgeIsSymmetrical(p1.right,p2.left); &#125; else return false; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个结点]]></title>
    <url>%2F2020%2F02%2F24%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路每个结点都包含父节点的指针，则可以通过给定的结点找到根节点，然后通过根节点的中序遍历，找到给定结点的中序遍历的下一个结点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.ArrayList;/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;TreeLinkNode&gt; list=new ArrayList&lt;TreeLinkNode&gt;(); public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if(pNode==null) return null; TreeLinkNode p=pNode; while(p.next!=null) &#123; p=p.next; &#125; mid(p); int i=0; for(i=0; i&lt;list.size(); i++) &#123; if(i&lt;list.size()-1&amp;&amp;list.get(i)==pNode) &#123; return list.get(i+1); &#125; if(i==list.size()-1&amp;&amp;list.get(i)==pNode) &#123; return null; &#125; &#125; return null; &#125; public void mid(TreeLinkNode p) &#123; if(p!=null) &#123; mid(p.left); list.add(p); mid(p.right); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除链表中重复的结点]]></title>
    <url>%2F2020%2F02%2F24%2F%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 解题思路总感觉自己的思维固化了，总想着遍历链表一次，就能把这道题解决，但是自己却想不出来，看了别人的思路后，遍历链表两次，很好解决。遍历链表第一次，把重复的元素放在Set中，第二次遍历把链表中的重复元素删除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.*;/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; if(pHead==null) return pHead; HashSet &lt;Integer&gt; set=new HashSet&lt;Integer&gt;(); ListNode p=pHead.next;//遍历结点 ListNode pre=pHead;//遍历结点的前一个结点 while(p!=null) &#123; if(p.val!=pre.val)//当前结点的值和前一个结点的值不相等 &#123; pre=p; p=p.next; &#125; else&#123;//相等 set.add(pre.val); pre=p; p=p.next; &#125; &#125; //头结点包含在重复元素中 while(pHead!=null&amp;&amp;set.contains(pHead.val)) &#123; pHead=pHead.next; &#125; if(pHead==null) return pHead; //删除中间的重复元素 pre=pHead; p=pHead.next; while(p!=null) &#123; if(set.contains(p.val)) &#123; while(p!=null&amp;&amp;set.contains(p.val)) &#123; p=p.next; &#125; pre.next=p; &#125; else &#123; pre=p; p=p.next; &#125; &#125; return pHead; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表中环的入口结点]]></title>
    <url>%2F2020%2F02%2F24%2F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路自己动手无从下手，看了剑指offer书后，思路很清晰。 第一步：判断链表是否有环，建立两个指针p1，p2，p1每次走一步，p2每次走两步，如果两个指针相交，则这个链表是有环的，否则是无环的。 第二步：找出环中的节点数。在上一步的基础上，p2每次走一步，走到和p1相交的时候，走的步数就是环中的结点数。 第三步：判断环的入口。让p1和p2从新指向链表的头节点。p2先走环中的节点数步，然后两个指针再同时走，最后相交的结点就是环的入口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if(pHead==null) return null; //首先判断链表是否有环 ListNode p1=pHead; ListNode p2=pHead; boolean flag=false; while(p1!=null&amp;&amp;p2!=null) &#123; if(p2.next!=null) &#123; p1=p1.next; p2=p2.next.next; &#125; else break; if(p1==p2) &#123; flag=true; break; &#125; &#125; int cout=1; p2=p2.next; if(flag==false) return null; else &#123; //找出环中的节点数 while(p2!=p1) &#123; p2=p2.next; cout++; &#125; &#125; //找出环的入口 p1=pHead; p2=pHead; for(int i=0; i&lt;cout; i++) &#123; p2=p2.next; &#125; while(p1!=p2) &#123; p1=p1.next; p2=p2.next; &#125; return p1; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流中第一个不重复的字符]]></title>
    <url>%2F2020%2F02%2F24%2F%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 输出描述: 1如果当前字符流没有存在出现一次的字符，返回#字符。 解题思路开一个数组，记录对应字符出现的次数，如果字符出现的次数为1，则这个字符就入队。然后依次检验队列首部的字符，如果对应的字符只出现了一次，这个字符就是第一个只出现一次的字符（因为队列是先进先出），如果对应的字符出现了多次，则把这个字符移除队列。遍历完队列后，没有符合的字符，则返回#字符 1234567891011121314151617181920212223242526272829import java.util.Queue;import java.util.LinkedList;import java.lang.Character;public class Solution &#123; //Insert one char from stringstream int [] a=new int [256]; Queue&lt;Character&gt; queue = new LinkedList&lt;Character&gt;(); public void Insert(char ch) &#123; a[ch]++; if(a[ch]&lt;=1)//如果出现的次数为1，这个字符就入队 queue.add(ch); &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; Character ch=null; char c=0; while((ch=queue.peek())!=null) &#123; c=ch.charValue(); if(a[c]==1)//如果只是出现一次，则返回这个字符 return c; else//如果成双出现，就把这个字符出队 queue.remove(); &#125; return '#';//上面的没返回，就返回# &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表示数值的字符串]]></title>
    <url>%2F2020%2F02%2F23%2F%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解题思路123[-+]?;//表示有0或1个＋或者-[0-9]*;//表示有0个或者多个0到9的数(\\.[0-9]*)?;//表示有一个小数点，括号中的内容是可选的 1234567891011121314import java.util.regex.Pattern;public class Solution &#123; public boolean isNumeric(char[] str) &#123; int isnegative=1; int len=str.length; if(len&lt;=0) return false; //用正则表达式 String pattern="[+-]?[0-9]*(\\.[0-9]*)?([eE][+-]?[0-9]+)?"; //String pattern="[+-]?[0-9]*(\\.[0-9]*)?([eE][+-]?[0-9]+)?"; String s=new String(str); return s.matches(pattern); &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式匹配]]></title>
    <url>%2F2020%2F02%2F23%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 1请实现一个函数用来匹配包括&apos;.&apos;和&apos;*&apos;的正则表达式。模式中的字符&apos;.&apos;表示任意一个字符，而&apos;*&apos;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;abaca&quot;匹配，但是与&quot;aa.a&quot;和&quot;aba&quot;均不匹配 解题思路感谢这位大佬提供的思路 匹配是指完全匹配，例如aaa和aa是不匹配的，字符串aaa和模式a.a匹配很容易理解 1aaa和ab*ac*a的匹配过程 可以理解为b✳和c✳消失，即模式串为aaa，b的个数为零，c的个数为零，当然模式串可以等价为abaa，也可以等价为aaca 如果可以比较的模式串下标的下一个不是✳时 1(i&lt;str.length&amp;&amp;j&lt;pattern.length&amp;&amp;str[i]==pattern[j])||(i&lt;str.length&amp;&amp;pattern[j]==&apos;.&apos;) 满足时，继续比较字符串和模式串的下一位，即i++，j++，不满足直接返回false 如果比较的模式串下标的下一个是✳时，情况比较复杂 如果字符串的字符和模式串的字符相等，或者字符串的字符不是空，并且模式串的符号是’.’ 1(i&lt;str.length&amp;&amp;j&lt;pattern.length&amp;&amp;str[i]==pattern[j])||(i&lt;str.length&amp;&amp;pattern[j]=='.') 这时，继续字符串位置不变，模式串下标加2，或者字符串位置加1，模式串下标加2，或者字符串位置加1，模式串位置不变 否则，认为这个字符不匹配，在模式串中找到下个匹配的字符， 字符串位置不变，模式串的下标加2 12345678910111213141516171819202122232425public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if(str.length==0&amp;&amp;pattern.length==0) return true; return matchfunction(str,0,pattern,0); &#125; public boolean matchfunction (char [] str,int i,char[] pattern,int j) &#123; if(i==str.length&amp;&amp;j==pattern.length) return true; if(i&lt;str.length&amp;&amp;j==pattern.length) return false; if(j+1&lt;pattern.length&amp;&amp;pattern[j+1]=='*') &#123; if((i&lt;str.length&amp;&amp;j&lt;pattern.length&amp;&amp;str[i]==pattern[j])||(i&lt;str.length&amp;&amp;pattern[j]=='.')) return matchfunction(str,i,pattern,j+2)||matchfunction(str,i+1,pattern,j+2)||matchfunction(str,i+1,pattern,j); else return matchfunction(str,i,pattern,j+2); &#125; if((i&lt;str.length&amp;&amp;j&lt;pattern.length&amp;&amp;str[i]==pattern[j])||(i&lt;str.length&amp;&amp;pattern[j]=='.')) return matchfunction(str,i+1,pattern,j+1); return false; &#125;&#125; 解题思路二在LeetCode中采用递归的方法，栈溢出。改成使用动态规划的方法。 感谢大佬的思路,思路简单明了，很容易懂，以后还是多看博客，别只看leetcode中的题解，那样才收获大些。 1234567891, If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];3, If p.charAt(j) == '*': here are two sub conditions: if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.': dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean isMatch(String s, String p) &#123; if(s.length()==0&amp;&amp;p.length()==0) return true; int lens=s.length(); int lenp=p.length(); boolean [][]dp=new boolean[lens+1][lenp+1]; dp[0][0]=true; for(int j=1; j&lt;=lenp; j++) &#123; if(j&gt;1&amp;&amp;p.charAt(j-1)=='*'&amp;&amp;dp[0][j-2]) dp[0][j]=true; &#125; for(int i=1; i&lt;=lens; i++) &#123; for(int j=1; j&lt;=lenp; j++) &#123; char nows=s.charAt(i-1); char nowp=p.charAt(j-1); if(nows==nowp) dp[i][j]=dp[i-1][j-1]; else &#123; if(nowp=='.') dp[i][j]=dp[i-1][j-1]; else if(nowp=='*') &#123; char nowlastp=p.charAt(j-2); if(nowlastp!=nows&amp;&amp;nowlastp!='.')//s:abc p:abb*,即把p串b*去掉 dp[i][j]=dp[i][j-2]; else dp[i][j]=dp[i-1][j]||dp[i][j-1]||dp[i][j-2]; &#125; &#125; &#125; &#125; return dp[lens][lenp]; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建乘积数组]]></title>
    <url>%2F2020%2F02%2F23%2F%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];） 解题思路 B0 1 A1 A2 … An-2 An-1 B1 A0 1 A2 … An-2 An-1 B2 A0 A1 1 … An-2 An-1 … A0 A1 … 1 An-2 An-1 Bn-2 A0 A1 A2 … 1 An-1 Bn-1 A0 A1 A2 A3 … 1 根据剑指offer书中的解法，可以把B[i]=A[0]×A[1]×…A[i-2]×A[i-1]×…A[n-1]看成A[0]×A[1]×…A[i-1]和A[i+1]×A[i+2]×…A[n-2]×A[n-1]两部分的乘积。因此，数组B可以用一个矩形来创建。在图中，B[i]为矩阵中第i行所有元素的乘积。 12345678910111213141516171819import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; int len =A.length; int [] B=new int [len]; B[0]=1; for(int i=1; i&lt;len; i++) &#123; B[i]=B[i-1]*A[i-1]; &#125; int temp=1; for(int i=len-1; i&gt;=0; i--) &#123; B[i]=temp*B[i]; temp=temp*A[i]; &#125; return B; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将字符串转换成整数]]></title>
    <url>%2F2020%2F02%2F22%2F%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 输入描述: 1输入一个字符串,包括数字字母符号,可以为空 输出描述: 1如果是合法的数值表达则返回该数字，否则返回0 示例1 输入 +2147483647 1a33123输出 2147483647 0 解题思路这道题主要的溢出的问题，很麻烦，看了这篇博客收获很大 -2147483648(最小值) 2147483647（最大值） 12overValue = isNegtive*value - INT_MAX/10 + (((isNegtive+1)/2 + digit &gt; 8) ? 1:0); overValue&gt;0时，数值将会越界，反之不会。 12345678910111213141516171819202122232425262728293031public class Solution &#123; public int StrToInt(String str) &#123; if(str.length()==0) return 0; char [] chars=str.toCharArray(); int sum=0,i=0; int flag=1;//0为正数，1为负数，3为非法字符 if(chars[0]=='+') &#123; flag=1; i=1; &#125; if(chars[0]=='-') &#123; flag=-1; i=1; &#125; for(int j=i; j&lt;chars.length; j++) &#123; int digit=chars[j]-'0'; //用来判断这次循环是否会溢出，大于0则溢出，小于零不溢出 int overvalue=sum*flag-Integer.MAX_VALUE/10+(((flag+1)/2+digit&gt;8)?1:0); if(overvalue&gt;0) return 0; if(digit&gt;9||digit&lt;0) return 0; sum=sum*10+digit*flag; &#125; return sum; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不用加减乘除做加法]]></title>
    <url>%2F2020%2F02%2F22%2F%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解题思路​ 根据剑指offer书中的解法，5的二进制是101，17的二进制是10001，试着把计算分成三步:第一步各位相加但不计进位，得到的结果是10100（最后一位两个数都是1，相加的结果是二进制的10.这一步不计进位，因此结果任然是0）；第二部记下进位。在这个例子中只在最后一位相加时产生一个进位，结果是二进制的10；第三步把前两步的结果相加，得到的结果是10110，转换成十进制正好是22. ​ 接下来我们试着把二进制的加法用位运算来代替。第一步不考虑进位。对每一位相加。0加0、1加1的结果都是0，0加1、1加0的结果都是1.我们注意到，这和异或的结果是一样的。接着考虑第二步进位，对0加0、0加1、1加0而言，都不会产生进位，只有1加1时，会向前产生一个进位。此时我们可以想象成是两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0.第三步把前两个步骤的结果相加。第三步相加的过程依然是重复前面两步，直到不产生进位为止。 12345678910111213public class Solution &#123; public int Add(int num1,int num2) &#123; int sum=0; int carry=0; do&#123; sum=num1^num2; carry=(num1&amp;num2)&lt;&lt;1; num1=sum; num2=carry; &#125;while(num2!=0); return sum; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[孩子们的游戏]]></title>
    <url>%2F2020%2F02%2F22%2F%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 如果没有小朋友，请返回-1 解题思路开始想的是，自己开一个n长度的数组，循环n-1次，数组开始默认的值为零，每次遍历从零开始，每一次循环从0数到m-1，每次数到m-1时，对应的数组中的值记为1，继续下一次循环，只有数组中的值为0才是有效遍历，循环结束就剩下一个数，就是想要的结果，但是实现太难了，于是想到了循环链表，每循环一次，删掉对应元素，实现很简单。 1234567891011121314151617181920212223242526272829303132333435class ListNode&#123; int val; ListNode next=null; ListNode(int val) &#123; this.val=val; &#125;&#125;public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if(n&lt;=0||m&lt;=0) return -1; ListNode head=new ListNode(0); ListNode p=head; for(int i=1; i&lt;n; i++) &#123; ListNode ph=new ListNode(i); p.next=ph; p=ph; &#125; p.next=head;//构造环形链表 //p=head;//操作指针从新指向头指针 int cout=0;//进行游戏的次数 while(cout&lt;n-1) &#123; for(int i=0; i&lt;m-1; i++)//循环结束后，指向删除节点的前一个节点，这一步很重要 &#123; p=p.next; &#125; p.next=p.next.next; cout++; &#125; return p.val; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扑克牌顺子]]></title>
    <url>%2F2020%2F02%2F22%2F%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路自己看了题目之后，一脸懵逼，不知道题目什么意思。。。看了别人的思路才知道，这道题就是判断数组中有5个数字，大小王为0，5个数字中没有重复数字，用一个Treeset来存储，最大值和最小值之差在5之内。 12345678910111213141516171819202122import java.util.TreeSet;public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; TreeSet &lt;Integer&gt; set=new TreeSet&lt;Integer&gt; (); if(numbers.length&lt;5) return false; int zeronum=0; for(int i=0; i&lt;numbers.length; i++) &#123; if(numbers[i]==0) zeronum++; else set.add(numbers[i]); &#125; int len=zeronum+set.size(); if(len&lt;5) return false; if(len==5&amp;&amp;set.last()-set.first()&lt;5) return true; return false; &#125;&#125; 其中不熟的知识点: set.add();//向set中添加元素 set.last();//取set中最后元素 set.first();//取set中第一个元素]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转单词顺序列]]></title>
    <url>%2F2020%2F02%2F22%2F%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述原题链接 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路String不能翻转字符串，但是StringBuffer可以 例子: 12345"student. a am I"翻转后"I ma a .tneduts"以空格为标记，把每个单词翻转，拼接到一个新的字符串中"I am a student." 不熟悉的知识点: 123456789StringBuffer需要导入的包java.lang.StringBuffer;把String类型转化成StringBufferString str;StringBuffer newstr=new StringBuffer(str);newstr.reverse();//翻转newstr.charAt(i)==' ';//对应下标的字符是否是空newstr.subString(i,j);//取字符串中i到j-1下标的字符newstr.toString();//把StringBuffer类型转化成String类型 123456789101112131415161718192021222324252627282930import java.lang.StringBuffer;//注意导入包的写法，是java.langpublic class Solution &#123; public String ReverseSentence(String str) &#123; if(str.length()==0) return ""; StringBuffer newstr=new StringBuffer(str); newstr.reverse();//对字符串进行翻转 StringBuffer result=new StringBuffer();//用来存放结果 int spacenum=0;//空格数 int j=0;//每个单词的其实下标 for(int i=0; i&lt;newstr.length(); i++) &#123; if(newstr.charAt(i)==' '&amp;&amp;i!=newstr.length()-1) &#123; spacenum++; StringBuffer str2=new StringBuffer(newstr.substring(j,i)); result.append(str2.reverse()).append(" "); j=i+1;//j重新指向新单词的第一位 &#125; if(i==newstr.length()-1) &#123; StringBuffer str3=new StringBuffer(newstr.substring(j,i+1)); result.append(str3.reverse()); &#125; &#125; if(spacenum==0)//如果空格数为零 return str; return result.toString(); &#125;&#125; 解法二1234567891011121314151617class Solution &#123; public String reverseWords(String s) &#123; s=s.trim();//去掉首位的空格 int i=s.length()-1,j=i; StringBuffer str=new StringBuffer(); while(i&gt;=0) &#123; while(i&gt;=0&amp;&amp;s.charAt(i)!=' ')//寻找首个单词 i--; str.append(s.substring(i+1,j+1)).append(" ");//把单词添加 while(i&gt;=0&amp;&amp;s.charAt(i)==' ')//跳过空格 i--; j=i; &#125; return str.toString().trim(); &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为S的连续正数序列]]></title>
    <url>%2F2020%2F02%2F21%2F%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述: 1输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解题思路自己想到了用暴力算法，穷举法，但是自己却一直不去动笔，也是很绝望，很怕超时，其实很简单 123456789101112131415161718192021222324import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for(int i=1; i&lt;=sum/2; i++) &#123; int j=i; int s=0; while(s&lt;sum) &#123; s=s+j; j++; &#125; if(s==sum) &#123; ArrayList&lt;Integer&gt; sublist=new ArrayList&lt;Integer&gt;(); for(int k=i; k&lt;j; k++) sublist.add(k); list.add(sublist); &#125; &#125; return list; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中只出现一次的数字]]></title>
    <url>%2F2020%2F02%2F21%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 解题思路我开始的思路是，开一个新的数组记录对应数出现的次数，例如a[s],如果s出现一次，a[s]就加一，但是这样出现的问题是，s如果等于很大的数，这个数组就不知道要开多大。 我就看了别人的解法，先对这个数组进行排序，开一栈，每遍历一个数，就要和栈顶的元素作比较，如果相等就出栈，如果不相等就入栈，最后栈中剩下的元素就是我们需要的两个元素。 其中自己不了解的知识点 12import java.util.Arrays;Arrays.sort(array);//是对array数组进行排序,需要导入Arrays包 12345678910111213141516171819202122//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果import java.util.Arrays;import java.util.Stack;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; int len=array.length; Arrays.sort(array); Stack &lt;Integer&gt; stack=new Stack&lt;Integer&gt; (); for(int i=0; i&lt;len; i++) &#123; if(stack.empty()==true||stack.peek()!=array[i])//栈为空，或者栈顶元素和遍历元素不相等 &#123; stack.push(array[i]); &#125; else stack.pop(); &#125; num1[0]=stack.pop(); num2[0]=stack.pop(); &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2020%2F02%2F21%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 解题思路平衡二叉树就是左右子树的高度不超过1，二叉树的左右子树也是平衡二叉树 12345678910111213141516public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; return deeptree(root)!=-1; &#125; public int deeptree(TreeNode root) &#123; if(root==null) return 0; int left=deeptree(root.left); int right=deeptree(root.right); if(left&gt;right+1||right&gt;left+1||left==-1||right==-1)//如果左右子树的高度相差多于1，就返回-1，告诉这不是平衡二叉树 return -1; else return 1+(left&gt;right?left:right); &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2020%2F02%2F20%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题思路知道这道题要用递归，自己却不知道如何下手，还是自己做的题太少了，自己太菜了，要多加练习 123456789101112131415161718192021222324252627/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null) return 0; int leftdeep=TreeDepth(root.left); int rightdeep=TreeDepth(root.right); int result; if(leftdeep&gt;rightdeep) result=1+leftdeep; else result=1+rightdeep; return result; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2F2020%2F02%2F20%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述： 123456789题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例1 1234输入1,2,3,4,5,6,7,0输出7 解题思路别人解题思路 简而言之，就是先把数组分隔成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; int cout=0; public int InversePairs(int [] array) &#123; mergesort(array,0,array.length-1); return cout; &#125; public void mergesort(int [] array,int start,int end) &#123; if(start&gt;=end) return; int mid=(start+end)/2; mergesort(array,start,mid); mergesort(array,mid+1,end); mergesortone(array,start,mid,end); &#125; public void mergesortone(int [] array,int start,int mid,int end) &#123; int [] temp=new int [end-start+1];//开一个数组保存排序后的数组 int i=start,j=mid+1,k=0; while(i&lt;=mid&amp;&amp;j&lt;=end) &#123; if(array[i]&lt;=array[j])//不能构成逆序对 &#123; temp[k++]=array[i++]; &#125; else//能构成逆序对 &#123; temp[k++]=array[j++]; cout=(cout+mid+1-i)%1000000007;//前一半数组中元素的个数 &#125; &#125; while(i&lt;=mid)//前一半数组中剩余的个数 &#123; temp[k++]=array[i++]; &#125; while(j&lt;=end)//后一半数组中剩余的个数 &#123; temp[k++]=array[j++]; &#125; for(int f=0; f&lt;k; f++)//把排好序的数组赋给array数组 &#123; array[start+f]=temp[f]; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2F2020%2F02%2F20%2F%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路1×2=2，1×3=3，2×2=4, 1×5=5，2×3=6，。。。。。 用三个指针分别纪录质数2，3，5，当乘以对应的质数时，对应的指针加一，开一个大的数组记录对应丑数。 1234567891011121314151617181920public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index&lt;=0) return 0; int p1=0,p2=0,p3=0; int [] result=new int [index]; result[0]=1; for(int i=1; i&lt;index; i++) &#123; result[i]=Math.min(result[p1]*2,Math.min(result[p2]*3,result[p3]*5)); if(result[i]==result[p1]*2) p1++; if(result[i]==result[p2]*3) p2++; if(result[i]==result[p3]*5) p3++; &#125; return result[index-1]; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把数组排成最小的数]]></title>
    <url>%2F2020%2F02%2F20%2F%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路自己拿到这道题，想了一会儿，完全一点思路也没有，看了别人的解题思路后，理解如下：这道题主要是对字符串进行排序，将字符串s1和s2进行拼接，如果s1+s2大于s2+s1，则s2应该排在s1的前面。 1234567891011121314151617181920212223242526272829import java.util.ArrayList; public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; String str=new String(""); int len =numbers.length; if(len==0) return ""; for(int i=0; i&lt;len; i++)//用冒泡排序 &#123; for(int j=i+1; j&lt;len; j++) &#123; int sum1=Integer.valueOf(numbers[i]+""+numbers[j]); int sum2=Integer.valueOf(numbers[j]+""+numbers[i]); if(sum1&gt;sum2) &#123; int temp=numbers[i]; numbers[i]=numbers[j]; numbers[j]=temp; &#125; &#125; &#125; for(int i=0; i&lt;len; i++) &#123; str+=numbers[i]; &#125; return str; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数中1出现的次数（从1到n整数中1出现的次数）]]></title>
    <url>%2F2020%2F02%2F19%2F%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路一从1到n，每个数都判断个位，十位，百位，千位。。。中的1的个数，加起来，累加后得到结果 代码12345678910111213141516171819202122public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; int cout=0; for(int i=1; i&lt;=n; i++) &#123; cout+=judge(i); &#125; return cout; &#125; public int judge(int n) &#123; int s=0; do&#123; int di=n%10; if(di==1) s++; n=n/10; &#125;while(n!=0); return s; &#125;&#125; 解题思路二写得很清晰，自己再总结就是1234是n，当前遍历为4，那么高位是123，低位是0，1的个数是124个，如果当前遍历为3，那么高位是12，低位是4，1的个数为120+4+1=125,如果当前遍历为2，那么高位是1，低位是34，1的个数为200，如果当前遍历为1，高位为0，低位为234，1的个数为234+1=235. 代码1234567891011121314151617181920class Solution &#123; public int countDigitOne(int n) &#123; int res=0,digit=1; int cur=n%10,low=0,high=n/10; while(high!=0||cur!=0) &#123; if(cur==0) res+=(high*digit); else if(cur==1) res+=(high*digit+low+1); else if(cur&gt;1) res+=(high+1)*digit; low+=(cur*digit); cur=high%10; high=high/10; digit=(digit*10); &#125; return res; &#125;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续子数组的最大和]]></title>
    <url>%2F2020%2F02%2F19%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 解题思路复习动态规划，连续子数组的最大和是通过遍历数组，通过比较当前最大子序列和与当前数的和是否大于当前最大子序列和，如果大于，则当前最大子序列和更新这两个数的和，如果当前最大子序列和当前数的和小于当前遍历的这个数，最大子列和为当前这个数。 代码12345678910111213141516171819202122public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int len=array.length; int [] dp=new int [len]; dp[0]=array[0]; int max=array[0]; for(int i=1; i&lt;len ; i++) &#123; if(array[i]+dp[i-1]&gt;array[i])//如果这个数加上最大连续子列和大于这个数，则更新最大连续子序列和 &#123; dp[i]=array[i]+dp[i-1]; &#125; else if(array[i]+dp[i-1]&lt;array[i])//最大子序列和加上这个数小于这个数，则最大连续子序列和就是这个数 &#123; dp[i]=array[i]; &#125; if(dp[i]&gt;max) max=dp[i]; &#125; return max; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中出现次数超过一半的数字]]></title>
    <url>%2F2020%2F02%2F19%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路记录第一个数，这个数出现的次数为1，遍历数组，如果和这个数相等，对应的次数加一，不相等，对应的次数减一，如果对应次数减到零，则重新记录新的数，遍历完数组，如果这个数在数组中的次数超过一半，记录的数就是这个数。 代码12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; int len=array.length; int cout=1; int temp=array[0]; for(int i=1; i&lt;len; i++) &#123; if(array[i]==temp) &#123; cout++; &#125; else if(array[i]!=temp) &#123; cout--; if(cout==0) &#123; temp=array[i]; cout=1; &#125; &#125; &#125; int s=0; for(int i=0; i&lt;len; i++)//判断找到的数是否真的是出现次数超过一半的数 &#123; if(temp==array[i]) &#123; s++; &#125; &#125; return s&gt;len/2?temp:0; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的排列]]></title>
    <url>%2F2020%2F02%2F18%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述：1输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路多谢大佬的解题思路 这道题用TreeSet很好解决，又可以去重，又自动排序，但是不能用。。。只能用ArrayList 例如abc可以字母a分别与a，b，c交换得到a,(b,c)和b,(a,c)和c,(a,b) a,(b,c)的子集(b,c)继续进行这样的操作，b与b,c交换,得到b,(c)和c,(b), (c)中c与c自己交换的，(b)中b与b自己交换.a,(b,c)的全排列就得到了，同理可以得到b,(a,c)和c,(a,b)的全排列,最后得到a,b,c的全排列。 下面是大佬思路的精髓： 假如有重复值呢？ 由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数(代码中用HashSet)，所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;import java.util.Collections;import java.util.Set;import java.util.HashSet;public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); if(str.length()!=0) &#123; //str.toCharArray()是将String类型转化成Char型数组 permutationhelp(str.toCharArray(),0,list); Collections.sort(list); &#125; return list; &#125; public void permutationhelp(char [] chars,int i,ArrayList&lt;String&gt; list) &#123; //已经递归到字符数组末尾了，是递归的结束条件 if(i==chars.length-1)//字符数组的长度为chars.length,字符串的长度为chars.length() &#123; list.add(String.valueOf(chars));//String.valueOf(chars)将chars数组转化成字符串 return; &#125; Set&lt;Character&gt; charset=new HashSet&lt;Character&gt; ();//记录字符，将来要和遍历的字符作比较，这里面没有交换 for(int j=i; j&lt;chars.length; j++) &#123; if(i==j||charset.contains(chars[j])==false) &#123; charset.add(chars[j]); swapij(chars,i,j);//将对应位置的字符对换 permutationhelp(chars,i+1,list); swapij(chars,j,i); &#125; &#125; &#125; public void swapij(char [] chars,int i,int j) &#123; char temp=chars[i]; chars[i]=chars[j]; chars[j]=temp; &#125;&#125;]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS]]></title>
    <url>%2F2020%2F02%2F17%2FAQS%2F</url>
    <content type="text"><![CDATA[AQS是AbstractQueuedSynchronizer的简称:使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架 利用了一个int类型表示状态 使用方法是继承 字类通过继承并通过实现它的方法管理其状态(require和release)的方法操作状态 可以同时实现排它锁和共享锁模式(独占，共享)]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树与双向链表]]></title>
    <url>%2F2020%2F02%2F07%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路用中序遍历的思想，再把修改相应的指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Stack;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeNode Convert(TreeNode pRootOfTree) &#123; Stack &lt;TreeNode&gt; stack =new Stack &lt;TreeNode&gt; (); TreeNode p=pRootOfTree; TreeNode head=null;//新的双向链表的头节点 TreeNode pre=null;//新的双向链表的尾节点 boolean flag=true;//用来建立链表的首节点 while(stack.isEmpty()==false||p!=null) &#123; while(p!=null) &#123; stack.push(p); p=p.left; &#125; p=stack.pop(); if(flag==true) &#123; head=p; pre=p; flag=false; &#125; else &#123; pre.right=p; p.left=pre; pre=p; &#125; p=p.right; &#125; return head; &#125;&#125; 二叉树的中序遍历二叉搜索树的中序遍历是有序的，详细解答代码如下 12345678inorder(root)&#123; if(root==null) return; inorder(root.left); System.out.println(root.val); inorder(root.right);&#125; 解题思路中序遍历二叉搜索树(需要两个指针，root表示当前遍历的指针，pre指针当前遍历节点的前指针) 1.终止条件：当节点为空时，直接返回 2.递归左子树inorder(root.left) 3.构建链表： ​ I.当root为空时，表示正在访问链表的第一个节点，让head=root ​ II.当root不为空时，保存这两个节点的关系，pre.right=root,root.left=pre,pre=root,让pre指向root 4.递归遍历右子树 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val,Node _left,Node _right) &#123; val = _val; left = _left; right = _right; &#125;&#125;;*/class Solution &#123; Node head=null,pre=null; public Node treeToDoublyList(Node root) &#123; if(root==null) return null; inorder(root); head.left=pre; pre.right=head; return head; &#125; public void inorder(Node root) &#123; if(root==null) return; inorder(root.left); if(pre!=null) pre.right=root; else head=root; root.left=pre; pre=root; inorder(root.right); &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树中和为某一值的路径]]></title>
    <url>%2F2020%2F02%2F07%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 思路二叉树的遍历，如果遍历后的和为目标值，则把这串数保存起来，用递归解法很简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; sublist=new ArrayList&lt;Integer&gt; (); if(root==null) return list; findpath(list,sublist,root,target); return list; &#125; public void findpath(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list,ArrayList&lt;Integer&gt; sublist,TreeNode root,int target) &#123; sublist.add(root.val); if(root.left==null&amp;&amp;root.right==null)//叶子节点 &#123; if(root.val==target) &#123; list.add(sublist); &#125; return; &#125; //分别遍历左右子树，如果有符合条件的就加入到list中 //每当遍历新的子树，就新建ArrayList来保存,以便于将符合条件的数组加入到list中 ArrayList &lt;Integer&gt; newlist=new ArrayList&lt;Integer&gt; (); newlist.addAll(sublist); if(root.left!=null) findpath(list,newlist,root.left,target-root.val); if(root.right!=null) findpath(list,sublist,root.right,target-root.val); &#125;&#125;]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的后序遍历序列]]></title>
    <url>%2F2020%2F02%2F06%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路什么叫做二叉搜索数，即左子树小于根节点，右子树大于根节点，每一个子树也满足这个条件。 这道题采用分治的方法，数组序列的最后一个节点就是根节点，根据二叉搜索树的后序遍历，小于根节点的数就是左子树，大于根节点的数就是右子树，然后再分别判断左子树和右子树是否满足二叉搜索树的后续遍历。 123456789101112131415161718192021222324252627public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length&lt;=0)//数组为空就是不符合后序遍历 return false; return judgeBSF(sequence,0,sequence.length-1); &#125; public boolean judgeBSF(int [] sequence,int start,int end) &#123; if(start&gt;=end) return true; int i=start; int val=sequence[end];//根节点的值 while(sequence[i]&lt;val)//循环截止时i-1的值，就是左子树根节点的下标 &#123; i++; &#125; int j=i; while(j&lt;end) &#123; j++; if(sequence[j]&lt;val)//如果右子树的值小于根节点的值，这个就不符合后序遍历 return false; &#125; //判断左子树和右子树是否符合二叉搜索树的后序遍历 return judgeBSF(sequence,start,i-1)&amp;&amp;judgeBSF(sequence,i,end-1); &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从上往下打印二叉树]]></title>
    <url>%2F2020%2F02%2F06%2F%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路这道题就是二叉树的层序遍历，用队列来完成即可，先进先出，只是忘记了队列的相关操作，做这道题来巩固一下队列的基本操作： offer（添加队尾元素）、peek（访问队头元素）、poll（访问队头元素并移除） 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.Queue;import java.util.LinkedList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; Queue &lt;TreeNode&gt; queue =new LinkedList &lt;TreeNode&gt; (); ArrayList &lt;Integer&gt; list=new ArrayList &lt;Integer&gt; (); if(root==null)//如果树为空，则返回空的ArrayList，而不是null return list; queue.offer(root); while(queue.isEmpty()==false) &#123; TreeNode temp=queue.poll(); list.add(temp.val); if(temp.left!=null) queue.offer(temp.left); if(temp.right!=null) queue.offer(temp.right); &#125; return list; &#125;&#125; 注意点12Queue &lt;TreeNode&gt; queue = new LinkedList &lt;TreeNode&gt;();而不是Queue &lt;TreeNode&gt; queue = new Queue &lt;TreeNode&gt;(); 还要导入相关的包 如果数是空树，返回的是空的ArrayList，而不是空指针！]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的压入、弹出序列]]></title>
    <url>%2F2020%2F02%2F06%2F%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路参考了别人的解题思路，我咋就没想到呢，新建一个栈，第一个序列依次进栈，每一次进栈，栈顶元素都要比较和序列二对应元素的值，如果相等，则出栈，循环结束后，如果栈中元素为空，则返回true 1234567891011121314151617181920import java.util.ArrayList;import java.util.Stack;//记得导入相关的包public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length==0||popA.length==0||pushA.length!=popA.length) return false; Stack &lt;Integer&gt; stack=new Stack &lt;Integer&gt; (); int j=0; for(int i=0; i&lt;pushA.length; i++) &#123; stack.push(pushA[i]); while(stack.isEmpty()==false&amp;&amp;stack.peek()==popA[j]) &#123; stack.pop(); j++; &#125; &#125; return stack.isEmpty();//判断栈是否为空 &#125;&#125;]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包含min函数的栈]]></title>
    <url>%2F2020%2F02%2F06%2F%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 解题思路用两个栈来完成，一个栈记录元素，另一个栈用来记录栈中所含最小元素，每一次元素的入栈和出栈，都要更新对应最小元素栈中的值。例如一个元素入栈，如果这个元素小于最小元素栈中的值，则要更新最小元素栈中的值，否则最小元素栈中的值保持不变。 123456789101112131415161718192021222324252627282930313233import java.util.Stack;public class Solution &#123; Stack &lt;Integer&gt; Total=new Stack &lt;&gt; ();//记录所有的元素 Stack &lt;Integer&gt; Little=new Stack &lt;&gt; ();//栈顶记录当前的最小元素 public void push(int node) &#123; Total.push(node); if(Little.empty()) Little.push(node); else&#123; if(node&lt;Little.peek())//如果这个元素小于栈中的最小元素 &#123; Little.push(node); &#125; else&#123;//如果这个元素大于栈中最小元素，则最小元素栈进栈的还是最小元素栈中栈顶的元素 Little.push(Little.peek());//Little.peek()只取栈顶的元素值，但是不出栈 &#125; &#125; &#125; public void pop() &#123; Total.pop(); Little.pop(); &#125; public int top() &#123; return Total.peek(); &#125; public int min() &#123; return Little.peek(); &#125;&#125;]]></content>
      <categories>
        <category>栈</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>剑指offer笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺时针打印矩阵]]></title>
    <url>%2F2020%2F02%2F06%2F%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[顺时针打印矩阵题目描述题目链接 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路主要是控制数组的访问方向，首先是向右遍历，然后向下遍历，向左遍历，向上遍历，可以用一个数组来完成。 12345int cout=0;int [] dx=&#123;0,1,0,-1&#125;;//行变化int [] dy=&#123;1,0,-1,0&#125;;//列变化//当需要改变方向时，可以通过改变cout的值来完成//例如向右遍历时，cout=0,对应的dx[cout]=0，dy[cout]=1 还有是需要一个二维数组来标记这个数是否被访问过，未被访问过则这个数组的对应数记录为false，访问过则记录对应数为ture，则可以完成矩阵的顺时针的遍历，逆时针同样可以完成遍历 代码: 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; int lie=matrix[0].length; int hang=matrix.length; ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;(); int [] dx=&#123;0,1,0,-1&#125;;//行变化 int [] dy=&#123;1,0,-1,0&#125;;//列变化 int cout=0;//用来控制方向 int x=0;//当前行 int y=0;//当前列 boolean [][] visit=new boolean[hang][lie]; for(int i=0; i&lt;hang*lie; i++) &#123; if(x&gt;=0&amp;&amp;x&lt;hang&amp;&amp;y&gt;=0&amp;&amp;y&lt;lie&amp;&amp;visit[x][y]==false)//在矩阵内且没有访问过 &#123; visit[x][y]=true; list.add(matrix[x][y]); &#125; int tx=x+dx[cout];//新的临时x坐标 int ty=y+dy[cout];//新的临时y坐标 if(tx&lt;0||tx&gt;=hang||ty&lt;0||ty&gt;=lie||visit[tx][ty]==true)//矩阵坐标越界或者已经访问过 &#123; cout++; cout=(cout)%4; x=x+dx[cout]; y=y+dy[cout]; &#125; else//正常坐标 &#123; x=tx; y=ty; &#125; &#125; return list; &#125;&#125;]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[147.对链表进行插入排序]]></title>
    <url>%2F2020%2F01%2F25%2F147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 对链表进行插入排序 解题思路这道的思路真的很简单，但是实际动手起来很容易出错，主要是指针有点小错误就会一直卡住。链表问题，自己做了这么多，一直很容易出现指针越界，这个问题就卡了昨天一下午，一定要先判断指针是否越界！！！ 1if(ph.val&gt;=p.val&amp;&amp;p.next.val&gt;ph.val&amp;&amp;p.next!=null) 1if(p.next!=null&amp;&amp;ph.val&gt;=p.val&amp;&amp;p.next.val&gt;ph.val)//插入链表中间 这两条命令是有区别的，在leetcode中，上面那条代码会出现指针越界问题，下面这条代码就不会出现指针越界问题 最后附上自己的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode p=head;//操作指针 ListNode ph=head.next;//从数据中获取元素 ListNode ph_next=ph.next;//用来指向输入数据的后面一个元素 head.next=null;//形成新的链表 while(ph!=null) &#123; while(p!=null) &#123; if(p.next!=null&amp;&amp;ph.val&gt;=p.val&amp;&amp;p.next.val&gt;ph.val)//插入链表中间 &#123; ph.next=p.next; p.next=ph; ph=ph_next;//ph指向新的数据 p=head;//p重新指向头节点 break; &#125; else if(ph.val&lt;p.val&amp;&amp;p==head)//插入到链表头部 &#123; head=ph; ph.next=p; ph=ph_next;//ph指向新的数据 p=head;//p重新指向头节点 break; &#125; else if(ph.val&gt;=p.val&amp;&amp;p.next==null)//插入到链表的末尾 &#123; ph.next=p.next; p.next=ph; ph=ph_next;//ph指向新的数据 p=head;//p重新指向头节点 break; &#125; else p=p.next; &#125; if(ph_next!=null) ph_next=ph_next.next; else break; &#125; return head; &#125;&#125;]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重排链表]]></title>
    <url>%2F2020%2F01%2F23%2F%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 解题思路把元素存储在线性表中，然后在头尾中分别取元素就行了 List的用法 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; if(head==null) return; List&lt;ListNode&gt; li=new ArrayList&lt;ListNode&gt;(); ListNode p=head; while(p!=null) &#123; li.add(p); p=p.next; &#125; int i=0; int j=li.size()-1; while(i&lt;j) &#123; li.get(i).next=li.get(j); i++; // 比如偶数个，例如2个 if(i==j) break; li.get(j).next=li.get(i); j--; &#125; li.get(i).next=null; &#125;&#125;]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环形链表II]]></title>
    <url>%2F2020%2F01%2F23%2F%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 解题思路这道题用set很好解决，但是set的用法不是很清楚.这篇文章讲set讲得很详细 这道题主要用了add()方法，向集合中添加元素，contains()方法，判断集合中是否包含某一个元素。 思路：遍历整个链表，并把每一个节点加入到set集合中，每加入一个，就判断以前是否加入过，如果有加入过，则这个链表是有环的，如果一直遍历到链表的结尾，即节点为空时，也没有重复元素，则这个链表是无环的。 代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; Set &lt;ListNode&gt; list = new HashSet &lt;ListNode&gt; (); ListNode p=head; while(p!=null) &#123; if(!list.contains(p)) &#123; list.add(p); &#125; else return p; p=p.next; &#125; return null; &#125;&#125;]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复制带随机指针的链表]]></title>
    <url>%2F2020%2F01%2F23%2F%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述题目链接 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的 深拷贝。 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 示例 1： 12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2： 12输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]] 示例 3： 12输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]] 示例 4： 123输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 解题思路大佬解题思路 看了这位作者的解题思路，学到了很多 第一步：复制节点 第二步：给每个复制节点指定对应的随机指针 第三步：把一个链表拆分成两个相同的链表 （看这位作者的图会更加生动形象） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*// Definition for a Node.class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125;&#125;*/class Solution &#123; public Node copyRandomList(Node head) &#123; if(head==null) return head; // 复制节点 Node cur=head; Node tmp=cur.next; while(cur!=null) &#123; tmp=cur.next; cur.next=new Node(cur.val,null,null); cur.next.next=tmp; cur=tmp; &#125; // 复制随机指针 cur=head; while(cur!=null) &#123; if(cur.random!=null) cur.next.random=cur.random.next; cur=cur.next.next; &#125; // 拆分 cur=head; Node curhead=cur.next; Node copylisthead=curhead; while(curhead.next!=null) &#123; cur.next=curhead.next; cur=curhead.next; curhead.next=cur.next; curhead=cur.next; &#125; cur.next=null; return copylisthead; &#125;&#125; 终于AC了！]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反转链表]]></title>
    <url>%2F2020%2F01%2F21%2F%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转链表题目反转链表题目链接 反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题思路遍历链表，并新建一个链表，每遍历一个数字，就把这个数用头插法插在第一位置。 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode list=new ListNode(-1);//这个链表的头指针 ListNode pl=list.next;//这个链表的第二个节点 ListNode p=head; while(p!=null) &#123; list.next=new ListNode(p.val);//每遍历一个节点就把它放到链表的第一个位置 list.next.next=pl; pl=list.next; p=p.next; &#125; return list.next; &#125;&#125; 遍历完成后，链表就反转完成。 12345678解题方法二:递归反转链表ListNode reverse(ListNode head) &#123; if (head.next == null) return head; ListNode last = reverse(head.next); head.next.next = head; head.next = null; return last;&#125; 这篇文章讲解递归反转链表讲的比较好 反转链表题目进阶反转链表II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 解题思路刚学完递归反转链表，我想过用递归去解这道题，自己还是毫无思路，看别人用递归的解法也看得有点发懵，还是觉得用常规方法好 第一步，找到反转位置的前一个位置p 第二步，将m到n的节点全部反转 第三步p的下一个指针指向反转链表的开始节点，反转链表的末尾节点的下一个指针指向原链表的第n+1的节点 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; //第一步，找到反转位置的前一个位置p //第二步，将m到n的节点全部反转 //第三步p的下一个指针指向反转链表的开始节点，反转链表的末尾节点的下一个指针指向原 //链表的第n+1的节点 ListNode Nl=new ListNode(0); Nl.next=head; ListNode p=Nl; for(int i=1; i&lt;m; i++)//找到开始反转位置的前一个位置 &#123; p=p.next; &#125; ListNode ph=p.next; ListNode pre=null;//pre指向反转链表的首节点 ListNode last=null;//last指向第n+1个节点 for(int i=m; i&lt;=n; i++)//将第m个节点到n个节点全部反转 &#123; last=ph.next; ph.next=pre; pre=ph; ph=last; &#125; p.next.next=last;//反转链表的末尾节点的下一个指针指向第n+1个节点 p.next=pre;//前一段链表的末尾节点的下一个指针指向反转链表的头节点 return Nl.next; &#125;&#125;]]></content>
      <tags>
        <tag>做题笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发秒杀项目]]></title>
    <url>%2F2020%2F01%2F08%2FJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1.创建项目和依赖1.1maven命令创建web骨架项目1mvn archetype:create -DgroupId=org.seckill -DartifactId=seckill -DarchetypeArtifactId=maven-archetype-webapp]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker学习笔记]]></title>
    <url>%2F2020%2F01%2F06%2FDock%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.Docker是什么？Docker是一个开源的应用容器引擎：Docker支持将软件编译成一个镜像，然后在镜像中各种软件做好配置，将镜像发布出去，其他人可以直接使用这个镜像。 2.Docker相关的概念docker主机（Host）：安装了Docker程序的机器，Docker直接安装在操作系统之上。 docker客户端（Client）：连接docker主机进行操作。 docker仓库（Registry）：用来保存各种打包好的软件镜像。 docker镜像（Images）：软件打包好的镜像，放在docker仓库中。 docker容器（Container）：镜像启动后的实例称为一个容器，容器是独立运行的应用。 3.使用Docker的步骤一 安装Docker 二 去Docker仓库找到这个软件对应的镜像 三 使用Docker运行这个镜像，这个镜像就会生成一个Docker容器 4.容器的操作12345678910111213141516171819201.搜索镜像docker search tomcat2.拉取镜像docker pull tomcat3.根据镜像启动容器docker run --name mytomcat -d tomcat：latest其中mytomcat是自己给tomcat的别名4.查看运行中的容器docker ps5.停止运行的容器docker stop （容器id）6.查看所有的容器docker ps -a7.启动一个做了端口映射的tomcatdocker run --name mytomcat -d -p 8888:8080 tomcat-d：后台运行-p：将主机的端口映射到容器的一个端口主机端口：容器内部的端口可以一个镜像，运行多个容器 安装MySql 1234567首先要以root方式运行sudo -i然后查看有哪些镜像docker images运行MySql docker run -p 3306:3306 --name mysql101 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.5就可以用Navicat连接了]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的基本使用]]></title>
    <url>%2F2020%2F01%2F03%2FLinux%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Linux的基本命令1.pwd命令显示当前的目录 2.ls显示当前目录的所有文件夹 2.1 ls -l显示当前目录的所有文件，文件以垂直展示出来，即列表的形式 2.2 ls -a这会显示隐藏文件的 2.3 ls -l -h以k的单位展示出来（文件大小） 2.4 ls通配符2.4.1 **代表一个或者多个符号 ls *.txt 只想找txt格式的文件 2.4.2 ？？只代表一个字符 ls ？？.odt 查找只有两个字符的文件夹,以odt结尾的文件 2.4.3 []ls [1234].odt 查找第一个字符从1，2，3，4中任一个字符开头的odt文件。 ls [1-4].odt的意思是一样的 3.cd在cd后面添加要去的文件目录，例如：cd Desktop，意思就是到Desktop文件，注意cd只能打开文件夹 3.1 cd .cd .表示当前目录 3.2 cd .. cd ..表示上一层目录 3.3 cd ~cd ~ 表示回到跟路径 3.4 绝对路径和相对路径cd /开头是绝对路径 3.5 cd -cd -回到上一次操作的目录 4 touch命令touch text.txt表示创建一个text.txt文件 5 mkdir命令mkdir xiaokeai 会创建一个xiaokeai文件 5.1 创建隐藏文件mkdir .xiaokeai 会创建一个隐藏文件夹 6 rm命令6.1 删除文件rm xiaokeai 会删除xiaokeai文件 6.2 删除文件夹rm -d xiaokeai 会删除xiaokeai文件夹，只能删除空的文件夹 rm -r xiaokeai 会删除xiaokeai文件夹（文件不为空也会删除） 7 移动mv test.txt aa 表示把test.txt文件移动到aa文件夹中 移动不仅可以移动文件，也可以移动文件夹 8 复制cp test.txt xiaokeai 会把test.txt复制到xiaokeai的文件夹中]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常见指令操作]]></title>
    <url>%2F2019%2F11%2F29%2Fgit%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Git常见指令操作查看属于哪个分支的指令git branch: 星号所指的是就是当前的分支 创建一个新分支,并切换到新分支上git checkout -b user:新建了一个user分支（-b user），并切换到user分支上 检查当前分支下文件的状态git status命令查看当前分支下文件的状态 把这些文件都添加到暂存区git add .然后再检查文件状态git status 把当前分支提交到仓库中git commit -m &quot;提交消息&quot; 把本地分支推送到云端进行保存git push -u origin user:把本地的分支推送到云端的origin仓库，以user分支进行保存 把其他分支合并到主分支中1.git branch:查看当前的分支2.git checkout master:切换到主分支3.git branch:查看当前的分支4.git merge user:把user分支合并到主分支 把本地master分支的代码推送到云端git push 提交到云端完成！ 创建新的分支git checkout -b rights:创建rights分支 把新创建的分支提交到云端git push -u origin rights]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四数之和]]></title>
    <url>%2F2019%2F10%2F28%2F%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目:题目链接给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路1.首先对数组进行从小到大排序2.使用四个指针，i=0，j=i+1，low=j+1，high=nums.length-1，判断nums[i]+nums[j]+nums[low]+nums[high]与目标数target大小？如果小于target，则low++，如果大于，则high–，如果相等，则把这个四个数存起来，low++，high–，直到low不小于high时，这时j++，指针j从左往右遍历，直到指针遍历到数组的最后一个数时，i++。即i在最外面循环，里面嵌套着循环j，j循环里面嵌套这low和high这两个指针的循环。3.要注意，重复元素，如果下次遍历的元素和这次的元素相等，则跳过这次循坏。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list=new ArrayList(); Arrays.sort(nums); if(nums.length&lt;4) return list; for(int i=0; i&lt;nums.length-3; i++) &#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1])//去重 continue; for(int j=i+1; j&lt;nums.length-2; j++ ) &#123; if(j-1&gt;i&amp;&amp;nums[j]==nums[j-1])//去重 continue; int low=j+1; int high=nums.length-1; while(low&lt;high) &#123; if(nums[i]+nums[j]+nums[low]+nums[high]==target) &#123; List&lt;Integer&gt;sublist=new ArrayList(); sublist.add(nums[i]); sublist.add(nums[j]); sublist.add(nums[low]); sublist.add(nums[high]); list.add(sublist); while(low+1&lt;high&amp;&amp;nums[low]==nums[low+1]) &#123; low+=1; &#125; while(high-1&gt;low&amp;&amp;nums[high]==nums[high-1]) &#123; high-=1; &#125; low++; high--; &#125; else if(nums[i]+nums[j]+nums[low]+nums[high]&lt;target) &#123; // if(low+2&lt;high&amp;&amp;nums[low]==nums[low+1])//自己想复杂了！！！！ // &#123; // while(low+2&lt;high&amp;&amp;nums[low]==nums[low+1]) // &#123; // low+=2; // &#125; // &#125; // else low++; &#125; else if(nums[i]+nums[j]+nums[low]+nums[high]&gt;target) &#123; // if(high-2&gt;low&amp;&amp;nums[high]==nums[high-1]) // &#123; // while(high-2&gt;low&amp;&amp;nums[high]==nums[high-1]) // &#123; // high-=2; // &#125; // &#125; // else high--; &#125; &#125; &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode练习</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2048游戏制作]]></title>
    <url>%2F2019%2F10%2F21%2F2048%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[2048游戏制作游戏架构1.UI层：主要包括index.html和2048.css文件2.游戏主逻辑：main2048.js文件3.动画效果逻辑：showanimation.js文件4.底层支撑逻辑：support.js文件 制作步骤创建五个文件，分别是index.html文件,2048.css文件,main2048文件,showanimation文件，support文件 UI层index.html文件代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;html&gt;&lt;head&gt; &lt;!--不让缩放屏幕大小--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; &lt;title&gt;2048&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;2048.css&quot;/&gt; &lt;!--加载jquery的库函数--&gt;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;main2048.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;showanimation.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;support.js&quot;&gt;&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;h1&gt;Lixin&apos;s 2048&lt;/h1&gt; &lt;!--点击New Game按钮将响应一个javascript的newgame()函数--&gt; &lt;a href=&quot;javascript:newgame();&quot; id=&quot;newgamebutton&quot;&gt;New Game&lt;/a&gt; &lt;!--score是动态的，所以在它的分值外面套一层span的标签，为了方便操作它，并给这个span加上一个id--&gt; &lt;p&gt;score:&lt;span id=&quot;score&quot;&gt;0&lt;/span&gt;&lt;/p&gt; &lt;/header&gt; &lt;div id=&quot;grid-container&quot;&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-0-0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-0-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-0-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-0-3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-1-0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-1-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-1-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-1-3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-2-0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-2-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-2-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-2-3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-3-0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-3-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-3-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;grid-cell&quot; id=&quot;grid-cell-3-3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2048.css代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172header&#123;/*header标签样式设置*/ display:block; margin:0 auto; /*居中显示*/ width: 100%; text-align:center; /*文字居中显示*/&#125;header h1&#123;/*h1标签样式设置*/ font-family:Arial;/*字体*/ font-size: 40px;/*字号*/ font-weight: bold;/*子粗体显示*/&#125;header #newgamebutton&#123;display: block;margin: 20px auto;/*居中显示，上下有20的空隙*/width: 100px;padding: 10px 10px;background-color: #8f7a66;font-family: Arial;color: white;border-radius:10px;text-decoration: none;&#125;header #newgamebutton:hover&#123; background-color: #9f8b77;&#125;header p&#123; font-family: Arial; font-size: 25px; margin: 20px auto;&#125;#grid-container&#123; width: 460px; height: 460px; padding:20px; margin:50px auto; background-color: #bbada0; border-radius: 10px; position: relative;&#125;.grid-cell&#123; width: 100px; height:100px; border-radius: 6px; background-color: #ccc0b3; position: absolute;&#125;/*对number-cell进行样式设计*/.number-cell&#123; border-radius: 6px; font-family: Arial; font-weight: bold; font-size: 60px; line-height: 100px; text-align: center; position: absolute;&#125; 游戏主逻辑main2048.js代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436var board = new Array();var score = 0;var hasconflict=new Array();//用来标记每个小格子是否发生过碰撞(解决一个bug，例如：2 2 4 8，向左移动时，不能生成16，而是生成4 4 8)var startx;var starty;var endx;var endy;/*当整个程序加载完成后，将运行一个newgame函数 */$(document).ready(function () &#123; //移动端进行游戏前的准备工作 prepareForMobile(); //newgame函数运行 newgame();&#125;);function prepareForMobile()&#123; if(documentWidth&gt;500) &#123; gridContainerWidth=500; cellSpace=20; cellSideLength=100; &#125; $(&apos;#grid-container&apos;).css(&apos;width&apos;,gridContainerWidth-2*cellSpace); $(&apos;#grid-container&apos;).css(&apos;height&apos;,gridContainerWidth-2*cellSpace); $(&apos;#grid-container&apos;).css(&apos;padding&apos;,cellSpace); $(&apos;#grid-container&apos;).css(&apos;border-radius&apos;,0.02*gridContainerWidth); $(&apos;.grid-cell&apos;).css(&apos;width&apos;,cellSideLength); $(&apos;.grid-cell&apos;).css(&apos;height&apos;,cellSideLength); $(&apos;.grid-cell&apos;).css(&apos;border-radius&apos;,0.02*cellSideLength);&#125;function newgame() &#123; //初始化棋盘格 init(); //在随机两个格子生成数字 generateOneNumber();//在16格子随机找一个格子，并随机生成一个数字 generateOneNumber();&#125;function init() &#123; for (var i = 0; i &lt; 4; i++)//对每个小格子的位置进行赋值 &#123; for (var j = 0; j &lt; 4; j++) &#123; // alert(&quot;hahha&quot;); var gridCell = $(&quot;#grid-cell-&quot; + i + &quot;-&quot; + j);//通过id获得小格子 gridCell.css(&apos;top&apos;, getPosTop(i, j));//通过i，j的值，通过getPosTop函数获得top的值 //alert(&quot;xixii&quot;); gridCell.css(&apos;left&apos;, getPosLeft(i, j));//通过i，j的值，通过getPosLeft函数获得left的值 //alert(&quot;wahahah&quot;); //console.log(getPosTop(i,j)+&quot;.......&quot;+getPosLeft(i,j)); &#125; &#125; for (var i = 0; i &lt; 4; i++) &#123; board[i] = new Array();//把board数组生成二维数组 hasconflict[i]=new Array();//把hasconflict数组生成二维数组 for (var j = 0; j &lt; 4; j++)//初始化board数组的值，开始都为零 &#123; board[i][j] = 0; hasconflict[i][j]=false;//初始化为false &#125; &#125; score=0;//初始化，score=0； updateBoardView();//初始化完毕后，需要通知number-cell进行显示的设定 updatescore(score);&#125;function updateBoardView() &#123; $(&quot;.number-cell&quot;).remove();//开始有number-cell这样的元素的话，要统统删除 for (var i = 0; i &lt; 4; i++)//根据board元素设置number-cell的值 &#123; for (var j = 0; j &lt; 4; j++) &#123; //每一个board元素都要生成一个number-cell，在grid-container里面添加number-cell元素 $(&quot;#grid-container&quot;).append(&apos;&lt;div class=&quot;number-cell&quot; id=&quot;number-cell-&apos; + i + &apos;-&apos; + j + &apos;&quot;&gt;&lt;/div&gt;&apos;);//这里写错了，检查了半天(格式注意一下啊)) var theNumberCell = $(&quot;#number-cell-&quot; + i + &apos;-&apos; + j);//用来操作当前number-cell if (board[i][j] == 0)//board的值，对应number-cell的样式也不同 &#123; theNumberCell.css(&apos;width&apos;, &apos;0px&apos;);//把number-cell的宽和高设置为零，让它不显示 theNumberCell.css(&apos;height&apos;, &apos;0px&apos;); //theNumberCell.css(&apos;top&apos;, getPosTop(i, j) + &apos;50px&apos;);原网页是这样的 theNumberCell.css(&apos;top&apos;, getPosTop(i, j) + cellSideLength/2);//getPosTop计算了每个（数字框）的上边的位置 //theNumberCell.css(&apos;left&apos;, getPosTop(i, j) + &apos;50px&apos;); theNumberCell.css(&apos;left&apos;, getPosLeft(i, j) + cellSideLength/2);//getPosLeft计算了每个（数字框）的左边的位置 &#125; else//board的值不为零时和grid-cell的样式是一样的 &#123; //theNumberCell.css(&apos;width&apos;, &apos;100px&apos;); theNumberCell.css(&apos;width&apos;, cellSideLength); //theNumberCell.css(&apos;height&apos;, &apos;100px&apos;); theNumberCell.css(&apos;height&apos;, cellSideLength); theNumberCell.css(&apos;top&apos;, getPosTop(i, j)); theNumberCell.css(&apos;left&apos;, getPosLeft(i, j)); theNumberCell.css(&apos;background-color&apos;, getNumberBackgroundColor(board[i][j]));//这时每一个number-cell的背景色也不同（根据board的值不同而不同） theNumberCell.css(&apos;color&apos;, getNumberColor(board[i][j]));//这时每一个number-cell的前景色也不同 theNumberCell.text(board[i][j]);//number-cell要显示board[i][j]的值 &#125; hasconflict[i][j]=false;//显示完之后，要把hasconflict重新置为false &#125; $(&apos;.number-cell&apos;).css(&apos;line-height&apos;,cellSideLength+&apos;px&apos;);//在css中将number-cell对应的行高进行改写 $(&apos;.number-cell&apos;).css(&apos;font-size&apos;,0.6*cellSideLength+&apos;px&apos;);//将字号进行设置 &#125;&#125;function generateOneNumber() &#123; if (nospace(board))//首先要判断一下，当前情况还能不能随机生成一个数字，判断4×4还有空间，就能生成 return false; //随机一个位置 var randx = parseInt(Math.floor(Math.random() * 4)); var randy = parseInt(Math.floor(Math.random() * 4)); /*while (true) &#123; if (board[randx][randy] == 0) break; randx = parseInt(Math.floor(Math.random() * 4)); randy = parseInt(Math.floor(Math.random() * 4)); &#125;*/ //优化寻找空位置的算法,只让他寻找五十次，如果找不到，就人工查找 var time=0; while (time&lt;50) &#123; if (board[randx][randy] == 0) break; randx = parseInt(Math.floor(Math.random() * 4)); randy = parseInt(Math.floor(Math.random() * 4)); time++; &#125; if(time==50) &#123; for(var i=0; i&lt;4; i++) &#123; for(var j=0; j&lt;4; j++) &#123; if(board[i][j]==0) &#123; randx=i; randy=j; break; &#125; &#125; &#125; &#125; //生成随机一个数字 var randNumber = Math.random() &lt; 0.5 ? 2 : 4; //在随机位置显示随机数字 board[randx][randy] = randNumber; //出现一个随机数显示一个动画效果 showNumberWithAnimation(randx, randy, randNumber); return true;&#125;/*没按下一个键，进行循环 */$(document).keydown(function (event) &#123; // event.preventDefault();//禁止页面进行上下移动 switch (event.keyCode) &#123; case 37://left event.preventDefault();//禁止页面进行上下移动 if (moveLeft())//向左移动，首先判断是否可以进行左边移动 &#123; setTimeout(&quot;generateOneNumber()&quot;,210);//生成一个随机数 setTimeout(&quot;isgameover()&quot;,300);//判断是否游戏结束 &#125; break; case 38://up event.preventDefault();//禁止页面进行上下移动 if (moveUp())//判断是否可以进行向上边移动 &#123; setTimeout(&quot;generateOneNumber()&quot;,210);//生成一个随机数 setTimeout(&quot;isgameover()&quot;,300);//判断是否游戏结束 &#125; break; case 39://right event.preventDefault();//禁止页面进行上下移动 if (moveRight())//判断是否可以进行向右边移动 &#123; setTimeout(&quot;generateOneNumber()&quot;,210);//生成一个随机数 setTimeout(&quot;isgameover()&quot;,300);//判断是否游戏结束 &#125; break; case 40://down event.preventDefault();//禁止页面进行上下移动 if (moveDown())//判断是否可以进行向下边移动 &#123; setTimeout(&quot;generateOneNumber()&quot;,210);//生成一个随机数 setTimeout(&quot;isgameover()&quot;,300);//判断是否游戏结束 &#125; break; default: break; &#125;&#125;);/**document上增加一个事件监听器，监听touchstart这个事件，捕捉这个事件，将响应一个匿名函数 * event会存储相关的信息 */document.addEventListener(&apos;touchstart&apos;,function(event)&#123; startx=event.touches[0].pageX; starty=event.touches[0].pageY;&#125;); document.addEventListener(&apos;touchmove&apos;,function(event)//用来解决手指识别不管用的bug&#123; event.preventDefault();&#125;);document.addEventListener(&apos;touchend&apos;,function(event)&#123; endx=event.changedTouches[0].pageX; endy=event.changedTouches[0].pageY; var deltax=endx-startx; var deltay=endy-starty; if(Math.abs(deltax)&lt;0.3*documentWidth&amp;&amp;Math.abs(deltay)&lt;0.3*documentWidth)//当滑动的距离小于一定距离时，就判断它不是滑动操作 &#123; return; &#125; //x方向 if(Math.abs(deltax)&gt;Math.abs(deltay)) &#123; if(deltax&gt;0)//向x的正方向移动 &#123; if (moveRight())//判断是否可以进行向右边移动 &#123; setTimeout(&quot;generateOneNumber()&quot;,210);//生成一个随机数 setTimeout(&quot;isgameover()&quot;,300);//判断是否游戏结束 &#125; &#125; else//向x轴的负方向移动 &#123; if (moveLeft())//向左移动，首先判断是否可以进行左边移动 &#123; setTimeout(&quot;generateOneNumber()&quot;,210);//生成一个随机数 setTimeout(&quot;isgameover()&quot;,300);//判断是否游戏结束 &#125; &#125; &#125; else//y方向 &#123; if(deltay&lt;0)//向上移动(注意屏幕坐标是向下的,和数学坐标是不一样的) &#123; if (moveUp())//判断是否可以进行向上边移动 &#123; setTimeout(&quot;generateOneNumber()&quot;,210);//生成一个随机数 setTimeout(&quot;isgameover()&quot;,300);//判断是否游戏结束 &#125; &#125; else//向下移动 &#123; if (moveDown())//判断是否可以进行向下边移动 &#123; setTimeout(&quot;generateOneNumber()&quot;,210);//生成一个随机数 setTimeout(&quot;isgameover()&quot;,300);//判断是否游戏结束 &#125; &#125; &#125;&#125;);function isgameover() &#123; if(nospace(board)&amp;&amp;nomove(board))//如果棋盘格占满，并且真的不能移动了(相邻间没有相等的数字) &#123; gameover(); &#125;&#125;function gameover()&#123; alert(&apos;gameover&apos;);&#125;/** 这里出现了问题*/function moveUp()&#123; if (canmoveup(board) == false) &#123; return false; &#125; //moveLeft for (var i = 0; i &lt; 4; i++) &#123; for (var j = 1; j &lt; 4; j++) &#123; if (board[j][i] != 0)//如果这个数不为零 &#123; for (var k = 0; k &lt; j; k++) &#123; if (board[k][i] == 0 &amp;&amp; notroublevert(i, k, j, board))//如果这个数为零，而且board[j][i]到board[k][i]之间没有非零数字 &#123; //move showmoveanimaton(k, i, j, i);//显示动画 //alert(&quot;heregoing&quot;); board[k][i] = board[j][i]; board[j][i] = 0; continue; &#125; else if (board[k][i] == board[j][i] &amp;&amp;notroublevert(i, k, j, board)&amp;&amp;hasconflict[k][i]==false)//如果这个数和board[i][j]相等，而且board[i][j]到board[i][k]之间没有非零数字 &#123; //move showmoveanimaton(k, i, j, i);//显示动画 //add board[k][i] += board[j][i]; board[j][i] = 0; score+=board[k][i]; updatescore(score);//通知前台更新score hasconflict[k][i]=true; continue; &#125; &#125; &#125; &#125; &#125; setTimeout(&quot;updateBoardView()&quot;,200);//初始化完毕后，需要通知number-cell进行显示的设定 //alert(&quot;aa&quot;); return true;&#125;function moveDown()&#123; if (canmovedown(board) == false) &#123; return false; &#125; //moveDown //alert(&quot;haha&quot;); for (var i = 0; i &lt; 4; i++) &#123; for (var j = 2; j &gt;=0; j--) &#123; if (board[j][i] != 0)//如果这个数不为零 &#123; for (var k = 3; k &gt;j; k--) &#123; //alert(&quot;row=&quot;+j); //alert(&quot;cols=&quot;+i); if (board[k][i] == 0 &amp;&amp; notroublevert(i, j, k, board))//如果这个数为零，而且board[j][i]到board[k][i]之间没有非零数字 &#123; //move //alert(&quot;heregoing&quot;); showmoveanimaton(k, i, j, i);//显示动画 board[k][i] = board[j][i]; board[j][i] = 0; continue; &#125; else if (board[k][i] == board[j][i] &amp;&amp;notroublevert(i, j, k, board)&amp;&amp;hasconflict[k][i]==false)//如果这个数和board[i][j]相等，而且board[i][j]到board[i][k]之间没有非零数字 &#123; //move showmoveanimaton(k, i, j, i);//显示动画 //add board[k][i] += board[j][i]; board[j][i] = 0; score+=board[k][i]; updatescore(score);//通知前台更新score hasconflict[k][i]=true; continue; &#125; &#125; &#125; &#125; &#125; setTimeout(&quot;updateBoardView()&quot;,200);//初始化完毕后，需要通知number-cell进行显示的设定 //alert(&quot;aa&quot;); return true;&#125;function moveLeft() &#123; if (canmoveleft(board) == false)//判断是否可以向左移动 &#123; return false; &#125; //moveLeft for (var i = 0; i &lt; 4; i++) &#123; for (var j = 1; j &lt; 4; j++) &#123; if (board[i][j] != 0)//如果这个数不为零 &#123; for (var k = 0; k &lt; j; k++) &#123; if (board[i][k] == 0 &amp;&amp; notroublehori(i, k, j, board)) &#123; //move showmoveanimaton(i, k, i, j);//显示动画 //alert(&quot;heregoing&quot;); board[i][k] = board[i][j]; board[i][j] = 0; continue; &#125; else if (board[i][k] == board[i][j] &amp;&amp; notroublehori(i, k, j, board)&amp;&amp;hasconflict[i][k]==false) &#123; //move showmoveanimaton(i, k, i, j);//显示动画 //add board[i][k] += board[i][j]; board[i][j] = 0; //addscore score+=board[i][k]; updatescore(score);//通知前台更新score hasconflict[i][k]=true; continue; &#125; &#125; &#125; &#125; &#125; setTimeout(&quot;updateBoardView()&quot;,200);//初始化完毕后，需要通知number-cell进行显示的设定 return true;&#125;function moveRight() &#123; if (canmoveright(board) == false)//判断是否可以向左移动 &#123; return false; &#125; //moveLeft for (var i = 0; i &lt; 4; i++) &#123; for (var j = 2; j &gt;=0; j--) &#123; if (board[i][j] != 0)//如果这个数不为零 &#123; for (var k = 3; k &gt; j; k--) &#123; if (board[i][k] == 0 &amp;&amp; notroublehori(i, j, k, board)) &#123; //move showmoveanimaton(i, k, i, j);//显示动画 //alert(&quot;heregoing&quot;); board[i][k] = board[i][j]; board[i][j] = 0; continue; &#125; else if (board[i][k] == board[i][j] &amp;&amp; notroublehori(i, j, k, board)&amp;&amp;hasconflict[i][k]==false) &#123; //move showmoveanimaton(i, k, i, j);//显示动画 //add board[i][k] += board[i][j]; board[i][j] = 0; score+=board[i][k]; updatescore(score);//通知前台更新score hasconflict[i][k]=true; continue; &#125; &#125; &#125; &#125; &#125; setTimeout(&quot;updateBoardView()&quot;,200);//初始化完毕后，需要通知number-cell进行显示的设定 return true;&#125; 动画效果逻辑showanimation.js代码：123456789101112131415161718192021222324252627282930function showNumberWithAnimation(i,j,randNumber)&#123; var numberCell=$(&quot;#number-cell-&quot;+i+&quot;-&quot;+j);//显示随机数的时候需要用到number-cell numberCell.css(&apos;background-color&apos;,getNumberBackgroundColor(randNumber)); numberCell.css(&apos;color&apos;,getNumberColor(randNumber)); numberCell.text(randNumber); numberCell.animate(&#123; /*width:&quot;100px&quot;,*/ width:cellSideLength, /*height:&quot;100px&quot;,*/ height:cellSideLength, top:getPosTop(i,j), left:getPosLeft(i,j) &#125;,50);&#125;function showmoveanimaton(tox,toy,fromx,fromy)&#123; var numbercell=$(&apos;#number-cell-&apos;+fromx+&apos;-&apos;+fromy);//通过id获得小格子(要移动的数) numbercell.animate(&#123;/*将这个number-cell进行动画的改变，移动到getPosTop(tox,toy)，getPosLeft(tox,toy)这个位置，在200ms内完成*/ top:getPosTop(tox,toy), left:getPosLeft(tox,toy) &#125;,200);&#125;function updatescore(score)&#123; $(&apos;#score&apos;).text(score);//拿到socre显示的id，让它的文本变成新的score&#125; 底层支撑逻辑support.js代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/**获取屏幕尺寸宽度 */documentWidth=window.screen.availWidth;/**获取游戏大方块的尺寸 */gridContainerWidth=0.92*documentWidth;/**获取游戏每个小方块的尺寸 */cellSideLength = 0.18*documentWidth;/**获取游戏每个小方块之间的间距尺寸 */cellSpace = 0.04*documentWidth;function getPosTop(i,j)&#123; //return 20+i*(20+100); return cellSpace+i*(cellSpace+cellSideLength);&#125;function getPosLeft(i,j)&#123; //return 20+j*(20+100); return cellSpace+j*(cellSpace+cellSideLength);&#125;function getNumberBackgroundColor(number)&#123; switch(number) &#123; case 2:return &quot;#eee4da&quot;;break; case 4:return &quot;#ede0c8&quot;;break; case 8:return &quot;#ede0c8&quot;;break; case 16:return &quot;#ede0c8&quot;;break; case 32:return &quot;#f2b179&quot;;break; case 64:return &quot;#f59563&quot;;break; case 128:return &quot;#f67c5f&quot;;break; case 256:return &quot;#f65e3b&quot;;break; case 512:return &quot;#edcf72&quot;;break; case 1024:return &quot;#edcc61&quot;;break; case 2048:return &quot;#9c0&quot;;break; case 4096:return &quot;#a6c&quot;;break; case 8192:return &quot;#93c&quot;;break; &#125; return &quot;black&quot;;&#125;function getNumberColor(number)&#123; if(number&lt;=4)//当值小于4时，一种颜色 return &quot;#776e65&quot;; return &quot;white&quot;;//当值大于4时，是白色&#125;function nospace(board)//判断格子是否占满，占满就返回true&#123; for(var i=0; i&lt;4; i++) &#123; for(var j=0; j&lt;4; j++) &#123; if(board[i][j]==0) return false; &#125; &#125; return true;&#125;function notroublehori(row,cols1,cols2,board)//水平没有障碍&#123; for(var l=cols1+1; l&lt;cols2; l++) &#123; if(board[row][l]!=0) return false; &#125; return true;&#125;function canmoveleft(board) &#123; for (var i = 0; i &lt; 4; i++) &#123; for (var j = 1; j &lt; 4; j++)//从第二列开始判断 &#123; if (board[i][j] != 0) &#123; if (board[i][j - 1] == 0 || board[i][j - 1] == board[i][j])//当左边的格子的数值为零或者数值和自己相等时，就可以向左移动 return true; &#125; &#125; &#125; return false;&#125;function canmoveup(board)&#123; for (var i = 0; i &lt; 4; i++) &#123; for (var j = 1; j &lt; 4; j++)//从第二行开始判断 &#123; if (board[j][i] != 0) &#123; if (board[j-1][i] == 0 || board[j-1][i] == board[j][i])//当上边的格子的数值为零或者数值和自己相等时，就可以向左移动 return true; &#125; &#125; &#125; return false; &#125;function notroublevert(cols, row2, row1, board)/**垂直没有障碍i列，k行到j行 */&#123; for(var l=row2+1; l&lt;row1; l++) &#123; if(board[l][cols]!=0) return false; &#125; return true;&#125;function canmoveright(board)&#123; for (var i = 0; i &lt; 4; i++) &#123; for (var j = 0; j &lt; 3; j++) &#123; if (board[i][j] != 0) &#123; if (board[i][j+1] == 0 || board[i][j+1] == board[i][j])//当右边的格子的数值为零或者数值和自己相等时，就可以向左移动 return true; &#125; &#125; &#125; return false; &#125;function canmovedown(board)&#123; for (var i = 0; i &lt; 4; i++) &#123; for (var j =0; j &lt; 3; j++)//从第二行开始判断 &#123; if (board[j][i] != 0) &#123; if (board[j+1][i] == 0 || board[j+1][i] == board[j][i])//当下边的格子的数值为零或者数值和自己相等时，就可以向左移动 return true; &#125; &#125; &#125; return false; &#125;function nomove(board)&#123; if(canmovedown(board)||canmoveleft(board)||canmoveright(board)||canmoveup(board))//不可以上下左右移动 return false; return true;&#125; 最后的显示效果 游戏代码下载地址链接地址]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[html标签的使用]]></title>
    <url>%2F2019%2F10%2F02%2Fhtml%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[html标签的使用超链接标签链接资源&lt;a href=&quot;链接到资源的路径&quot;&gt; 显示在页面上的内容 &lt;/a&gt;href: 链接的资源的地址target: 设置打开的方式，默认是当前页面打开 _self: 在当前页面打开 _blank: 在一个新窗口打开当超链接不需要到任何的地址，在href里面加# 定位资源如果想要定位资源，定义一个位置&lt;a name=&quot;top&quot;&gt; 顶部 &lt;/a&gt;回到这个位置&lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;引入一个标签pre: 原样输出 表格标签&lt;table&gt;&lt;/table&gt; :表示表格的范围border：表格线的粗细度bordercolor： 表格线颜色cellspacing：单元格之间的距离withth：表格的宽度heigth：表格的高度&lt;tr&gt;&lt;/tr&gt;：表示一行设置对齐方式align：left center right&lt;td&gt;&lt;/td&gt;：表示一个单元格操作技巧:首先数有多少行，每行有多少个单元格 表单标签&lt;form&gt;&lt;/form&gt;：表单标签的范围输入项：可以输入内容或者选择内容的部分 -大部分的输入项 使用&lt;input type=&quot;输入项的类型&quot;/&gt; 普通输入项：&lt;input type=&quot;text&quot;/&gt; 密码输入项：&lt;input type=&quot;password&quot;/&gt; 单选输入项：&lt;input type=&quot;radio&quot;/&gt; 在里面需要属性 name name的属性值必须要相同 复选输入项：&lt;input type=&quot;checkbox&quot;/&gt; 在里面需要属性 name name的属性值必须要相同 文件输入项: &lt;input type=&quot;file&quot;/&gt; 下拉输入项：&lt;select name=&quot;birth&quot;&gt; &lt;option value=&quot;0&quot;&gt;选择年份&lt;/option&gt; &lt;option value=&quot;1992&quot;&gt;1992&lt;/option&gt; &lt;option value=&quot;1993&quot;&gt;1993&lt;/option&gt;&lt;/select&gt; 文本域: `&lt;textarea cols=&quot;10&quot; rows=&quot;40&quot;&gt;&lt;/textarea&gt;` cols：多少列 rows：多少行 `&lt;input type=&quot;file&quot;/&gt;`]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的基本用法]]></title>
    <url>%2F2019%2F07%2F30%2FMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown的基本用法tagstags是标签，可以在tags：后面加标签。例如： - 导航 //就会有导航标签 - 分享 //就会有分享标签 标题#一个#加个空格是一级标题##两个#加个空格是二级标题###三个#加个空格是三级标题 categoriescategories是分类，可以在categories： 后面加分类。例如： categories: PAT乙级就会有PAT乙级标签 列表- 列表名就会出现列表例如： - 列表一就会显示：。列表一 链接[链接名字](链接地址)例如：[PAT乙级](https://pintia.cn/problem-sets/994805260223102976/problems/type/7)就会显示PAT乙级链接，通过点击PAT乙级链接就可以到PAT乙级网站 插入图片![图片名](链接地址)就会显示图片例如：![美女图片](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1564494317057&amp;di=8c6aaf9a225e374ce10a89a7266bb688&amp;imgtype=0&amp;src=http%3A%2F%2Fimg4.duitang.com%2Fuploads%2Fitem%2F201302%2F04%2F20130204093707_dPZSV.thumb.700_0.png)就会出现美女图片 字体*字*就会显示斜的”字”例如：字**字**字就会被加粗例如：字是不是被加粗了呢 引用代码一个引号+代码+一个引号，这是引用单行的代码三个引号+多行的代码+三个引号，这是引用多行的代码 一行直线---三个-***三个*例如： 引用别人的文章&gt; 引用哪个人的文章就会显示哪个人文章的字 我的文章是引用某个人的]]></content>
      <categories>
        <category>Markdown的基本用法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[福尔摩斯的约会]]></title>
    <url>%2F2018%2F04%2F05%2F%E7%A6%8F%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[题目：题目链接大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。输入格式：输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。输出格式：在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。输入样例：3485djDkxh4hhGE2984akDfkkkkggEdsbs&amp;hgsfdkd&amp;Hyscvnm输出样例：THU 14:04 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;int main(void)&#123; char day[7][7]= &#123;&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot;&#125;; char time[25]= &#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,&apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;&#125;; char str1[100],str2[100],str3[100],str4[100]; scanf(&quot;%s&quot;,str1); scanf(&quot;%s&quot;,str2); scanf(&quot;%s&quot;,str3); scanf(&quot;%s&quot;,str4); int len1,len2,len3,len4,i; len1=strlen(str1); len2=strlen(str2); len3=strlen(str3); len4=strlen(str4); char D,T; int M=0,j; bool flag=false; for(i=0; i&lt;len1&amp;&amp;i&lt;len2; i++) &#123; if(str1[i]&gt;=&apos;A&apos;&amp;&amp;str1[i]&lt;=&apos;G&apos;) &#123; if(str1[i]==str2[i]) &#123; D=str2[i]; flag=true; j=i; break; &#125; &#125; &#125; for(i=j+1; i&lt;len1&amp;&amp;i&lt;len2; i++) &#123; if(str1[i]&gt;=&apos;A&apos;&amp;&amp;str1[i]&lt;=&apos;N&apos;||str1[i]&gt;=&apos;0&apos;&amp;&amp;str1[i]&lt;=&apos;9&apos;) &#123; if(str1[i]==str2[i]&amp;&amp;flag==true) &#123; T=str2[i]; break; &#125; &#125; &#125; for(i=0; i&lt;len3&amp;&amp;i&lt;len4; i++) &#123; if(str3[i]&gt;=&apos;A&apos;&amp;&amp;str3[i]&lt;=&apos;Z&apos;||str3[i]&gt;=&apos;a&apos;&amp;&amp;str3[i]&lt;=&apos;z&apos;) &#123; if(str3[i]==str4[i]) &#123; M=i; break; &#125; &#125; &#125; int s=0; while(s+&apos;A&apos;!=D) &#123; s++; &#125; printf(&quot;%s &quot;,day[s]); for(i=0; i&lt;=23; i++) &#123; if(T==time[i]) &#123; printf(&quot;%02d&quot;,i); break; &#125; &#125; printf(&quot;:%02d&quot;,M); return 0;&#125; 分析：1.前面两字符串中第1对相同的大写英文字母（因为代表星期一到星期天），所以范围是AG；2.前面两字符串中字符的范围是由数字0到9、以及大写字母A到N表示，自己想当然的以为是09或az或AZ，如果是小写字幕的话，把他的ASCII码减去32，得到大写字母，这种想法导致错误的答案3.后面两字符串中字符的范围是az或者AZ]]></content>
      <categories>
        <category>PAT乙级练习</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
